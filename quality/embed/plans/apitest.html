<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="top" title="Home" href="http://www.mozilla.org/">
<link rel="stylesheet" type="text/css" href="../../../css/print.css"  media="print">
<link rel="stylesheet" type="text/css" href="../../../css/base/content.css"  media="all">
<link rel="stylesheet" type="text/css" href="../../../css/cavendish/content.css" title="Cavendish" media="screen">
<link rel="stylesheet" type="text/css" href="../../../css/base/template.css"  media="screen">
<link rel="stylesheet" type="text/css" href="../../../css/cavendish/template.css" title="Cavendish" media="screen">
<link rel="icon" href="../../../images/mozilla-16.png" type="image/png">

  <meta name="author" content="David Epstein">
  <meta name="GENERATOR"
  <title>Embedding API Approaches</title>
<script src="../../../__utm.js" type="text/javascript"></script>
</head>
<body id="www-mozilla-org" class="deepLevel">
<div id="container">
<p class="important">You are currently viewing a snapshot of www.mozilla.org taken on April 21, 2008. Most of this content is
highly out of date (some pages haven't been updated since the project began in 1998) and exists for historical purposes only.  If
there are any pages on this archive site that you think should be added back to www.mozilla.org, please <a
href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Websites&component=www.mozilla.org">file a bug</a>.</p>
<p class="skipLink"><a href="#mainContent" accesskey="2">Skip to main content</a></p>
<div id="header">
<h1><a href="/" title="Return to home page" accesskey="1">Mozilla</a></h1>
<ul>
<li id="menu_aboutus"><a href="../../../about/" title="Getting the most out of your online experience">About</a></li>
<li id="menu_developers"><a href="../../../developer/" title="Using Mozilla's products for your own applications">Developers</a></li>
<li id="menu_store"><a href="http://store.mozilla.org/?r=mozorg1" title="Shop for Mozilla products on CD and other merchandise">Store</a></li>
<li id="menu_support"><a href="../../../support/" title="Installation, trouble-shooting, and the knowledge base">Support</a></li>
<li id="menu_products"><a href="../../../products/" title="All software Mozilla currently offers">Products</a></li>
</ul>
<form id="searchbox_002443141534113389537:ysdmevkkknw" action="http://www.google.com/cse" title="mozilla.org Search">
<div>
<label for="q" title="Search mozilla.org's sites">search mozilla:</label>
<input type="hidden" name="cx" value="002443141534113389537:ysdmevkkknw">
<input type="hidden" name="cof" value="FORID:0">
<input type="text" id="q" name="q" accesskey="s" size="30">
<input type="submit" id="submit" value="Go">
</div>
</form>
</div>
<hr class="hide">
<div id="mBody">
<div id="side">

<ul id="nav">
<li><a title="Roadmap" href="../../../roadmap.html"><strong> Roadmap</strong></a></li>
<li><a title="Projects" href="../../../projects/"><strong> Projects</strong></a></li>
<li><a title="For developers" href="../../../developer/"><strong> Coding</strong></a>
<ul>
<li><a title="Module Owners" href="../../../owners.html"> Module Owners</a></li>
<li><a title="Hacking" href="../../../hacking/"> Hacking</a></li>
<li><a title="Get the Source" href="http://developer.mozilla.org/en/docs/Download_Mozilla_Source_Code"> Get the Source</a></li>
<li><a title="Building Mozilla" href="http://developer.mozilla.org/en/docs/Build_Documentation"> Build It</a></li>
</ul>
</li>
<li><a title="Testing" href="../../../quality/"><strong> Testing</strong></a>
<ul>
<li><a title="Downloads of mozilla.org software releases" href="../../../download.html"> Releases</a></li>
<li><a title="Latest mozilla builds for testers" href="../../../developer/#builds"> Nightly Builds</a></li>
<li><a title="For testers to report bugs" href="https://bugzilla.mozilla.org/"> Report A Problem</a></li>
</ul>
</li>
<li><a title="Tools for mozilla developers" href="../../../tools.html"><strong> Tools</strong></a>
<ul>
<li><a title="Bug tracking system for mozilla testers." href="https://bugzilla.mozilla.org/"> Bugzilla</a></li>
<li><a title="Latest status of mozilla builds" href="http://tinderbox.mozilla.org/showbuilds.cgi?tree=Firefox"> Tinderbox</a></li>
<li><a title="Latest checkins" href="http://bonsai.mozilla.org/cvsqueryform.cgi"> Bonsai</a></li>
<li><a title="Source cross reference" href="http://lxr.mozilla.org/seamonkey/"> LXR</a></li>
</ul>
</li>
<li><a title="Frequently Asked Questions." href="../../../faq.html"><strong> FAQs</strong></a></li>
</ul>

</div>
<hr class="hide">
<div id="mainContent">




<hr class="hide">

<center><b>Embedding API Testing Approaches</b></center>
<ol type="I">
<li><b>Introduction</b></li>
<p>This document will explore different approaches that can be applied
to methodically test the Embedding API set. These APIs are used by application
programmers to render, display, and manipulate web content in an embedded
framework (i.e. customized browsers). The role of Quality Assurance will be to 
insure that the APIs are functioning correctly within a variety of contexts.&nbsp;
<br>
&nbsp;
</p>
<li><b>Dependencies</b></li>
<p>In order to write test drivers to exercise these APIs, the following are necessary:
&nbsp;<br>
</p>
<ol type="a">
<li>
Pull and Build the latest Mozilla source.</li>
<li>
Install Visual C++ or some other C++ compiler.</li>
<li>
Utilize existing test applications like <a
 href="http://lxr.mozilla.org/seamonkey/source/embedding/qa/testembed/">testEmbed</a>&nbsp;
or <a
 href="http://lxr.mozilla.org/seamonkey/source/embedding/tests/mfcembed/">MfcEmbed</a>.&nbsp;</li>
<li>
Modify existing apps and/or design new ones suitable for testing the APIs.</li>
<li>
General knowledge and code walkthroughs of the APIs and interfaces (idl
files and source code).&nbsp;</li>
</ol>
<p>The build process will not be described in this document.
For more info on that, go to:<a href="http://www.mozilla.org/build/win32.html">
http://www.mozilla.org/build/win32.html</a>
</p>
<p>Utilizing existing test apps and creating new ones will be discussed
in this document.
<br>
&nbsp;
</p>
<li><b>The API Testing Process</b></li>
<p>Here is an outline of QAs process for performing effective functional
testing. It will be further described in subsequent sections:
<br>
&nbsp;
</p>
<ol type="a">
<li>
Define an input process to call interfaces, feed data into API methods,
and use attributes. Two ideas that come to mind are script-executed calls
relayed to the APIs, and entry of data from dialogs within a GUI test app
like MfcEmbed. The general data format of test input is "interface : method :
method input data". (e.g. nsIWebNavigation: loadURI() : uri,
loadFlags).
The format for testing attributes would be something like "interface : attribute
: method used with attribute" (e.g. nsILoadGroup : mDefaultLoadRequest
: GetName() ).</li>
<li>
Propagate test driver execution. These are tests that will directly test
the interfaces, API methods, and attributes, either one at a time or grouped
together. The drivers can be executed within the context of a test app
or independently from a shell environment.</li>
<li>
Capture results from driver execution. This can be done with callbacks
sent directly to dialogs, if inside a test app, and/or to an output log
file. The captured data would include which interfaces and methods were
called, invoked attributes, and results from executing these methods.</li>
<li>
Validation of Results. When applicable, results from test execution will
be checked with internal test code (e.g. string compares) or by comparison
to baseline output files. If checked internally in the test app, then
pass/fail determination will occur before printing the results to the logfile.
Otherwise, file comparisons between test output and baseline file(s) will be
performed.</li>
<br>
</ol>
<center><img src="qa.gif"></center>
<p>Note that there are different considerations for testing synchronous
and asynchronous processes. For synchronous ones, a straighforward tracking
of entry and exit points of API methods will suffice. For asynchronous
ones, where timing and event handling occur, we will be concerned with
what events are triggered, callbacks from asynchronous processes, if
they return at all, the sequence of callbacks, cancellation and timeout issues. The
monitoring of these processes are more involved and will be discussed in later sections.
</p>
<li><b>Different Approaches</b></li>
<p>There are a few testing approaches to choose from. Each one will be
briefly discussed with emphasis upon how they can be applied to the task
at hand. Variations as well as combinations of such approaches might work
as well.
<br>
&nbsp;
</p>
<ol type="a">
<li>
<b>Use an existing test application</b>. Use hooks inside of the app to
accept interface and method calls routed to the APIs. This can be done
by sending JavaScript functions from an html file that pass data to the
test app. The results of these test executions would be captured and
printed to a logfile. They possibly could be validated using JS calls. See
mfcembed.htm for examples of how it utilizes CreateBrowserWindow() method of the
nsIWebBrowserChrome interface.</li>
<p>The benefit of this approach is that it could exercise the APIs utilized
by an existing test app. We wouldn't have to start from scratch. QA would
write the functions to cover all the applicable permutations of each API.
Breakpoints could be setup in the test app (e.g. MfcEmbed) to view how
the data inputs and callbacks were being handled. One downside I can see
is that it might become a file management problem if a great many files
are created.
<br>
&nbsp;
</p>
<li><b>Create a test bed framework</b>. This approach would in effect modify
an existing app to make it more QA friendly, or would require designing
a base test app. The setup would be configured to load a base framework
when the app is launched. This framework would be the creation of the browser
frame, a browser view (creating the first instance of the embedded browser),
and a glue interface binding the frame with a set of required Gecko implementations.
Once this framework was loaded, then menu items could be selected in the
app to load the chrome, test UI routines (e.g. windowing, cut/paste, view
source, etc), exercise listener interfaces and handle callbacks, and
run network API tests for such areas as <a
href="http://lxr.mozilla.org/seamonkey/source/netwerk/protocol/http/public/nsIHttpChannel.idl">httpChannel</a>
(request methods) and protocol handler.</li>
<p>One advantage of this approach is that a minimal framework would itself
be utilizing a core set of APIs. If the framework wasnt created during
launch, then it would be easier to isolate the problem to one of these
APIs if in fact in was the culprit. Once successfully launched, additional
tests would be performed by selecting menu items. These selections could
correspond to embedding interfaces. Cascading menus would be created to
handle nested API methods, or a dialog could be displayed for user selection
of method, parameter inputs, or execution of a sequence of APIs.&nbsp;
</p>
<p>Alternatively, the menus would correspond to well-formulated test cases.
For example, one menu item might be for resizing the browser, another for
activating a web progress listener routine, and so forth. In either case,
the menus would be thematically grouped together: listeners/callbacks,
prompts, windows/viewers, file handling, profiles, or grouping by interface.
</p>
<p>The downside is that time would have to be invested to reconfigure an
existing test app or create a new one. That involves using native classes
(i.e. MFC) and interfaces.
<br>
&nbsp;
<br>
</p>
<center>
<p><img src="frame.gif"></p>
</center>
<li>
<b>Use command line script activation, calling native app test harness</b>
. Here, the main idea is that the scripts would be cross-platform while
the apps would be written to test the APIs for that specific platform.
One idea is that a Perl driver would dispatch commands to the native app
which in turn would handle them as separate tests. The test app could be
written as a shell app to make it easier to port to other platforms.</li>
<p>The native app would have a command handler to accept and process these
commands. Entry and exit points would be tracked to determine what values
are actually passed to and returned from the API methods. This information
would be printed to a log file.
</p>
<p>In addition, a nonintrusive profiler could be setup to instrument the
code, monitoring their various state transitions (such as found in listener
processes: registration, embedded object handling, invoking the listener,
and notification). For each state, a print statement would be made to a
stack trace, a written record of the state and call histories of the exercised
APIs. This would make it easier for QA to isolate bugs that will be nested
in the APIs.
</p>
<p>The profiler could also monitor other processes like the spawning of
threads. This could be valuable to check parent/child thread handling,
ref counts, and tracking memory leaks.
<br>
<br>
</p>
<center>
<p><img src="profiler.gif"></p>
</center>
<li>
<b>Write class libraries for QA usage</b>. This would provide standard
methods for invoking actions like data creation, feeding data input into
API methods, capturing results and printing to a log file, monitoring
internal states, and bug tracking.
The class libraries most likely would be written in C++. They would be
primarily written to make it easier for QA to write their test drivers,
utilize shared code and perform cross-platform testing. This approach can
be used in conjunction with any of the other approaches, but most particularly
with the last one discussed.</li>
<br>
&nbsp;
</ol>
<li>
<b>Mixed Strategies</b></li>
<p>As stated above, combinations of approaches might be the prefered strategy
for QA. This probably would expand testing coverage, improve efficiency,
and address platform issues. Some of mixed strategies will now be briefly
discussed.
<br>
&nbsp;
</p>
<ol type="a">
<li>
<b>Test architecture</b>. One large test driver or app will become a headache
to maintain and debug. More efficient will be smaller, modular apps each
testing specific functionality. The individual drivers could be linked
together by script execution, but each driver would be called separately
in this case.</li>
<p>If the architecture involves implementing a component model, then each
test component will be assigned specific functionality to test. Data input
sets would be created to test all the permutations and pathways of that
component (say NSPrompts). In addition, there might be codependencies between
components, so data flow and callbacks would have to be identified to properly
capture accurate results.
<br>
&nbsp;
</p>
<li><b>Manual testing and Automation</b>. There will be occasions when test
results will need to be visually inspected to determine if the output is
providing QA with accurate results, and to track down bugs. However, automation
will be used whenever it is convenient to do so. Examples of when
automation can be effective include running acceptance tests on new
builds, performing
regression tests on established APIs, and for sanity checking.</li>
<p>Automation will only be used after QA has implemented a test architecture.
The actual test cases have to be created first before automation can occur.
Script languages like Perl and JavaScript could be used for such purposes.
<br>
&nbsp;
</p>
<li><b>Entry/Exit points, States, and Processes</b>. Every test case should
have sufficiently defined entry and exit criteria to determine passage
or failure of that test. The test case might involve one specific API method
(i.e. resizing a browser window), or might invoke a group of methods (i.e.
to test a listener or observer). For <span style="font-style: italic;">defined
</span>library methods, the entry point will be the actual calling
of the API method(s). Input parameter data, if applicable, will be
seeded into the method. The exit point will be the point where the method returns data
or control back to the calling app. Test results will be logged to the output file.</li>
<p>There will be other tests that have intermediate states to capture,
especially for asynchronous processes. Listeners have various states like
object creation, registration of the listener via IID or contract ID, storage
in the embedded Gecko object, invoking the listener, event handling, and
notification callback. Each state should be tracked and results logged.
<br>
</p>
<p>For asynchronous methods that need to be <span
 style="font-style: italic;">implemented</span> (i.e. listener
notifications), The entry point occurs when it's called by the browser
engine. The methodology is to track when it's called, capture the
parameter values passed to it, set callback switches (if applicable),
and track notification messages returned to the caller. The exit point
is when the series of events is completed (e.g. when a listener is
unregistered).<br>
</p>
<p>Finally, there could be tests to track processes like thread handling,
memory issues, resource management, etc. This would involve additional
implementation besides the direct API tests, and might involve using
debuggers,
profilers, and other tools; but this testing could be valuable to help
developers track down memory leaks, failures, and so forth.
<br>
&nbsp;
</p>
<li><b>Platform vs. Cross-Platform testing</b>. Test apps with GUI are by their
very nature platform specific. An app like MfcEmbed is convenient to run
and add test cases to for Windows testing. But shell apps will be easier
to port to other platforms/OSs like Linux and Mac. Scripts should be written
to be cross platform, yet even when this is the case, there will always
be platform-specific issues. For example, if Perl is used as the script
driver, there will be implementation issues on the Mac (involves utilizing
Apple Events).</li>
<p>From this perspective, the soundest approach will again involve a mixed
strategy. Test apps that effectively test the APIs on one platform should
be used or developed. Cross-platform solutions should be pursued when
reasonable to do so.
<br>
&nbsp;
</p>
<li><b>Browsers, non-Browsers, and User scenario testing</b>.
A browser test
app is a great way to use the API set. There might also be application
developers who will use the APIs to create non-browsers as well, like
client graphic applications. The mixed strategy here is to create different
contexts and user scenarios that capture varying usage of the APIs. In other
words, don't rely on one test app. <br>
</li>
<p>Another consideration is that there might be different ways to invoke
APIs. For example, they can be invoked as methods in objects or as stand
alone method calls. Different class hierarchies and interface calls should
be tried to see if there are no functionality failures.
<br>
&nbsp;</p>
</ol>
<li>
<b>The Listener Process.</b> At the heart of asynchronous processes of
the Embedded APIs are listeners. Listeners (and Observers) are designed
to monitor event handling and capture the resulting callbacks sent to
the calling app. This is accomplished by invoking customized listener
implementations. The state transition methods described above will be
necessary to test these processes. Both the actual occurrence of callbacks
and their sequence will be tracked.</li>
<p>Here is a flow diagram of a typical listener process:
<br>
&nbsp;
<br>
</p>
<center>
<p><img src="listener.gif"></p>
</center>
The process begins with listener registration that is done by adding a
listener. For example, in the <a
 href="http://lxr.mozilla.org/seamonkey/source/uriloader/base/nsIWebProgress.idl">nsIWebProgress
interface</a>, there is addProgressListener(). This method accepts a listener
interface that is called when a progress event occurs. It returns either
NS_OK (successful registration) or NS_INVALID_ARG (a null listener or one
already registered). QA will induce states to return both of these values and
capture the results.
<p>The actual listener process between registration and unregistration
is complex. Various states and notifications can occur during the process.
Most listeners will have flags for three primary states: start, transfer,
and stop. Some listeners support additional states. For example, <a 
href="http://lxr.mozilla.org/seamonkey/source/uriloader/base/nsIWebProgressListener.idl">nsIWebProgressListener
interface </a>also includes states for redirecting and negotiating
(authentication).&nbsp;
</p>
<p>A listener interface should have a method capturing the various
states. Using nsIWebProgressListener as an example, there is the onStateChange()
method. This is a notification that tracks state changes for document load
requests. The situation is further complicated because there can be multiple
windows and url requests, each with its own set of states. QA will write
cases to monitor these sets, their sequence of occurrence, and make sure
that each set accurately corresponds to the correct request.&nbsp;
</p>
<p>In general, depending upon the listener implementations, various sets of state
permutations can occur. Additionally, there are other factors to consider.
For example, different document types and requests are supported. The web
progress listener has flags for full document loading and requests made
from within documents. QA should create a test matrix for each listener
to outline the permutations of state transitions and other factors.
</p>
<p>Finally, after a validation phase that can be accomplished through a
DOM interface, internal checking of results, or interpreting output files,
the listener is deregistered. This is done by removing the listener. In
nsIWebProgress, there is a method called removeProgressListener(). Like
its 'add' counterpart, it returns either NS_OK and NS_ERROR_INVALID_ARG.&nbsp;
</p>
<li><b>Test case example. </b>Here is a sample code snippet utilizing API methods
of the NSIGlobalHistory interface. A global history class is declared in
a header file. Then, there will be the implementation of the methods in
the .cpp file. The two methods are addPage() and IsVisited(); addPage()
adds a URL to the global history while IsVisited() determines if the URL
has been visited. Finally, an instance of NSIGlobalHistory object will
be created in the nsMyBrowserInstance.cpp file. The XPCOM service manager
will register the object via a contract ID, and if the object is recognized,
will call the 2 API methods.&nbsp;</li>
<center>
<p>nsMyGlobalHistory.h:</p>
</center>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "nsIGlobalHistory.h"<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class nsMyGlobalHistory : public nsIGlobalHistory,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public nsISupports<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // implements public interfaces<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS_DECL_ISUPPORTS<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS_DECL_NSIGLOBALHISTORY&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // member variables<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *globalHistoryFile;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *theURL;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // local methods<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void ReadFromGHFile();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void WriteToGHFile(const char *theURL);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRBool SearchForURL(const char *theURL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre>
        <center>nsMyGlobalHistory.cpp:&nbsp;</center>
        <pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "nsMyGlobalHistory.h"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;fstream&gt;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // constructor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nsMyGlobalHistory::nsMyGlobalHistory()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // reads from Global History file<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReadFromGHFile();&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // destructor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nsMyGlobalHistory::~nsMyGlobalHistory()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Updates Global History file<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WriteToGHFile(theURL);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS_IMETHODIMP nsMyGlobalHistory::AddPage(const char *aURL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRBool retVal;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nsresult rv;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofstream output("myfile");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // checks if the url is valid<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!aURL)&nbsp; return NS_ERROR_FAILURE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsVisited(aURL, &amp;retVal);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output &lt;&lt; "IsVisited() returns = " &lt;&lt; retVal &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // will only write to the global history file if the url<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // hasn't been visited.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (retVal == PR_FALSE)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // save url to global history file<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WriteToGHFile(aURL);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NS_ERROR_FAILURE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NS_OK;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS_IMETHODIMP nsMyGlobalHistory::IsVisited(const char *aURL,&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRBool *myRet)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // checks if the url is valid<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (! aURL) return NS_ERROR_FAILURE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (! myRet) return NS_ERROR_FAILURE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // searches for URL in the Global History file&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *myRet = SearchForURL(aURL);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NS_OK;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This registers the object - exposes it to the XPCOM registry.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS_GENERIC_FACTORY_CONSTRUCTOR(nsMyGlobalHistory);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static nsModuleComponentInfo components[] = {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nsMyGlobalHistory",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS_GLOBALHISTORY_CID,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NS_GLOBALHISTORY_CONTRACTID,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nsMyGlobalHistoryConstructor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre>
        <center>nsMyBrowserInstance.h:</center>
        <pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class nsEmbedAPITests<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // test methods<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myGHImpl();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for Global History<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // data<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre>
        <center>nsMyBrowserInstance.cpp:</center>
        <pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "nsMyGlobalHistory.h"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "nsMyBrowserInstance.h"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;fstream&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // test implementation of global history API methods<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void nsEmbedAPITests::myGHImpl()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofstream output("myfile");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // create instance of myHistory object. Call's XPCOM<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // service manager to pass the contract ID.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nsCOMPtr&lt;nsIGlobalHistory&gt; myHistory(do_GetService(NS_GLOBALHISTORY_CONTRACTID));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (myHistory)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nsresult rv;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output &lt;&lt; "Testing addPage(): " &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // adds a url to the global history<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rv = myHistory-&gt;addPage(theURL);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // prints results to output file<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (NS_FAILED(rv))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output &lt;&lt; "addPage() test failed." &lt;&lt; endl;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output &lt;&lt; "addPage() test succeeded." &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output &lt;&lt; "Testing IsVisited(): " &lt;&lt; endl;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // checks if url was visited<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myHistory-&gt;IsVisited(theURL, &amp;theRetVal);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // prints results to output file<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output &lt;&lt; "IsVisited() returned value = " &lt;&lt; theRetVal &lt;&lt; endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // create local test object&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nsEmbedAPITests *localTest;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // execute Global History test<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; localTest-&gt;myGHImpl();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre>
        
<li>
<b>Other Documentation</b>&nbsp;</li>
<p><br>
Here are other docs providing additional information about Embedding APIs:
</p>
<center>
<p><a
 href="http://www.mozilla.org/projects/embedding/PublicAPIs.html">Mozilla Embedding APIs</a>
<br>
&nbsp;<a
 href="http://mozilla.org/quality/embed/plans/JSTestFramework.html">JS Framework</a></p>
</center>
<li>
<b>Revision History</b></li>
<br>
&nbsp;
        <pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; David Epstein.&nbsp; 03/12/01.&nbsp;&nbsp; Created.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; David Epstein.&nbsp; 03/27/01.&nbsp;&nbsp; Added test example.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; David Epstein.&nbsp; 03/30/01.&nbsp;&nbsp; Modified "API Testing Process" section.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; David Epstein.&nbsp; 04/05/01.&nbsp;&nbsp; Enhanced example, added info about async processes.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; David Epstein.&nbsp; 04/12/01.&nbsp;&nbsp; Added section describing listeners.<br>	David Epstein.	07/02/04    Some minor reformatting and updating.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre>
</ol>



<hr class="hide">
</div>
</div>
<div id="footer">
<ul>
<li><a href="../../../sitemap.html">Site Map</a></li>
<li><a href="../../../security/">Security Updates</a></li>
<li><a href="../../../contact/">Contact Us</a></li>
<li><a href="../../../foundation/donate.html">Donate</a></li>
</ul>
<p class="copyright">
Portions of this content are &copy; 1998&#8211;2009 by individual mozilla.org
contributors; content available under a Creative Commons license | <a
href="http://www.mozilla.org/foundation/licensing/website-content.html">Details</a>.</p>
<p>
<span>Last modified July  2,  2004</span>
<span><a href="http://bonsai-www.mozilla.org/cvslog.cgi?file=mozilla-org/html/quality/embed/plans/apitest.html&amp;rev=&amp;root=/www/">Document History</a></span>
</p>
</div>
</div>
</body>
</html>
