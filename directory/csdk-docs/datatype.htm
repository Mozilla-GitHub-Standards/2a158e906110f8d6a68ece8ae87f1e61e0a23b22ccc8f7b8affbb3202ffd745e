<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="top" title="Home" href="http://www.mozilla.org/">
<link rel="stylesheet" type="text/css" href="../../css/print.css"  media="print">
<link rel="stylesheet" type="text/css" href="../../css/base/content.css"  media="all">
<link rel="stylesheet" type="text/css" href="../../css/cavendish/content.css" title="Cavendish" media="screen">
<link rel="stylesheet" type="text/css" href="../../css/base/template.css"  media="screen">
<link rel="stylesheet" type="text/css" href="../../css/cavendish/template.css" title="Cavendish" media="screen">
<link rel="icon" href="../../images/mozilla-16.png" type="image/png">

 <title>Mozilla LDAP C SDK: Chapter 17 - Data Types and Structures</title>
 <link rel="prev" href="ref_part.htm">
 <link rel="contents" href="./">
 <link rel="index" href="ix.htm">
 <link rel="next" href="function.htm">
<script src="../../__utm.js" type="text/javascript"></script>
</head>
<body id="www-mozilla-org" class="deepLevel">
<div id="container">
<p class="important">You are currently viewing a snapshot of www.mozilla.org taken on April 21, 2008. Most of this content is
highly out of date (some pages haven't been updated since the project began in 1998) and exists for historical purposes only.  If
there are any pages on this archive site that you think should be added back to www.mozilla.org, please <a
href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Websites&component=www.mozilla.org">file a bug</a>.</p>
<p class="skipLink"><a href="#mainContent" accesskey="2">Skip to main content</a></p>
<div id="header">
<h1><a href="/" title="Return to home page" accesskey="1">Mozilla</a></h1>
<ul>
<li id="menu_aboutus"><a href="../../about/" title="Getting the most out of your online experience">About</a></li>
<li id="menu_developers"><a href="../../developer/" title="Using Mozilla's products for your own applications">Developers</a></li>
<li id="menu_store"><a href="http://store.mozilla.org/?r=mozorg1" title="Shop for Mozilla products on CD and other merchandise">Store</a></li>
<li id="menu_support"><a href="../../support/" title="Installation, trouble-shooting, and the knowledge base">Support</a></li>
<li id="menu_products"><a href="../../products/" title="All software Mozilla currently offers">Products</a></li>
</ul>
<form id="searchbox_002443141534113389537:ysdmevkkknw" action="http://www.google.com/cse" title="mozilla.org Search">
<div>
<label for="q" title="Search mozilla.org's sites">search mozilla:</label>
<input type="hidden" name="cx" value="002443141534113389537:ysdmevkkknw">
<input type="hidden" name="cof" value="FORID:0">
<input type="text" id="q" name="q" accesskey="s" size="30">
<input type="submit" id="submit" value="Go">
</div>
</form>
</div>
<hr class="hide">
<div id="mBody">
<div id="side">

<ul id="nav">
<li><a title="Roadmap" href="../../roadmap.html"><strong> Roadmap</strong></a></li>
<li><a title="Projects" href="../../projects/"><strong> Projects</strong></a></li>
<li><a title="For developers" href="../../developer/"><strong> Coding</strong></a>
<ul>
<li><a title="Module Owners" href="../../owners.html"> Module Owners</a></li>
<li><a title="Hacking" href="../../hacking/"> Hacking</a></li>
<li><a title="Get the Source" href="http://developer.mozilla.org/en/docs/Download_Mozilla_Source_Code"> Get the Source</a></li>
<li><a title="Building Mozilla" href="http://developer.mozilla.org/en/docs/Build_Documentation"> Build It</a></li>
</ul>
</li>
<li><a title="Testing" href="../../quality/"><strong> Testing</strong></a>
<ul>
<li><a title="Downloads of mozilla.org software releases" href="../../download.html"> Releases</a></li>
<li><a title="Latest mozilla builds for testers" href="../../developer/#builds"> Nightly Builds</a></li>
<li><a title="For testers to report bugs" href="https://bugzilla.mozilla.org/"> Report A Problem</a></li>
</ul>
</li>
<li><a title="Tools for mozilla developers" href="../../tools.html"><strong> Tools</strong></a>
<ul>
<li><a title="Bug tracking system for mozilla testers." href="https://bugzilla.mozilla.org/"> Bugzilla</a></li>
<li><a title="Latest status of mozilla builds" href="http://tinderbox.mozilla.org/showbuilds.cgi?tree=Firefox"> Tinderbox</a></li>
<li><a title="Latest checkins" href="http://bonsai.mozilla.org/cvsqueryform.cgi"> Bonsai</a></li>
<li><a title="Source cross reference" href="http://lxr.mozilla.org/seamonkey/"> LXR</a></li>
</ul>
</li>
<li><a title="Frequently Asked Questions." href="../../faq.html"><strong> FAQs</strong></a></li>
</ul>

</div>
<hr class="hide">
<div id="mainContent">





<ul class="snav">
 <li><a href="ref_part.htm">Previous</a>
 <li><a href="./">Contents</a>
 <li><a href="ix.htm">Index</a>
 <li><a href="function.htm">Next</a>
</ul>

<h1>Mozilla LDAP C SDK Programmer's Guide</h1>
<h2>Chapter 17 - Data Types and Structures</h2>

<p>This chapter describes the data structures and data types used by 
functions in the LDAP API. The chapter documents the following data 
structures and data types:</p>

<ul class="toc">
 <li><a href="#berval">berval</a>
 <li><a href="#BerElement">BerElement</a>
 <li><a href="#FriendlyMap">FriendlyMap</a>
 <li><a href="#LDAP">LDAP</a>
 <li><a href="#LDAP_CMP_CALLBACK">LDAP_CMP_CALLBACK</a>
 <li><a href="#LDAPControl">LDAPControl</a>
 <li><a href="#LDAP_DNSFN_GETHOSTBYADDR">LDAP_DNSFN_GETHOSTBYADDR</a>
 <li><a href="#LDAP_DNSFN_GETHOSTBYNAME">LDAP_DNSFN_GETHOSTBYNAME</a>
 <li><a href="#ldap_dns_fns">ldap_dns_fns</a>
 <li><a href="#ldap_extra_thread_fns">ldap_extra_thread_fns</a>
 <li><a href="#LDAPFiltDesc">LDAPFiltDesc</a>
 <li><a href="#LDAPFiltInfo">LDAPFiltInfo</a>
 <li><a href="#LDAPHostEnt">LDAPHostEnt</a>
 <li><a href="#LDAP_IOF_CLOSE_CALLBACK">LDAP_IOF_CLOSE_CALLBACK</a>
 <li><a href="#LDAP_IOF_CONNECT_CALLBACK">LDAP_IOF_CONNECT_CALLBACK</a>
 <li><a href="#LDAP_IOF_IOCTL_CALLBACK">LDAP_IOF_IOCTL_CALLBACK</a>
 <li><a href="#LDAP_IOF_READ_CALLBACK">LDAP_IOF_READ_CALLBACK</a>
 <li><a href="#LDAP_IOF_SELECT_CALLBACK">LDAP_IOF_SELECT_CALLBACK</a>
 <li><a href="#LDAP_IOF_SOCKET_CALLBACK">LDAP_IOF_SOCKET_CALLBACK</a>
 <li><a href="#LDAP_IOF_SSL_ENABLE_CALLBACK">LDAP_IOF_SSL_ENABLE_CALLBACK</a>
 <li><a href="#LDAP_IOF_WRITE_CALLBACK">LDAP_IOF_WRITE_CALLBACK</a>
 <li><a href="#ldap_io_fns">ldap_io_fns</a>
 <li><a href="#LDAPMemCache">LDAPMemCache</a>
 <li><a href="#LDAPMessage">LDAPMessage</a>
 <li><a href="#LDAPMod">LDAPMod</a>
 <li><a href="#LDAP_REBINDPROC_CALLBACK">LDAP_REBINDPROC_CALLBACK</a>
 <li><a href="#LDAPsortkey">LDAPsortkey</a>
 <li><a href="#LDAP_TF_GET_ERRNO_CALLBACK">LDAP_TF_GET_ERRNO_CALLBACK</a>
 <li><a href="#LDAP_TF_SET_ERRNO_CALLBACK">LDAP_TF_SET_ERRNO_CALLBACK</a>
 <li><a href="#LDAP_TF_GET_LDERRNO_CALLBACK">LDAP_TF_GET_LDERRNO_CALLBACK</a>
 <li><a href="#LDAP_TF_SET_LDERRNO_CALLBACK">LDAP_TF_SET_LDERRNO_CALLBACK</a>
 <li><a href="#LDAP_TF_MUTEX_ALLOC_CALLBACK">LDAP_TF_MUTEX_ALLOC_CALLBACK</a>
 <li><a href="#LDAP_TF_MUTEX_FREE_CALLBACK">LDAP_TF_MUTEX_FREE_CALLBACK</a>
 <li><a href="#LDAP_TF_MUTEX_LOCK_CALLBACK">LDAP_TF_MUTEX_LOCK_CALLBACK</a>
 <li><a href="#LDAP_TF_MUTEX_TRYLOCK_CALLBACK">LDAP_TF_MUTEX_TRYLOCK_CALLBACK</a>
 <li><a href="#LDAP_TF_MUTEX_UNLOCK_CALLBACK">LDAP_TF_MUTEX_UNLOCK_CALLBACK</a>
 <li><a href="#LDAP_TF_SEMA_ALLOC_CALLBACK">LDAP_TF_SEMA_ALLOC_CALLBACK</a>
 <li><a href="#LDAP_TF_SEMA_FREE_CALLBACK">LDAP_TF_SEMA_FREE_CALLBACK</a>
 <li><a href="#LDAP_TF_SEMA_POST_CALLBACK">LDAP_TF_SEMA_POST_CALLBACK</a>
 <li><a href="#LDAP_TF_SEMA_WAIT_CALLBACK">LDAP_TF_SEMA_WAIT_CALLBACK</a>
 <li><a href="#LDAP_TF_THREADID_CALLBACK">LDAP_TF_THREADID_CALLBACK</a>
 <li><a href="#ldap_thread_fns">ldap_thread_fns</a>
 <li><a href="#LDAPURLDesc">LDAPURLDesc</a>
 <li><a href="#LDAP_VALCMP_CALLBACK">LDAP_VALCMP_CALLBACK</a>
 <li><a href="#LDAPVersion">LDAPVersion</a>
 <li><a href="#LDAPVirtualList">LDAPVirtualList</a>
</ul>

<h3 id="berval">berval</h3>
<p>berval represents binary data that is encoded using simplified Basic 
 Encoding Rules (BER). The data and size of the data are included in a 
 berval structure.</p>

<p>berval is defined as follows:</p>

<pre>struct berval {
  unsigned long bv_len;
  char *bv_val;
};</pre>

<p>The fields in this structure are described below:</p>
<dl>
 <dt><code>bv_len</code>
 <dd>The length of the data.
 <dt><code>bv_val</code>
 <dd>The binary data.
</dl>
<p>Use a berval structure when working with attributes that contain 
 binary data (such as a JPEG or audio file).</p>

<h3 id="BerElement">BerElement</h3>
<p>BerElement represents data encoded using the Basic Encoding Rules 
 (BER). BerElement is not completely exposed in 
 <code class="filename">ldap.h</code> because the fields within the 
 structure are not intended to be accessible to clients.</p>
 
<p>Calling the <a href="function.htm#first-attribute">ldap_first_attribute()</a> 
 function allocates a BerElement structure in memory. You use this 
 structure to keep track of the current attribute. When you are done 
 reading attributes in an entry, you need to free the  BerElement 
 structure from memory by calling the 
 <a href="function.htm#ldap-ber-free">ldap_ber_free()</a> function.</p>

<h3 id="FriendlyMap">FriendlyMap</h3>
<p>FriendlyMap represents the mapping between a list of "unfriendly 
 names" and "friendly names". For example, you can represent the list 
 of two-letter state codes (cryptic, "unfriendly names") and 
 corresponding state names (easy to understand, "friendly names") in a 
 FriendlyMap structure.</p>
 
<p>FriendlyMap is not completely defined in ldap.h because the fields 
 within the structure are not intended to be accessible to clients.</p>
 
<p>Calling the <a href="function.htm#friendly-name">ldap_friendly_name()</a> 
 routine allocates a FriendlyMap structure and reads a list of 
 "unfriendly names" and "friendly names" from a file.</p>

<h3 id="LDAP">LDAP</h3>
<p>LDAP is a type of structure representing the connection with the 
 LDAP server. LDAP is not completely defined in 
 <code class="filename">ldap.h</code> because the fields within the 
 structure are not intended to be accessible to clients.</p>
<p>When you call functions that perform LDAP operations on an LDAP 
 server (for example, when you call 
 <a href="function.htm#search-ext">ldap_search_ext()</a> to search the 
 directory or <a href="function.htm#modify-ext">ldap_modify_ext()</a> to 
 update an entry in the directory), you need to pass a pointer to an 
 LDAP structure as a parameter to the function.</p>
 
<p>To create, manipulate, and free an LDAP structure, call the 
 following functions:
<ul>
 <li>
  To create an LDAP structure, call the 
  <a href="function.htm#init">ldap_init()</a> or 
  <a href="function.htm#ssl-init">ldapssl_init()</a> function.
 <li>
  To view or modify the properties of the connection, call the
  <a href="function.htm#get-option">ldap_get_option()</a> and 
  <a href="function.htm#set-option">ldap_set_option()</a> functions.
 <li>
  To close the connection and free the LDAP structure, call the
  <a href="function.htm#unbind">ldap_unbind()</a> or 
  <a href="function.htm#unbind-s">ldap_unbind_s()</a> function.
</ul>

<h3 id="LDAP_CMP_CALLBACK">LDAP_CMP_CALLBACK</h3>
<p>LDAP_CMP_CALLBACK specifies the prototype for a callback function.
 If you define a function with this prototype and specify it when 
 calling the <a href="function.htm#sort-entries">ldap_sort_entries()</a> or
 <a href="function.htm#multisort-entries">ldap_multisort_entries()</a> function,
 your function will be called by your LDAP client. The client will call
 your function to sort a specified set of entries.</p>
 
<p>The prototype specified by this data type is:</p>

<pre class="code">typedef int (LDAP_C LDAP_CALLBACK
  LDAP_CMP_CALLBACK)(const char*, const char*);</pre>
  
<p>For information on the arguments, return values, and purpose of this 
 function, see <a href="function.htm#sort-entries">ldap_sort_entries()</a> and
 <a href="function.htm#multisort-entries">ldap_multisort_entries()</a>.</p>

<h3 id="LDAPControl">LDAPControl</h3>
<p>LDAPControl represents a client or server control associated with an 
 LDAP operation. Controls are part of the LDAPv3 protocol. You can use a 
 control to extend the functionality of an LDAP operation.</p>
<p>There are two basic types of controls described in the LDAPv3 protocol:
<ul>
 <li>
  Server controls are controls that are sent from the client to the 
  server along with an LDAP request. (In some cases, a server can 
  include a control in the response it sends back to the client.)
  <p></p>
  For example, you can include a server control in a search request to 
  specify that you want the server to sort the search results before 
  sending them back.
 <li>
  Client controls are controls that can extend the client but that are 
  never sent to the server. As a general example, you might be able to 
  pass a client control to an LDAP API function, which might parse the 
  control and use the data that you've specified in the control.
  <p></p>
  Note that the Mozilla LDAP C SDK does not currently support any 
  client controls.
</ul>

<p>LDAPControl is defined as follows:</p>

<pre class="code">typedef struct ldapcontrol {
  char *ldctl_oid;
  struct berval ldctl_value;
  char ldctl_iscritical;
} LDAPControl;</pre>

<p>The fields in this structure are described below:</p>

<dl>
 <dt><code>ldctl_oid</code>
 <dd>Object identifier (OID) of the control.
 <dt><code>ldctl_value</code>
 <dd>
  <a href="#berval">berval</a> structure containing data associated 
  with the control.
  <p></p>
  If you want to specify a zero-length value, set ldctl_value.bv_len to 
  0 and ldctl_value.bv_val to a zero-length string.
  <p></p>
  To indicate that no data is associated with the control, set 
  ldctl_value.bv_val to NULL.
 <dt><code>ldctl_iscritical</code>
 <dd>
  Specifies whether or not the control is critical to the operation. 
  This field can have one of the following values:
  <ul>
   <li>A non-zero value specifies that the control is critical to the operation.
   <li>0 specifies that the control is not critical to the operation.
  </ul>
</dl>

<p>For more information on LDAP controls, see 
<a href="controls.htm">Chapter 14 - Working with LDAP Controls</a>.</p>

<h3 id="LDAP_DNSFN_GETHOSTBYADDR">LDAP_DNSFN_GETHOSTBYADDR</h3>
<p>LDAP_DNSFN_GETHOSTBYADDR specifies the prototype for a callback 
 function. This callback function should be equivalent to the 
 gethostbyaddr_r() function that is available on some UNIX platforms.</p>
 
<p>If you define a function with this prototype and set it in the 
 <a href="#ldap_dns_fns">ldap_dns_fns</a> structure, your function will 
 be called by the LDAP C SDK on behalf of your LDAP client if it needs 
 to get the hostname of the LDAP server to which it is connected.</p>
 
<p>The prototype specified by this data type is:</p>

<pre class="code">typedef <a href="#LDAPHostEnt">LDAPHostEnt</a> * (LDAP_C LDAP_CALLBACK
LDAP_DNSFN_GETHOSTBYADDR)( const char *addr, int length, int type,
  LDAPHostEnt *result, char *buffer, int buflen, int *statusp,
  void *extradata );</pre>

<h3 id="LDAP_DNSFN_GETHOSTBYNAME">LDAP_DNSFN_GETHOSTBYNAME</h3>
<p>LDAP_DNSFN_GETHOSTBYNAME specifies the prototype for a callback function.
 This callback function should be equivalent to the gethostbyname_r() function that is available on some UNIX platforms.
<p>If you define a function with this prototype and set it in the <a href="#ldap_dns_fns">ldap_dns_fns</a>
 structure, your function will be called by the LDAP SDK on behalf of your LDAP client to get the host entry for the LDAP server when connecting to the server.
<p>The prototype specified by this data type is:
<pre>typedef <a href="#41186">LDAPHostEnt</a> * (LDAP_C LDAP_CALLBACK
LDAP_DNSFN_GETHOSTBYADDR)( const char *addr, int length, int type,
  LDAPHostEnt *result, char *buffer, int buflen, int *statusp,
  void *extradata );</pre>

<h3 id="ldap_dns_fns">ldap_dns_fns</h3>
<p>ldap_dns_fns contains a set of pointers to DNS functions (equivalents to
 the gethostbyname_r() and gethostbyaddr_r() functions that are available on some UNIX platforms.)
<p>You can use this if you want the LDAP C SDK to call these functions when looking up the hostname
 or IP address for the LDAP server. For example, you could use this to call versions of the DNS
 functions that are safe for use in a multi-threaded application.
<p>After you set the fields in this structure, you can register the functions in this structure for
 use by the client by calling the <a href="function.htm#set-option">ldap_set_option()</a> function and
 set the LDAP_OPT_DNS_FN_PTRS option to this structure.
<p>ldap_dns_fns is defined as follows:
<pre class="code">struct ldap_dns_fns {
  void *lddnsfn_extradata;
  int lddnsfn_bufsize;
  <a href="#LDAP_DNSFN_GETHOSTBYNAME">LDAP_DNSFN_GETHOSTBYNAME</a> *lddnsfn_gethostbyname;
  <a href="#LDAP_DNSFN_GETHOSTBYADDR">LDAP_DNSFN_GETHOSTBYADDR</a> *lddnsfn_gethostbyaddr;
};</pre>
<p>The fields in this structure are described below:
<dl>
 <dt><code>lddnsfn_extradata</code>
 <dd>Value passed in the extradata argument of the <a href="#LDAP_DNSFN_GETHOSTBYADDR">LDAP_DNSFN_GETHOSTBYADDR</a>
  and <a href="#LDAP_DNSFN_GETHOSTBYADDR">LDAP_DNSFN_GETHOSTBYADDR</a> function calls.
 <dt><code>lddnsfn_bufsize</code>
 <dd>Specifies the size of the buffer that you want passed to your DNS callback function.
  Your LDAP client passes this value as the buflen argument of the
  <a href="#LDAP_DNSFN_GETHOSTBYADDR">LDAP_DNSFN_GETHOSTBYADDR</a> and
  <a href="#LDAP_DNSFN_GETHOSTBYADDR">LDAP_DNSFN_GETHOSTBYADDR</a> function calls.
 <dt><code>lddnsfn_gethostbyname</code>
 <dd>Function pointer for getting the host entry for the LDAP server. This function
  is called by the client when connecting to the server if the function pointer is
  not NULL. The function must have the prototype specified by
  <a href="#LDAP_DNSFN_GETHOSTBYNAME">LDAP_DNSFN_GETHOSTBYNAME</a>.
  If NULL, the standard built-in OS routine is used.
 <dt><code>lddnsfn_gethostbyaddr</code>
 <dd>
  <p>Function pointer for getting the host name of the LDAP server. This function
   is called by the client when needed if the function pointer is not NULL.
  <p>The function must have the prototype specified by
   <a href="#LDAP_DNSFN_GETHOSTBYADDR">LDAP_DNSFN_GETHOSTBYADDR</a>.
   If NULL, the standard built-in OS routine is used.
</dl>

<h3 id="ldap_extra_thread_fns">ldap_extra_thread_fns</h3>
<p>The ldap_extra_thread_fns structure contains a set of pointers to additional functions that you want to use when write a multithreaded client. Your client calls these functions when getting results from the <a href="#LDAP">LDAP</a> structure.
<p>Note that the LDAP C SDK ignores all the elements in this structure except for the ltf_threadid_fn function. Calling ltf_threadid_fn will, in some cases, enhance the performance of a multithreaded program.
<p>After you set the fields in this structure, you can register the functions in this structure for use by the client by calling the <a href="function.htm#set-option">ldap_set_option()</a> function and set the LDAP_OPT_EXTRA_THREAD_FN_PTRS option to this structure.
<p>The ldap_extra_thread_fns structure is defined as follows:
<pre class="code">struct ldap_extra_thread_fns {
  <a href="#LDAP_TF_MUTEX_TRYLOCK_CALLBACK">LDAP_TF_MUTEX_TRYLOCK_CALLBACK</a>  *ltf_mutex_trylock;
  <a href="#LDAP_TF_SEMA_ALLOC_CALLBACK">LDAP_TF_SEMA_ALLOC_CALLBACK</a>     *ltf_sema_alloc;
  <a href="#LDAP_TF_SEMA_FREE_CALLBACK">LDAP_TF_SEMA_FREE_CALLBACK</a>      *ltf_sema_free;
  <a href="#LDAP_TF_SEMA_WAIT_CALLBACK">LDAP_TF_SEMA_WAIT_CALLBACK</a>      *ltf_sema_wait;
  <a href="#LDAP_TF_SEMA_POST_CALLBACK">LDAP_TF_SEMA_POST_CALLBACK</a>      *ltf_sema_post;
  <a href="#LDAP_TF_THREADID_CALLBACK">LDAP_TF_THREADID_CALLBACK</a>       *ltf_threadid_fn;
};</pre>
<p>The fields in this structure are described below:
<dl>
 <dt><code>ltf_mutex_trylock</code>
 <dd>Function pointer for attempting to lock a mutex. This function is called by the client when needed if the function pointer is not NULL. The function must have the prototype specified by <a href="#LDAP_TF_MUTEX_TRYLOCK_CALLBACK">LDAP_TF_MUTEX_TRYLOCK_CALLBACK</a>.
 <dt><code>ltf_sema_alloc</code>
 <dd>Function pointer for allocating a semaphore. This function is called by the client when needed if the function pointer is not NULL. The function must have the prototype specified by <a href="#LDAP_TF_SEMA_ALLOC_CALLBACK">LDAP_TF_SEMA_ALLOC_CALLBACK</a>.
 <dt><code>ltf_sema_free</code>
 <dd>Function pointer for freeing a semaphore. This function is called by the client when needed if the function pointer is not NULL. The function must have the prototype specified by <a href="#LDAP_TF_SEMA_FREE_CALLBACK">LDAP_TF_SEMA_FREE_CALLBACK</a>.
 <dt><code>ltf_sema_wait</code>
 <dd>Function pointer for waiting for the value of a semaphore to be greater than 0. This function is called by the client when needed if the function pointer is not NULL. The function must have the prototype specified by <a href="#LDAP_TF_SEMA_WAIT_CALLBACK">LDAP_TF_SEMA_WAIT_CALLBACK</a>.
 <dt><code>ltf_sema_post</code>
 <dd>
  <p>Function pointer for incrementing the value of a semaphore. This function is called by the client when needed if the function pointer is not NULL.
  <p>The function must have the prototype specified by <a href="#41736">LDAP_TF_SEMA_POST_CALLBACK</a>.
 <dt><code>ltf_threadid_fn</code>
 <dd>
  <p>Function pointer that is called to retieve the unique identifier for the calling thread.
   If this is NULL, it is not used. An example of a similar function in the POSIX threads standard is pthread_self().
  <p>The function must have the prototype specified by LDAP_TF_THREADID_CALLBACK.
</dl>
<p>For an example of setting up the ldap_extra_thread_fns structure, see <a href="threaded.htm">Chapter 16 - Writing Multithreaded Clients</a>.

<h3 id="LDAPFiltDesc">LDAPFiltDesc</h3>
<p>LDAPFiltDesc is a type of structure that is returned when you call the <a href="function.htm#init-getfilter">ldap_init_getfilter()</a> routine to load a filter configuration file. LDAPFiltDesc is not completely defined in ldap.h because the fields within the structure are not intended to be accessible to clients.
<p>After calling the <a href="function.htm#init-getfilter">ldap_init_getfilter()</a> routine, use the pointer to the returned LDAPFiltDesc structure in subsequent calls to get information about filters in the filter configuration file.

<h3 id="LDAPFiltInfo">LDAPFiltInfo</h3>
<p>LDAPFiltInfo represents information about a filter in the filter configuration file. When you call the <a href="function.htm#getfirstfilter">ldap_getfirstfilter()</a> or <a href="function.htm#getnextfilter">ldap_getnextfilter()</a> routines to get a filter from the filter configuration file, the routines return a pointer to an LDAPFiltInfo structure containing the information about the filter.
<p>LDAPFiltInfo is defined as follows:
<pre class="code">typedef struct ldap_filt_info {
  char *lfi_filter;
  char *lfi_desc;
  int lfi_scope;
  int lfi_isexact;
  struct ldap_filt_info *lfi_next;
} LDAPFiltInfo;</pre>
<p>The fields in this structure are described below:
<dl>
 <dt><code>lfi_filter</code>
 <dd>The filter (for example, (cn=d*)).
 <dt><code>lfi_desc</code>
 <dd>Description of the filter (the fifth field in the filter configuration file).
 <dt><code>lfi_scope</code>
 <dd>
  <p>The scope of the filter (the sixth field in the filter configuration file), which can be one of the following values:
  <ul>
   <li>LDAP_SCOPE_BASE specifies that the search will be restricted to the current distinguished name.
   <li>LDAP_SCOPE_ONELEVEL specifies that the search will be restricted to the entries at the level beneath the current distinguished name.
   <li>LDAP_SCOPE_SUBTREE specifies that the search will encompass entries at all levels beneath the current distinguished name.
  </ul>
  <p>If the scope of the filter is not specified in the filter configuration file, the scope is LDAP_SCOPE_SUBTREE by default.
 <dt><code>lfi_isexact</code>
 <dd>
  <p>Specifies whether or not the filter is an exact filter (an exact filter contains no wildcards and does not match words that sound alike):
  <ul>
   <li>0 specifies that the filter is not an exact filter.
   <li>1 specifies that the filter is an exact filter.
  </ul>
 <dt><code>lfi_next</code>
 <dd>Pointer to the LDAPFiltInfo structure representing the next filter in the filter list.
</dl>
<p>The following section of code prints out information about a filter:
<pre class="code">LDAPFiltInfo *lfip;
/* Print out the filter */
printf( "Filter:\t%s\n", lfdp-&gt;lfd_filter );
printf( "Description:\t%s\n", lfdp-&gt;lfd_desc );</pre>
<p>For example, in the filter configuration file, if the first filter that applies to the value "@" is:
<p>"@" " " "(mail=%v)" "email address is" "onelevel"
<p>The code prints out:
<pre class="screen">Filter: (mail=@)
 Description: email address is</pre>

<h3 id="LDAPHostEnt">LDAPHostEnt</h3>
<p>LDAPHostEnt represents an entry for a host found by a domain name server. This type is similar to the hostent structure returned by functions such as gethostbyname_r() on UNIX.
<p>If you are writing your own DNS functions for use by the client, your functions should return the host entry in this type of structure. See the documentation on <a href="#LDAP_DNSFN_GETHOSTBYADDR">LDAP_DNSFN_GETHOSTBYADDR</a> and <a href="#LDAP_DNSFN_GETHOSTBYNAME">LDAP_DNSFN_GETHOSTBYNAME</a> for details.
<p>The fields in this structure should point to addresses within the buffer that is passed to the DNS callback (referenced in the LDAP callback function). This buffer contains the host data. The pointers in the hostent structure returned by the function point to the data in this buffer.
<p>LDAPHostEnt is defined as follows:
<pre class="code">typedef struct LDAPHostEnt {
  char *ldaphe_name;
  char **ldaphe_aliases;
  int ldaphe_addrtype;
  int ldaphe_length;
  char **ldaphe_addr_list;
} LDAPHostEnt;</pre>
<p>The fields in this structure are described below:
<dl>
 <dt><code>ldaphe_name</code>
 <dd>Canonical name of the host.
 <dt><code>ldaphe_aliases</code>
 <dd>List of aliases for this host.
 <dt><code>ldaphe_addrtype</code>
 <dd>Address type of the host.
 <dt><code>ldaphe_length</code>
 <dd>Length of the address.
 <dt><code>ldaphe_addr_list</code>
 <dd>List of addresses for this host (as returned by the name server).
</dl>

<h3 id="LDAP_IOF_CLOSE_CALLBACK">LDAP_IOF_CLOSE_CALLBACK</h3>
<p>LDAP_IOF_CLOSE_CONNECT_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and set it in the <a href="#ldap_io_fns">ldap_io_fns</a> structure, your function will be called by your LDAP client.
<p>This callback function is equivalent to the standard close() system call.
<p>The prototype specified by this data type is:
<pre class="code">typedef int (LDAP_C LDAP_CALLBACK
  LDAP_IOF_CLOSE_CALLBACK )( LBER_SOCKET );</pre>

<h3 id="LDAP_IOF_CONNECT_CALLBACK">LDAP_IOF_CONNECT_CALLBACK</h3>
<p>LDAP_IOF_CONNECT_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and set it in the <a href="#ldap_io_fns">ldap_io_fns</a> structure, your function will be called by your LDAP client.
<p>This callback function is equivalent to the standard connect() network I/O function.
<p>The prototype specified by this data type is:
<pre class="code">typedef int (LDAP_C LDAP_CALLBACK
  LDAP_IOF_CONNECT_CALLBACK )( LBER_SOCKET,
  struct sockaddr *, int );</pre>

<h3 id="LDAP_IOF_IOCTL_CALLBACK">LDAP_IOF_IOCTL_CALLBACK</h3>
<p>LDAP_IOF_IOCTL_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and set it in the <a href="#ldap_io_fns">ldap_io_fns</a> structure, your function will be called by your LDAP client.
<p>This callback function is equivalent to the standard ioctl() system call.
<p>The prototype specified by this data type is:
<pre class="code">typedef int (LDAP_C LDAP_CALLBACK
  LDAP_IOF_IOCTL_CALLBACK)( LBER_SOCKET, int, ... );</pre>

<h3 id="LDAP_IOF_READ_CALLBACK">LDAP_IOF_READ_CALLBACK</h3>
<p>LDAP_IOF_READ_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and set it in the <a href="#ldap_io_fns">ldap_io_fns</a> structure, your function will be called by your LDAP client.
<p>This callback function is equivalent to the standard read() I/O function.
<p>The prototype specified by this data type is:
<pre class="code">typedef int (LDAP_C LDAP_CALLBACK
  LDAP_IOF_READ_CALLBACK)( LBER_SOCKET, void *, int );</pre>

<h3 id="LDAP_IOF_SELECT_CALLBACK">LDAP_IOF_SELECT_CALLBACK</h3>
<p>LDAP_IOF_SELECT_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and set it in the <a href="#ldap_io_fns">ldap_io_fns</a> structure, your function will be called by your LDAP client.
<p>This callback function is equivalent to the standard select() I/O function.
<p>The prototype specified by this data type is:
<pre class="code">typedef int (LDAP_C LDAP_CALLBACK
LDAP_IOF_SELECT_CALLBACK)( int, fd_set *, fd_set *,
  fd_set *, struct timeval * );</pre>

<h3 id="LDAP_IOF_SOCKET_CALLBACK">LDAP_IOF_SOCKET_CALLBACK</h3>
<p>LDAP_IOF_SOCKET_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and set it in the <a href="#ldap_io_fns">ldap_io_fns</a> structure, your function will be called by your LDAP client.
<p>This callback function is equivalent to the standard socket() network I/O function.
<p>The prototype specified by this data type is:
<pre class="code">typedef LBER_SOCKET (LDAP_C LDAP_CALLBACK
  LDAP_IOF_SOCKET_CALLBACK)( int, int, int );</pre>

<h3 id="LDAP_IOF_SSL_ENABLE_CALLBACK">LDAP_IOF_SSL_ENABLE_CALLBACK</h3>
<p>LDAP_IOF_SSL_ENABLE_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and set it in the <a href="#ldap_io_fns">ldap_io_fns</a> structure, your function will be called by your LDAP client.
<p>This callback function is equivalent to the ssl_enable() function.
<p>The prototype specified by this data type is:
<pre class="code">typedef int (LDAP_C LDAP_CALLBACK
  LDAP_IOF_SSL_ENABLE_CALLBACK )( LBER_SOCKET );</pre>

<h3 id="LDAP_IOF_WRITE_CALLBACK">LDAP_IOF_WRITE_CALLBACK</h3>
<p>LDAP_IOF_WRITE_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and set it in the <a href="#ldap_io_fns">ldap_io_fns</a> structure, your function will be called by your LDAP client.
<p>This callback function is equivalent to the standard write() I/O function.
<p>The prototype specified by this data type is:
<pre class="code">typedef int (LDAP_C LDAP_CALLBACK LDAP_IOF_WRITE_CALLBACK)
  ( LBER_SOCKET, const void *, int );</pre>

<h3 id="ldap_io_fns">ldap_io_fns</h3>
<p>The ldap_io_fns structure contains a set of pointers to input/output functions that you want used with the Directory Server API. You need to set up this structure if you want to connect to the LDAP server using a secure sockets layer (SSL).
<p>The ldap_io_fns structure is defined as follows:
<pre class="code">struct ldap_io_fns {
  LDAP_IOF_READ_CALLBACK *liof_read;
  LDAP_IOF_WRITE_CALLBACK *liof_write;
  LDAP_IOF_SELECT_CALLBACK *liof_select;
  LDAP_IOF_SOCKET_CALLBACK *liof_socket;
  LDAP_IOF_IOCTL_CALLBACK *liof_ioctl;
  LDAP_IOF_CONNECT_CALLBACK *liof_connect;
  LDAP_IOF_CLOSE_CALLBACK *liof_close;
  LDAP_IOF_SSL_ENABLE_CALLBACK *liof_ssl_enable;
};</pre>
<p>The fields in this structure are described below:
<dl>
 <dt><code>liof_read</code>
 <dd>Function pointer to the equivalent of the standard read() I/O function. The function must have the prototype specified by <a href="#LDAP_IOF_READ_CALLBACK">LDAP_IOF_READ_CALLBACK</a>.
 <dt><code>liof_write</code>
 <dd>Function pointer to the equivalent of the standard write() I/O function. The function must have the prototype specified by <a href="#LDAP_IOF_WRITE_CALLBACK">LDAP_IOF_WRITE_CALLBACK</a>.
 <dt><code>liof_select</code>
 <dd>Function pointer to the equivalent of the standard select() I/O function. The function must have the prototype specified by <a href="#LDAP_IOF_SELECT_CALLBACK">LDAP_IOF_SELECT_CALLBACK</a>.
 <dt><code>liof_socket</code>
 <dd>Function pointer to the equivalent of the standard socket() network I/O function. The function must have the prototype specified by <a href="#LDAP_IOF_SOCKET_CALLBACK">LDAP_IOF_SOCKET_CALLBACK</a>.
 <dt><code>liof_ioctl</code>
 <dd>Function pointer to the equivalent of the standard ioctl() system call. The function must have the prototype specified by <a href="#LDAP_IOF_IOCTL_CALLBACK">LDAP_IOF_IOCTL_CALLBACK</a>.
 <dt><code>liof_connect</code>
 <dd>Function pointer to the equivalent of the standard connect() network I/O function. The function must have the prototype specified by <a href="#LDAP_IOF_CONNECT_CALLBACK">LDAP_IOF_CONNECT_CALLBACK</a>.
 <dt><code>liof_close</code>
 <dd>Function pointer to the equivalent of the standard close() system call. The function must have the prototype specified by <a href="#LDAP_IOF_CLOSE_CALLBACK">LDAP_IOF_CLOSE_CALLBACK</a>.
 <dt><code>liof_ssl_enable</code>
 <dd>Function pointer to the equivalent of the ssl_enable() function. The function must have the prototype specified by <a href="#LDAP_IOF_SSL_ENABLE_CALLBACK">LDAP_IOF_SSL_ENABLE_CALLBACK</a>.
</dl>

<h3 id="LDAPMemCache">LDAPMemCache</h3>
<p>LDAPMemCache is a type of structure representing an in-memory, client-side cache.
<p>You can create a cache and specify the following information:
<ul>
 <li>The maximum size of the cache.
 <li>The maximum amount of time to keep an item in the cache.
 <li>A set of base DNs for the search requests that you want to cache (optional).
 <li>A set of functions that you want used to ensure the thread-safety of the cache.
</ul>
<p>To use a cache, you need to associate it with a connection handle (and <a href="#LDAP">LDAP</a> structure). Before a search request is sent to the server, the cache is checked to determine if the same request was made before. If an earlier request was cached, the search results are retrieved from the cache.
<p>Note that the cache uses the search criteria as the key to cached items. Search requests with different criteria are cached as separate items.
<p>For example, suppose you send a search request specifying that you just want to retrieve the uid attribute. Your client caches the results of that search. If you send a similar search request specifying that you want to retrieve all attributes instead of just the uid, the results cached from the previous search are not used.
<p>The cache uses a combination of the following information as the key to a cached item:
<ul>
 <li>The hostname and port number of the LDAP server that you are searching.
 <li>The DN to which you are currently authenticated.
 <li>From the search criteria, the base DN, scope, filter, attributes to be returned, and an indication of whether to return attribute types only or attribute types and values.
</ul>
<p>Use the following functions to work with the cache:
<ul>
 <li>To create an LDAPMemCache structure, call the <a href="function.htm#memcache-init">ldap_memcache_init()</a> function.
 <li>To associate an LDAPMemCache structure with a connection handle (an <a href="#LDAP">LDAP</a> structure), call the <a href="function.htm#memcache-set">ldap_memcache_set()</a> function.
 <li>To get the LDAPMemCache structure that is associated with a connection handle (an <a href="#LDAP">LDAP</a> structure), call the <a href="function.htm#memcache-get">ldap_memcache_get()</a> function.
 <li>To get the cache to proactively remove expired items, call the <a href="function.htm#memcache-update">ldap_memcache_update()</a> function.
 <li>To remove entries from the cache, call the <a href="function.htm#memcache-flush">ldap_memcache_flush()</a> function.
 <li>To free the LDAPMemCache structure, call <a href="function.htm#memcache-destroy">ldap_memcache_destroy()</a>.
</ul>

<h3 id="LDAPMessage">LDAPMessage</h3>
<p>LDAPMessage is a type of structure representing the results of an LDAP operation, a chain of search results, an entry in the search results, or a search reference in the search results. LDAPMessage is not completely defined in ldap.h because the fields within the structure are not intended to be directly accessible to clients.
<p>Calling the <a href="function.htm#search-ext-s">ldap_search_ext_s()</a> or <a href="function.htm#search-ext">ldap_search_ext()</a> followed by <a href="function.htm#result">ldap_result()</a> function creates an LDAPMessage structure to represent the chain of results of a search. Calling the <a href="function.htm#first-entry">ldap_first_entry()</a> or <a href="function.htm#next-entry">ldap_next_entry()</a> function creates an LDAPMessage structure to represent an entry in the search results. Calling <a href="function.htm#first-reference">ldap_first_reference()</a> or <a href="function.htm#next-reference">ldap_next_reference()</a> creates an LDAPMessage structure to represent a search reference in the search results.
<p>To free the LDAPMessage structure, call the <a href="function.htm#msgfree">ldap_msgfree()</a> routine.

<h3 id="LDAPMod">LDAPMod</h3>
<p>LDAPMod is a type of structure that you use to specify changes to an attribute in an directory entry. Before you call the <a href="function.htm#add-ext">ldap_add_ext()</a>, <a href="function.htm#add-ext-s">ldap_add_ext_s()</a>, <a href="function.htm#modify-ext">ldap_modify_ext()</a>, or <a href="function.htm#modify-ext-s">ldap_modify_ext_s()</a> routines to add or modify an entry in the directory, you need to fill LDAPMod structures with the attribute values that you intend to add or change.
<p>LDAPMod is defined as follows:
<pre class="code">typedef struct ldapmod {
  int mod_op;
  char *mod_type;
  union {
    char **modv_strvals;
    struct berval **modv_bvals;
  } mod_vals;
#define mod_values mod_vals.modv_strvals
#define mod_bvalues mod_vals.modv_bvals
} LDAPMod;</pre>
<p>The fields in this structure are described below:
<dl>
 <dt><code>mod_op</code>
 <dd>
  <p>The operation to be performed on the attribute and the type of data specified as the attribute values. This field can have one of the following values:
  <ul>
   <li>LDAP_MOD_ADD adds a value to the attribute.
   <li>LDAP_MOD_DELETE removes the value from the attribute.
   <li>LDAP_MOD_REPLACE replaces all existing values of the attribute.
  </ul>
  <p>In addition, if you are specifying binary values in the mod_bvalues field, you should use the bitwise OR operator ( | ) to combine LDAP_MOD_BVALUES with the operation type. For example:
  <pre>mod-&gt;mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES</pre>
  <p class="note">If you are using the structure to add a new entry, you can specify 0 for the mod_op field (unless you are adding binary values and need to specify LDAP_MOD_BVALUES). See <a href="addmod.htm#add-new-entry">"Adding a New Entry"</a> for details.
 <dt><code>mod_type</code>
 <dd>The attribute type that you want to add, delete, or replace the values of (for example, "sn" or "telephoneNumber").
 <dt><code>mod_values</code>
 <dd>A pointer to a NULL-terminated array of string values for the attribute.
 <dt><code>mod_bvalues</code>
 <dd>A pointer to a NULL-terminated array of <a href="#berval">berval</a> structures for the attribute.
</dl>
<p>Note the following:
<ul>
 <li>If you specify LDAP_MOD_DELETE in the mod_op field and you remove all values in an attribute, the attribute is removed from the entry.
 <li>If you specify LDAP_MOD_DELETE in the mod_op field and NULL in the mod_values field, the attribute is removed from the entry.
 <li>If you specify LDAP_MOD_REPLACE in the mod_op field and NULL in the mod_values field, the attribute is removed from the entry.
 <li>If you specify LDAP_MOD_REPLACE in the mod_op field and the attribute does not exist in the entry, the attribute is added to the entry.
 <li>If you specify LDAP_MOD_ADD in the mod_op field and the attribute does not exist in the entry, the attribute is added to the entry.
</ul>
<p>If you've allocated memory for the structures yourself, you should free the structures when you're finished by calling the <a href="function.htm#mods-free">ldap_mods_free()</a> function.
<p>The following section of code sets up an LDAPMod structure to change the email address of a user's entry to "bjensen@example.com":

<h4>Code Example  17-1 - Setting up an LDAPMod structure</h4>
<pre class="example code">LDAPMod attribute1;
LDAPMod *list_of_attrs[2];
char *mail_values[] = { "bjensen@example.com", NULL };
char *dn;
...
/* Identify the entry that you want changed */
char *dn = "uid=bjensen, ou=People, dc=example,dc=com";

/* Specify that you want to replace the value of an attribute */
attribute1.mod_op = LDAP_MOD_REPLACE;

/* Specify that you want to change the value of the mail attribute */
attribute1.mod_type = "mail";

/* Specify the new value of the mail attribute */
attribute1.mod_values = mail_values;

/* Add the change to the list of attributes that you want changed */
list_of_attrs[0] = &amp;attribute_change;
list_of_attrs[1] = NULL;

/* Update the entry with the change */
if ( ldap_modify_s( ld, dn, list_of_attrs ) != LDAP_SUCCESS ) {
  ldap_perror( ld, "ldap_modify_s" );
  return( 1 );
}
...</pre>

<h3 id="LDAP_REBINDPROC_CALLBACK">LDAP_REBINDPROC_CALLBACK</h3>
<p>LDAP_REBINDPROC_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and specify it when calling the <a href="function.htm#set-rebind-proc">ldap_set_rebind_proc()</a> function, your function will be called by your LDAP client. The client will call your function to retrieve authentication information when automatically following referrals to other servers.
<p>The prototype specified by this data type is:
<pre class="code">typedef int (LDAP_CALL LDAP_CALLBACK
  LDAP_REBINDPROC_CALLBACK)( LDAP *ld, char **dnp, char **passwdp,
  int *authmethodp, int freeit, void *arg);</pre>
<p>For information on the arguments, return values, and purpose of this function, see <a href="function.htm#set-rebind-proc">ldap_set_rebind_proc()</a>.

<h3 id="LDAPsortkey">LDAPsortkey</h3>
<p>LDAPsortkey represents a server control used to specify that the server should sort the search results before sending them back to the client. Controls are part of the LDAPv3 protocol.
<p>For example, you can use LDAPsortkey to specify that you want the server to sort search results by the roomNumber attribute.
<p>LDAPsortkey is defined as follows:
<pre class="code">typedef struct LDAPsortkey {
  char *sk_attrtype;
  char *sk_matchruleoid;
  int sk_reverseorder;
} LDAPsortkey;</pre>
<p>The fields in this structure are described below:
<dl>
 <dt><code>sk_attrtype</code>
 <dd>Name of the attribute that you want to use for sorting.
 <dt><code>sk_matchruleoid</code>
 <dd>Object identifier (OID) of the matching rule that you want to use for sorting.
 <dt><code>sk_reverseorder</code>
 <dd>
  <p>Specifies whether or not the results are sorted in reverse order. This field can have one of the following values:
  <ul>
   <li>A non-zero value specifies that the results should be sorted in reverse order.
   <li>0 specifies that the results should be sorted in normal (forward) order.
  </ul>
</dl>
<p>To create an array of LDAPsortkey structures, you can call the <a href="function.htm#create-sort-keylist">ldap_create_sort_keylist()</a> function.
<p>To free an array of LDAPsortkey structures, you can call the <a href="function.htm#free-sort-keylist">ldap_free_sort_keylist()</a> function.

<h3 id="LDAP_TF_GET_ERRNO_CALLBACK">LDAP_TF_GET_ERRNO_CALLBACK</h3>
<p>LDAP_TF_GET_ERRNO_CALLBACK specifies the prototype for a callback function. This function is called by your LDAP client when it needs to get the value of the errno variable for a thread.
<p>The prototype specified by this data type is:
<pre class="code">typedef int (LDAP_C LDAP_CALLBACK
  LDAP_TF_GET_ERRNO_CALLBACK) ( void );</pre>
<p>For more details on the errno variable, see <a href="#ldap_thread_fns">ldap_thread_fns</a>.

<h3 id="LDAP_TF_SET_ERRNO_CALLBACK">LDAP_TF_SET_ERRNO_CALLBACK</h3>
<p>LDAP_TF_SET_ERRNO_CALLBACK specifies the prototype for a callback function. This function is called by your LDAP client when it needs to set the value of the errno variable for a thread.
<p>The prototype specified by this data type is:
<pre class="code">typedef void (LDAP_C LDAP_CALLBACK
  LDAP_TF_SET_ERRNO_CALLBACK)( int );</pre>
<p>For more details on the errno variable, see <a href="#ldap_thread_fns">ldap_thread_fns</a>.

<h3 id="LDAP_TF_GET_LDERRNO_CALLBACK">LDAP_TF_GET_LDERRNO_CALLBACK</h3>
<p>LDAP_TF_GET_LDERRNO_CALLBACK specifies the prototype for a callback function. This function is called by your LDAP client when it needs to retrieve the LDAP result code for an operation.
<p>The prototype specified by this data type is:
<pre class="code">typedef int (LDAP_C LDAP_CALLBACK
  LDAP_TF_GET_LDERRNO_CALLBACK)( char **, char **, void * );</pre>
<p>If you define a function with this prototype and set it in the <a href="#41754">ldap_thread_fns</a> structure, your callback function is called when the <a href="function.htm#get-lderrno">ldap_get_lderrno()</a> function is called. The arguments of <a href="function.htm#get-lderrno">ldap_get_lderrno()</a> are passed to your function, and the value returned by your function is returned by <a href="function.htm#get-lderrno">ldap_get_lderrno()</a>.
<p>For more details on the arguments and return values that your function must use, see <a href="function.htm#get-lderrno">ldap_get_lderrno()</a>.

<h3 id="LDAP_TF_SET_LDERRNO_CALLBACK">LDAP_TF_SET_LDERRNO_CALLBACK</h3>
<p>LDAP_TF_SET_LDERRNO_CALLBACK specifies the prototype for a callback function. This function is called by your LDAP client when it needs to set the LDAP result code for an operation.
<p>The prototype specified by this data type is:
<pre class="code">typedef void (LDAP_C LDAP_CALLBACK
  LDAP_TF_SET_LDERRNO_CALLBACK)( int, char *, char *, void * );</pre>
<p>If you define a function with this prototype and set it in the <a href="#41754">ldap_thread_fns</a> structure, your callback function is called when the <a href="function.htm#set-lderrno">ldap_set_lderrno()</a> function is called. The arguments of <a href="function.htm#set-lderrno">ldap_set_lderrno()</a> are passed to your function.
<p>For more details on the arguments that your function must use, see <a href="function.htm#set-lderrno">ldap_set_lderrno()</a>.

<h3 id="LDAP_TF_MUTEX_ALLOC_CALLBACK">LDAP_TF_MUTEX_ALLOC_CALLBACK</h3>
<p>LDAP_TF_MUTEX_ALLOC_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and set it in the <a href="#41754">ldap_thread_fns</a> structure, your function will be called by your LDAP client when it needs to allocate a mutex.
<p>The prototype specified by this data type is:
<pre class="code">typedef void *(LDAP_C LDAP_CALLBACK
  LDAP_TF_MUTEX_ALLOC_CALLBACK)( void );</pre>

<h3 id="LDAP_TF_MUTEX_FREE_CALLBACK">LDAP_TF_MUTEX_FREE_CALLBACK</h3>
<p>LDAP_TF_MUTEX_FREE_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and set it in the <a href="#ldap_thread_fns">ldap_thread_fns</a> structure, your function will be called by your LDAP client when it needs to free a mutex.
<p>The prototype specified by this data type is:
<pre class="screen">typedef void (LDAP_C LDAP_CALLBACK
  LDAP_TF_MUTEX_FREE_CALLBACK)( void * );</pre>

<h3 id="LDAP_TF_MUTEX_LOCK_CALLBACK">LDAP_TF_MUTEX_LOCK_CALLBACK</h3>
<p>LDAP_TF_MUTEX_LOCK_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and set it in the <a href="#ldap_thread_fns">ldap_thread_fns</a> structure, your function will be called by your LDAP client when it needs to lock a mutex.
<p>The prototype specified by this data type is:
<pre class="screen">typedef int (LDAP_C LDAP_CALLBACK
  LDAP_TF_MUTEX_LOCK_CALLBACK)( void * );</pre>

<h3 id="LDAP_TF_MUTEX_TRYLOCK_CALLBACK">LDAP_TF_MUTEX_TRYLOCK_CALLBACK</h3>
<p>This function prototype is not supported in this release of the LDAP C SDK.

<h3 id="LDAP_TF_MUTEX_UNLOCK_CALLBACK">LDAP_TF_MUTEX_UNLOCK_CALLBACK</h3>
<p>LDAP_TF_MUTEX_UNLOCK_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and set it in the <a href="#ldap_thread_fns">ldap_thread_fns</a> structure, your function will be called by your LDAP client when it needs to unlock a mutex.
<p>The prototype specified by this data type is:
<pre class="code">typedef int (LDAP_C LDAP_CALLBACK
  LDAP_TF_MUTEX_UNLOCK_CALLBACK)( void * );</pre>

<h3 id="LDAP_TF_SEMA_ALLOC_CALLBACK">LDAP_TF_SEMA_ALLOC_CALLBACK</h3>
<p>This function prototype is not supported in this release of the LDAP C SDK.

<h3 id="LDAP_TF_SEMA_FREE_CALLBACK">LDAP_TF_SEMA_FREE_CALLBACK</h3>
<p>This function prototype is not supported in this release of the LDAP C SDK.

<h3 id="LDAP_TF_SEMA_POST_CALLBACK">LDAP_TF_SEMA_POST_CALLBACK</h3>
<p>This function prototype is not supported in this release of the LDAP C SDK.

<h3 id="LDAP_TF_SEMA_WAIT_CALLBACK">LDAP_TF_SEMA_WAIT_CALLBACK</h3>
<p>This function prototype is not supported in this release of the LDAP C SDK.

<h3 id="LDAP_TF_THREADID_CALLBACK">LDAP_TF_THREADID_CALLBACK</h3>
<p>LDAP_TF_THREADID_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and set it in the <a href="#41754">ldap_thread_fns</a> structure, your function will be called when the LDAP C SDK needs to identify a thread. This callback function should return an identifier that is unique to the calling thread, much like the POSIX pthread_self() function does.
<p>The prototype specified by this data type is:
<pre class="code">typedef void *(LDAP_C LDAP_CALLBACK
  LDAP_TF_THREADID_CALLBACK)( void );</pre>

<h3 id="ldap_thread_fns">ldap_thread_fns</h3>
<p>The ldap_thread_fns structure contains a set of pointers to functions that you want to use when write a multithreaded client.
<p>The ldap_thread_fns structure is defined as follows:
<pre class="code">struct ldap_thread_fns {
  LDAP_TF_MUTEX_ALLOC_CALLBACK *ltf_mutex_alloc;
  LDAP_TF_MUTEX_FREE_CALLBACK *ltf_mutex_free;
  LDAP_TF_MUTEX_LOCK_CALLBACK *ltf_mutex_lock;
  LDAP_TF_MUTEX_UNLOCK_CALLBACK *ltf_mutex_unlock;
  LDAP_TF_GET_ERRNO_CALLBACK *ltf_get_errno;
  LDAP_TF_SET_ERRNO_CALLBACK *ltf_set_errno;
  LDAP_TF_GET_LDERRNO_CALLBACK *ltf_get_lderrno;
  LDAP_TF_SET_LDERRNO_CALLBACK *ltf_set_lderrno;
  void *ltf_lderrno_arg;
};</pre>
<p>The fields in this structure are described below:
<dl>
 <dt><code>ltf_mutex_alloc</code>
 <dd>Function pointer for allocating a mutex. This function is called by the client when needed if the function pointer is not NULL. The function must have the prototype specified by <a href="#41673">LDAP_TF_MUTEX_ALLOC_CALLBACK</a>.
 <dt><code>ltf_mutex_free</code>
 <dd>Function pointer for freeing a mutex. This function is called by the client when needed if the function pointer is not NULL. The function must have the prototype specified by <a href="#41682">LDAP_TF_MUTEX_FREE_CALLBACK</a>.
 <dt><code>ltf_mutex_lock</code>
 <dd>Function pointer for locking critical sections of code. This function is called by the client when needed if the function pointer is not NULL. The function must have the prototype specified by <a href="#41691">LDAP_TF_MUTEX_LOCK_CALLBACK</a>.
 <dt><code>ltf_mutex_unlock</code>
 <dd>Function pointer for unlocking critical sections of code. This function is called by the client when needed if the function pointer is not NULL. The function must have the prototype specified by <a href="#41709">LDAP_TF_MUTEX_UNLOCK_CALLBACK</a>.
 <dt><code>ltf_get_errno</code>
 <dd>
  <p>Function pointer for getting the value of the errno variable. This function is called by the client when needed if the function pointer is not NULL.
  <p>In a threaded environment, errno is typically redefined so that it has a value for each thread, rather than a global value for the entire process. This redefinition is done at compile time. Because the libldap library does not know what method your code and threading environment will use to get the value of errno for each thread, it calls this function to obtain the value of errno.
  <p>The function must have the prototype specified by <a href="#41610">LDAP_TF_GET_ERRNO_CALLBACK</a>.
 <dt><code>ltf_set_errno</code>
 <dd>
  <p>Function pointer for setting the value of the errno variable. This function is called by the client when needed if the function pointer is not NULL.
  <p>In a threaded environment, errno is typically redefined so that it has a value for each thread, rather than a global value for the entire process. This redefinition is done at compile time. Because the libldap library does not know what method your code and threading environment will use to get the value of errno for each thread, it calls this function to set the value of errno.
  <p>The function must have the prototype specified by <a href="#41620">LDAP_TF_SET_ERRNO_CALLBACK</a>.
 <dt><code>ltf_get_lderrno</code>
 <dd>
  <p>Function pointer for getting error values from calls to functions in the libldap library. This function is called by the client as needed if the function pointer isn't NULL.
  <p>If this function pointer is not set, the libldap library records these errors in fields in the LDAP structure.
  <p>The function must have the prototype specified by <a href="#41630">LDAP_TF_GET_LDERRNO_CALLBACK</a>.
 <dt><code>ltf_set_lderrno</code
 <dd>
  <p>Function pointer for setting error values from calls to functions in the libldap library. This function is called by the client as needed if the function pointer isn't NULL.
  <p>If this function pointer is not set, the libldap library records these errors in fields in the LDAP structure.
  <p>The function must have the prototype specified by <a href="#41653">LDAP_TF_SET_LDERRNO_CALLBACK</a>.
 <dt><code>ltf_lderrno_arg</code>
 <dd>Additional parameter passed to the functions for getting and setting error values from calls to functions in the libldap library. (*ltf_get_lderrno) and (*ltf_set_lderrno) identify these functions.
</dl>
<p>For an example of setting up the ldap_thread_fns structure, see <a href="threaded.htm">Chapter 16 - Writing Multithreaded Clients</a>.

<h3 id="LDAPURLDesc">LDAPURLDesc</h3>
<p>LDAPURLDesc is a type of structure that represents the components of an LDAP URL. LDAP URLs have the following syntax:
<pre>ldap://<var>hostport</var>/<var>dn</var>[?<var>attributes</var>[?<var>scope</var>[?<var>filter</var>]]]</pre>
<p>For example:
<pre>ldap://ldap.itd.umich.edu/c=US?o,description?one?o=umich</pre>
<p>Calling the <a href="function.htm#url-parse">ldap_url_parse()</a> routine creates an LDAPURLDesc structure containing the components of the URL. To free the LDAPURLDesc structure, call the <a href="function.htm#free-urldesc">ldap_free_urldesc()</a> routine.
<p>LDAPURLDesc is defined as follows:
<pre class="code">typedef struct ldap_url_desc {
  char *lud_host;
  int lud_port;
  char *lud_dn;
  char **lud_attrs;
  int lud_scope;
  char *lud_filter;
  unsigned long lud_options;
} LDAPURLDesc;</pre>
<p>The fields in this structure are described below:
<dl>
 <dt><code>lud_host</code>
 <dd>Name of the host in the URL.
 <dt><code>lud_port</code>
 <dd>Number of the port in the URL.
 <dt><code>lud_dn</code>
 <dd>Distinguished name in the URL. This "base entry" DN identifies the starting point of the search.
 <dt><code>lud_attrs</code>
 <dd>Pointer to a NULL-terminated list of the attributes specified in the URL.
 <dt><code>lud_scope</code>
 <dd>
  <p>Integer representing the scope of the search specified in the URL:
  <ul>
   <li>LDAP_SCOPE_BASE specifies a search of the base entry.
   <li>LDAP_SCOPE_ONELEVEL specifies a search of all entries one level under the base entry (not including the base entry).
   <li>LDAP_SCOPE_SUBTREE specified a search of all entries at all levels under the base entry (including the base entry).
  </ul>
 <dt><code>lud_filter</code>
 <dd>Search filter included in the URL.
 <dt><code>lud_options</code>
 <dd>Options (if LDAP_URL_OPT_SECURE, indicates that the protocol is ldaps:// instead of ldap://).
</dl>
<p>For example, suppose you pass the following URL to the <a href="function.htm#url-parse">ldap_url_parse()</a> function:
<pre>ldap://ldap.example.com:5000/dc=example,dc=com?cn,mail, \
  telephoneNumber?sub?(sn=Jensen)</pre>
<p>The resulting LDAPURLDesc structure (ludpp, in this example) will contain the following values:
<dl>
 <dt><code>ludpp-&gt;lud_host</code>
 <dd>ldap.example.com
 <dt><code>ludpp-&gt;lud_port</code>
 <dd>5000</dd>
 <dt><code>ludpp-&gt;lud_dn</code>
 <dd>dc=example,dc=com
 <dt><code>ludpp-&gt;lud_attrs[0]</code>
 <dd>cn
 <dt><code>ludpp-&gt;lud_attrs[1]</code>
 <dd>mail
 <dt><code>ludpp-&gt;lud_attrs[2]</code>
 <dd>telephoneNumber
 <dt><code>ludpp-&gt;lud_attrs[3]</code>
 <dd>NULL
 <dt><code>ludpp-&gt;lud_scope</code>
 <dd>LDAP_SCOPE_SUBTREE</dd>
 <dt><code>ludpp-&gt;lud_filter</code>
 <dd>(sn=Jensen)
</dl>

<h3 id="LDAP_VALCMP_CALLBACK">LDAP_VALCMP_CALLBACK</h3>
<p>LDAP_VALCMP_CALLBACK specifies the prototype for a callback function. If you define a function with this prototype and specify it when calling the <a href="function.htm#sort-values">ldap_sort_values()</a> function, your function will be called by your LDAP client. The client will call your function to sort a specified set of values.
<p>The prototype specified by this data type is:
<pre class="code">typedef int (LDAP_C LDAP_CALLBACK
  LDAP_VALCMP_CALLBACK)(const char**, const char**);</pre>
<p>For information on the arguments, return values, and purpose of this function, see <a href="function.htm#sort-values">ldap_sort_values()</a>.

<h3 id="LDAPVersion">LDAPVersion</h3>
<p>LDAPVersion is deprecated; you should use the function <a href="function.htm#get-option">ldap_get_option()</a> in its place (it is documented here for backward compatibility only).
<p>LDAPVersion contains version information about the LDAP C SDK. Call the <a href="function.htm#version">ldap_version()</a> function to return a pointer to an LDAPVersion structure containing the version information.
<p>LDAPVersion is defined as follows:
<pre class="code">typedef struct _LDAPVersion {
  int sdk_version;
  int protocol_version;
  int SSL_version;
  int security_level;
} LDAPVersion;</pre>
<p>The fields in this structure are described below:
<dl>
 <dt><code>sdk_version</code>
 <dd>Version number of the LDAP C SDK multiplied by 100 (for example, the value 100 in this field represents version 1.0).
 <dt><code>protocol_version</code>
 <dd>Highest supported LDAP protocol version multiplied by 100 (for example, the value 300 in this field represents LDAPv3).
 <dt><code>SSL_version</code>
 <dd>Supported SSL version multiplied by 100 (for example, the value 300 in this field represents SSL 3.0).
 <dt><code>security_level</code>
 <dd>Level of encryption supported in bits (for example, 128 for domestic or 40 for export). If SSL is not enabled, the value of this field is LDAP_SECURITY_NONE.
</dl>

<h3 id="LDAPVirtualList">LDAPVirtualList</h3>
<p>LDAPVirtualList specifies the information that can be used to create a "virtual list view" control. This LDAPv3 control is designed to allow the client to retrieve subsets of search results to display in a "virtual list box".
<p>This control is OID 2.16.840.1.113730.3.4.9, or LDAP_CONTROL_VLVREQUEST as defined in <code class="filename">ldap.h</code>.
<p>This control is supported by the Netscape Directory Server, version 4.0 and later. For information on determining if a server supports this or other LDAPv3 controls, see <a href="srvrinfo.htm#determine_server_support">"Determining If the Server Supports LDAPv3"</a>.
<p>A virtual list box is typically a graphical user interface that displays a long list of entries with a few entries visible. End users can display different sections of the list by scrolling up or down.
<p>To display the list of entries, the client usually does not retrieve the entire list of entries from the server. Instead, the client just retrieves the subset of entries to be displayed to the end user.
<p>The virtual list view control provides the means for your client to request and retrieve certain subsets of a long, sorted list of entries. The control specifies the following information:
<ul>
 <li>The entry in the list that is currently selected.
 <li>The number of entries to be displayed in the list before the selected item.
 <li>The number of entries to be displayed in the list after the selected entry.
</ul>
<p>The currently selected entry can be identified in one of the following ways:
<ul>
 <li>By the index of the entry in the entire list (in which case, the control specifies both the offset of the entry and the total number of entries in the list).
 <li>By the value of the entry (in which case, the control specifies that value).
</ul>
<p>For example, a virtual list view control might specify that you want to retrieve entries 15 through 24 in a list of 100 results with entry 20 being the selected entry. The control uses the following information to specify this:
<ul>
 <li>The selected entry is the 20th entry from the top (in other words, the index or offset of the entry is 20) of a list of 100.
 <li>Get 5 entries before the selected entry in the list (entries 15 - 19).
 <li>Get 4 entries after the selected entry in the list (entries 21 - 24).
</ul>
<p>As another example, a virtual list view control might specify that you want to retrieve a subset of entries that start with the letter "c" or a later letter in the alphabet. The control might specify the following information:
<ul>
 <li>The selected entry is the first entry that starts with the letter "c". (The size of the list is not relevant in determining the selected entry in this case.)
 <li>Get 5 entries before the selected entry in the list.
 <li>Get 4 entries after the selected entry in the list.
</ul>
<p>LDAPVirtualList is defined as follows:
<pre class="code">typedef struct ldapvirtuallist {
  unsigned long ldvlist_before_count;
  unsigned long ldvlist_after_count;
  char *ldvlist_attrvalue;
  unsigned long ldvlist_index;
  unsigned long ldvlist_size;
  void *ldvlist_extradata;
} LDAPVirtualList;</pre>
<p>The fields in this structure are described below:
<dl>
 <dt><code>ldvlist_before_count</code>
 <dd>Number of entries before the selected entry that you want to retrieve.
 <dt><code>ldvlist_after_count</code>
 <dd>Number of entries after the selected entry that you want to retrieve.
 <dt><code>ldvlist_attrvalue</code>
 <dd>
  <p>Specifies the value that you want to find in the list. The selected entry in the list is the first entry that is greater than or equal to this value.
  <p>If this field is NULL, the ldvlist_index and ldvlist_size fields are used to determine the selected entry instead.
 <dt><code>ldvlist_index</code>
 <dd>If the ldvlist_attrvalue field is NULL, specifies the offset or index of the selected entry in the list. This field is used in conjunction with the ldvlist_size field to identify the selected entry.
 <dt><code>ldvlist_size</code>
 <dd>If the ldvlist_attrvalue field is NULL, specifies the total number items in the list. This field is used in conjunction with the ldvlist_index field to identify the selected entry.
 <dt><code>ldvlist_extradata</code>
 <dd>Reserved for application-specific use. Note that this data is not used in the virtual list view control.
</dl>
<p>After you create an LDAPVirtualList structure and specify values for its fields, you can create the virtual list view control by calling the function <a href="function.htm#create-virtuallist-control">ldap_create_virtuallist_control()</a>.
<p>You can pass this control and a server-side sorting control (created by calling the <a href="function.htm#create-sort-keylist">ldap_create_sort_keylist()</a> function and the <a href="function.htm#create-sort-control">ldap_create_sort_control()</a> function) to the <a href="function.htm#search-ext">ldap_search_ext()</a> or <a href="function.htm#search-ext-s">ldap_search_ext_s()</a> function.
<p>To get the virtual list view response control sent back from the server, call the <a href="function.htm#parse-result">ldap_parse_result()</a> function to get the list of controls returned by the server, then call the <a href="function.htm#parse-virtuallist-control">ldap_parse_virtuallist_control()</a> function to retrieve information from the control.
<p>For more information about this control, see <a href="controls.htm#use_virtual_list">"Using the Virtual List View Control."</a>




<hr class="hide">
</div>
</div>
<div id="footer">
<ul>
<li><a href="../../sitemap.html">Site Map</a></li>
<li><a href="../../security/">Security Updates</a></li>
<li><a href="../../contact/">Contact Us</a></li>
<li><a href="../../foundation/donate.html">Donate</a></li>
</ul>
<p class="copyright">
Portions of this content are &copy; 1998&#8211;2009 by individual mozilla.org
contributors; content available under a Creative Commons license | <a
href="http://www.mozilla.org/foundation/licensing/website-content.html">Details</a>.</p>
<p>
<span>Last modified March 16,  2005</span>
<span><a href="http://bonsai-www.mozilla.org/cvslog.cgi?file=mozilla-org/html/directory/csdk-docs/datatype.htm&amp;rev=&amp;root=/www/">Document History</a></span>
</p>
</div>
</div>
</body>
</html>
