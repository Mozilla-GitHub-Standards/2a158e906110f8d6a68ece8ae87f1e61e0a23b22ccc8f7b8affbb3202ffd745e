<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<link rel="top" title="Home" href="http://www.mozilla.org/">
<link rel="stylesheet" type="text/css" href="../../css/print.css"  media="print">
<link rel="stylesheet" type="text/css" href="../../css/base/content.css"  media="all">
<link rel="stylesheet" type="text/css" href="../../css/cavendish/content.css" title="Cavendish" media="screen">
<link rel="stylesheet" type="text/css" href="../../css/base/template.css"  media="screen">
<link rel="stylesheet" type="text/css" href="../../css/cavendish/template.css" title="Cavendish" media="screen">
<link rel="icon" href="../../images/mozilla-16.png" type="image/png">

 <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <title>Mozilla LDAP C SDK: Chapter 5 - Using the LDAP API</title>
<script src="../../__utm.js" type="text/javascript"></script>
</head>
<body id="www-mozilla-org" class="deepLevel">
<div id="container">
<p class="important">You are currently viewing a snapshot of www.mozilla.org taken on April 21, 2008. Most of this content is
highly out of date (some pages haven't been updated since the project began in 1998) and exists for historical purposes only.  If
there are any pages on this archive site that you think should be added back to www.mozilla.org, please <a
href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Websites&component=www.mozilla.org">file a bug</a>.</p>
<p class="skipLink"><a href="#mainContent" accesskey="2">Skip to main content</a></p>
<div id="header">
<h1><a href="/" title="Return to home page" accesskey="1">Mozilla</a></h1>
<ul>
<li id="menu_aboutus"><a href="../../about/" title="Getting the most out of your online experience">About</a></li>
<li id="menu_developers"><a href="../../developer/" title="Using Mozilla's products for your own applications">Developers</a></li>
<li id="menu_store"><a href="http://store.mozilla.org/?r=mozorg1" title="Shop for Mozilla products on CD and other merchandise">Store</a></li>
<li id="menu_support"><a href="../../support/" title="Installation, trouble-shooting, and the knowledge base">Support</a></li>
<li id="menu_products"><a href="../../products/" title="All software Mozilla currently offers">Products</a></li>
</ul>
<form id="searchbox_002443141534113389537:ysdmevkkknw" action="http://www.google.com/cse" title="mozilla.org Search">
<div>
<label for="q" title="Search mozilla.org's sites">search mozilla:</label>
<input type="hidden" name="cx" value="002443141534113389537:ysdmevkkknw">
<input type="hidden" name="cof" value="FORID:0">
<input type="text" id="q" name="q" accesskey="s" size="30">
<input type="submit" id="submit" value="Go">
</div>
</form>
</div>
<hr class="hide">
<div id="mBody">
<div id="side">

<ul id="nav">
<li><a title="Roadmap" href="../../roadmap.html"><strong> Roadmap</strong></a></li>
<li><a title="Projects" href="../../projects/"><strong> Projects</strong></a></li>
<li><a title="For developers" href="../../developer/"><strong> Coding</strong></a>
<ul>
<li><a title="Module Owners" href="../../owners.html"> Module Owners</a></li>
<li><a title="Hacking" href="../../hacking/"> Hacking</a></li>
<li><a title="Get the Source" href="http://developer.mozilla.org/en/docs/Download_Mozilla_Source_Code"> Get the Source</a></li>
<li><a title="Building Mozilla" href="http://developer.mozilla.org/en/docs/Build_Documentation"> Build It</a></li>
</ul>
</li>
<li><a title="Testing" href="../../quality/"><strong> Testing</strong></a>
<ul>
<li><a title="Downloads of mozilla.org software releases" href="../../download.html"> Releases</a></li>
<li><a title="Latest mozilla builds for testers" href="../../developer/#builds"> Nightly Builds</a></li>
<li><a title="For testers to report bugs" href="https://bugzilla.mozilla.org/"> Report A Problem</a></li>
</ul>
</li>
<li><a title="Tools for mozilla developers" href="../../tools.html"><strong> Tools</strong></a>
<ul>
<li><a title="Bug tracking system for mozilla testers." href="https://bugzilla.mozilla.org/"> Bugzilla</a></li>
<li><a title="Latest status of mozilla builds" href="http://tinderbox.mozilla.org/showbuilds.cgi?tree=Firefox"> Tinderbox</a></li>
<li><a title="Latest checkins" href="http://bonsai.mozilla.org/cvsqueryform.cgi"> Bonsai</a></li>
<li><a title="Source cross reference" href="http://lxr.mozilla.org/seamonkey/"> LXR</a></li>
</ul>
</li>
<li><a title="Frequently Asked Questions." href="../../faq.html"><strong> FAQs</strong></a></li>
</ul>

</div>
<hr class="hide">
<div id="mainContent">





<ul class="snav">
 <li><a href="writing.htm">Previous</a>
 <li><a href="./">Contents</a>
 <li><a href="ix.htm">Index</a>
 <li><a href="search.htm">Next</a>
</ul>

<h1>Mozilla LDAP C SDK Programmer's Guide</h1>
<h2>Chapter 5 - Using the LDAP API</h2>

<p>This chapter covers some of the general LDAP API functions that 
are commonly used when writing LDAP clients. This chapter includes 
instructions on getting version information, freeing memory, 
checking for errors, and requesting synchronous and asynchronous 
functions.</p>

<ul>
 <li><a href="using.htm#get_info_sdk">Getting Information About the SDK</a>
 <li><a href="using.htm#manage_memory">Managing Memory</a>
 <li><a href="using.htm#report_errors">Reporting Errors</a>
 <li><a href="using.htm#call_sync_async_function">Calling Synchronous and Asynchronous Functions</a>
 <li><a href="using.htm#handle_referral">Handling Referrals</a>
 <li><a href="using.htm#setup_mem_cache">Setting Up an In-Memory Cache</a>
 <li><a href="using.htm#handle_failover">Handling Failover</a>
</ul>

<h3 id="get_info_sdk">Getting Information About the SDK</h3>

<p>You can get version information about the particular version of 
the Mozilla LDAP C SDK that you are using (for example, the version 
of the SDK or the highest version of the LDAP protocol that it 
supports).</p>

<p>To get this version information, call the 
<code><a href="function.htm#get-option">ldap_get_option()</a></code> 
function using the following option:</p>
<code>  ldap_get_option (..., LDAP_OPT_API_INFO, ...) ;</code>

<p>The following example illustrates retrieving the version information:</p>

<p>
 <strong>Code Example 5-1 - Retrieving LDAP version 
 information</strong>
</p>

<pre class="example code">#include &lt;stdio.h&gt;
#include "ldap.h"

main()
{

LDAPAPIInfo         ldapi;
LDAPAPIFeatureInfo fi;
int                 i;
int                 rc;
LDAP                *ld;

memset( &amp;ldapi, 0, sizeof(ldapi));
ldapi.ldapai_info_version = LDAP_API_INFO_VERSION;

if ((rc = ldap_get_option( ld, LDAP_OPT_API_INFO, &amp;ldapi)) != 0) {
    printf("Error: ldap_get_option (rc: %d)\n", rc);
    exit(0);
}

printf("LDAP Library Information -\n"
    "  Highest supported protocol version: %d\n"
    "  LDAP API revision:         %d\n"
    "  API vendor name:          %s\n"
    "  Vendor-specific version:      %.2f\n",
    ldapi.ldapai_protocol_version, ldapi.ldapai_api_version,
    ldapi.ldapai_vendor_name,
    (float)ldapi.ldapai_vendor_version / 100.0 );

if ( ldapi.ldapai_extensions != NULL ) {
    printf("  LDAP API Extensions:\n");

    for ( i = 0; ldapi.ldapai_extensions[i] != NULL; i++ ) {
      printf("    %s", ldapi.ldapai_extensions[i] );
      fi.ldapaif_info_version = LDAP_FEATURE_INFO_VERSION;
      fi.ldapaif_name = ldapi.ldapai_extensions[i];
      fi.ldapaif_version = 0;

      if ( ldap_get_option( NULL, LDAP_OPT_API_FEATURE_INFO, &amp;fi )
          != 0 ) {
        printf("Error: ldap_get_option( NULL,"
            " LDAP_OPT_API_FEATURE_INFO, ... ) for %s failed"
            " (Feature Info version: %d)\n",
            fi.ldapaif_name, fi.ldapaif_info_version );
      } else {
        printf(" (revision %d)\n", fi.ldapaif_version);
      }
    }
  }
  printf("\n");
}</pre>

<h3 id="manage_memory">Managing Memory</h3>

<p>Several of the LDAP API functions allocate memory when called. 
When you have finished working with data allocated by these 
functions, you should free the memory.</p>

<p><a href="using.htm#table_5_1">Table 5-1</a> lists some of the API 
functions that allocate memory and the corresponding functions that 
you must call to free the memory when you are done.</p>

<p id="table_5_1">
 <strong>Table 5-1 - API functions that allocate and free memory</strong>
</p>

<table class="data">
 <tr>
  <th>Functions to free memory</th>
  <th>Type of memory freed</th>
 </tr>
 <tr>
  <td><code><a href="function.htm#unbind">ldap_unbind()</a></code> or 
  <code><a href="function.htm#unbind-s">ldap_unbind_s()</a></code>
 </td>
  <td>Frees <code><a href="datatype.htm#LDAP">LDAP</a></code> 
   structures allocated by calling 
   <code><a href="function.htm#init">ldap_init()</a></code>.
 </td>
 </tr>
 <tr>
  <td><code><a href="function.htm#msgfree">ldap_msgfree()</a></code></td>
  <td>Frees <code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> 
   structures allocated by calling 
   <code><a href="function.htm#result">ldap_result()</a></code> or 
   <code><a href="function.htm#search-ext-s">ldap_search_ext_s()</a>.</code>
 </td>
 </tr>
 <tr>
  <td><code><a href="function.htm#ldap-ber-free">ldap_ber_free()</a></code></td>
  <td>Frees <code><a href="datatype.htm#BerElement">BerElement</a></code> 
   structures allocated by calling 
   <code><a href="function.htm#first-attribute">ldap_first_attribute()</a></code>.
  </td>
 </tr>
 <tr>
  <td><code><a href="function.htm#value-free">ldap_value_free()</a></code></td>
  <td>Frees <code>char **</code> arrays structures allocated by 
   calling <code><a href="function.htm#get-values">ldap_get_values()</a></code>.
  </td>
 </tr>
 <tr>
  <td><code><a href="function.htm#value-free-len">ldap_value_free_len()</a></code></td>
  <td>Frees Arrays of <code><a href="datatype.htm#berval">berval</a></code> 
   structures allocated by calling 
   <code><a href="function.htm#get-values-len">ldap_get_values_len()</a></code>.
  </td>
 </tr>
 <tr>
  <td><code><a href="function.htm#ber-bvfree">ber_bvfree()</a></code></td>
  <td>Frees <code><a href="datatype.htm#berval">berval</a></code> 
   structures allocated by calling 
   <code><a href="function.htm#extended-operation-s">ldap_extended_operation_s()</a></code>, 
   <code><a href="function.htm#parse-extended-result">ldap_parse_extended_result()</a></code>, 
   <code><a href="function.htm#parse-sasl-bind-result">ldap_parse_sasl_bind_result()</a></code>, 
   and <code><a href="function.htm#sasl-bind-s">ldap_sasl_bind_s()</a></code>.
  </td>
 </tr>
 <tr>
  <td><code><a href="function.htm#free-friendlymap">ldap_free_friendlymap()</a></code></td>
  <td>Frees <code><a href="datatype.htm#FriendlyMap">FriendlyMap</a></code> 
   structures allocated by calling 
   <code><a href="function.htm#friendly-name">ldap_friendly_name()</a></code>.
  </td>
 </tr>
 <tr>
  <td><code><a href="function.htm#free-urldesc">ldap_free_urldesc()</a></code></td>
  <td>Frees <code><a href="datatype.htm#LDAPURLDesc">LDAPURLDesc</a></code> 
   structures allocated by calling 
   <code><a href="function.htm#url-parse">ldap_url_parse()</a></code>.
  </td>
 </tr>
 <tr>
  <td><code><a href="function.htm#getfilter-free">ldap_getfilter_free()</a></code></td>
  <td>Frees <code><a href="datatype.htm#LDAPFiltDesc">LDAPFiltDesc</a></code> 
   structures allocated by calling
   <code><a href="function.htm#init-getfilter">ldap_init_getfilter()</a></code> 
   or <code><a href="function.htm#init-getfilter-buf">ldap_init_getfilter_buf()</a></code>.
  </td>
 </tr>
 <tr>
  <td><code><a href="function.htm#mods-free">ldap_mods_free()</a></code></td>
  <td>Frees <code><a href="datatype.htm#LDAPMod">LDAPMod</a> **</code> 
   arrays and structures allocated by functions that you call when 
   you add or modify entries.
  </td>
 </tr>
 <tr>
  <td><code><a href="function.htm#free-sort-keylist">ldap_free_sort_keylist()</a></code></td>
  <td>Frees <code><a href="datatype.htm#LDAPsortkey">LDAPsortkey</a> **</code> 
   arrays structures allocated by calling 
   <code><a href="function.htm#create-sort-keylist">ldap_create_sort_keylist()</a>.</code></td>
 </tr>
 <tr>
  <td><code><a href="function.htm#control-free">ldap_control_free()</a></code></td>
  <td>Frees <code><a href="datatype.htm#LDAPControl">LDAPControl</a></code> 
   structures allocated by calling
   <code><a href="function.htm#create-sort-control">ldap_create_sort_control()</a></code> 
   or <code><a href="function.htm#create-persistentsearch-control">ldap_create_persistentsearch_control()</a>.</code>
  </td>
 </tr>
 <tr>
  <td><code><a href="function.htm#controls-free">ldap_controls_free()</a></code></td>
  <td>Frees <code><a href="datatype.htm#LDAPControl">LDAPControl</a> **</code> 
   arrays structures allocated by calling 
   <code><a href="function.htm#get-entry-controls">ldap_get_entry_controls()</a></code>, 
   <code><a href="function.htm#parse-result">ldap_parse_result()</a></code>, 
   or <code><a href="function.htm#parse-reference">ldap_parse_reference()</a>.</code>
  </td>
 </tr>
 <tr>
  <td><code><a href="function.htm#memfree">ldap_memfree()</a></code></td>
  <td>Any other types of memory that you allocate (this function is 
   a general function for freeing memory).
  </td>
 </tr>
</table>

<p>See the descriptions of individual functions in 
<a href="function.htm">Chapter 18 - Function Reference</a> for more 
information about memory management.</p>

<h3 id="report_errors">Reporting Errors</h3>

<p>In the LDAP protocol, the success or failure of an operation is 
specified by an LDAP result code sent back to the client. A result 
code of <code>0</code> normally indicates that the operation was 
successful whereas a non-zero result code usually indicates that an 
error occurred.</p>

<p>The following sections explain more about handling and reporting errors:</p>

<ul>
 <li><a href="using.htm#get_info_error">Getting Information About the Error</a>
 <li><a href="using.htm#get_error_message">Getting the Error Message</a>
 <li><a href="using.htm#set_error_code">Setting Error Codes</a>
 <li><a href="using.htm#print_error_message">Printing Out Error Messages</a>
</ul>

<h3 id="get_info_error">Getting Information About the Error</h3>

<p>When an error occurs in an LDAP operation, the server sends the 
following information back to the client:</p>

<ul>
 <li>The LDAP result code for the error that occurred.
 <li>A message containing any additional information about the 
  error from the server.
</ul>

<p>If the error occurred because an entry specified by a DN could 
not be found, the server may also return the portion of the DN that 
identifies an existing entry. (See 
<a href="using.htm#receive_portion_dn_matching_entry">"Receiving the 
Portion of the DN Matching an Entry"</a> for an explanation.)</p>

<p>There are two ways you can get this information back from the 
server:</p>

<ul>
 <li>If you are calling asynchronous functions, you can get the 
  information from the 
  <code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> 
  structure representing the result returned from the server.
  <p></p>
  For details, see <a href="using.htm#get_info_LDAPMessage">"Getting 
  the Information from an LDAPMessage Structure</a>."
 <li>In situations where you do not have an 
  <code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> 
  structure (for example, if you are calling functions that do not 
  interact with the server), you can get error information from the 
  connection handle. For details, see 
  <a href="using.htm#get_info_LDAP">"Getting the Information from an 
  LDAP Structure."</a>
</ul>

<h4 id="receive_portion_dn_matching_entry">Receiving the Portion of the DN Matching an Entry</h4>

<p>According to the LDAPv3 protocol, if a server returns an 
<code>LDAP_NO_SUCH_OBJECT</code>, <code>LDAP_ALIAS_PROBLEM</code>, 
<code>LDAP_INVALID_DN_SYNTAX</code>, or 
<code>LDAP_ALIAS_DEREF_PROBLEM</code> result code, the LDAP server 
should also send back the portion of DN that matches the entry that 
is closest to the requested entry.</p>

<p>For example, suppose the LDAP server processes a request to modify 
the entry with the DN 
"<code>uid=bjensen,ou=Contractors,dc=example,dc=com</code>" but that 
entry does not exist in the directory.</p>

<ul>
 <li>If the entry with the DN 
  "<code>ou=Contractors,dc=example,dc=com</code>" does exist, the 
  server sends this portion of the DN 
  ("<code>ou=Contractors,dc=example,dc=com</code>") with the result 
  code <code>LDAP_NO_SUCH_OBJECT</code>.
 <li>If the entry with the DN 
  "<code>ou=Contractors,dc=example,dc=com</code>" does exist either, 
  but the entry with the DN "<code>dc=example,dc=com</code>" does 
  exist, the server sends "<code>dc=example,dc=com</code>" back to 
  the client with the result code <code>LDAP_NO_SUCH_OBJECT</code>.
  <p></p>
  Basically, the server moves back up the directory tree (one DN 
  component at a time) until it can find a DN that identifies an 
  existing entry.
</ul>

<h4 id="get_info_LDAPMessage"">Getting the Information from an LDAPMessage Structure</h4>

<p>If you have requested the operation through an asynchronous 
function, not a synchronous function (see 
<a href="using.htm#call_sync_async_function">"Calling Synchronous and Asynchronous 
Functions"</a> for the difference between these functions), you can 
get the result of the operation from the server by calling the 
<code><a href="function.htm#result">ldap_result()</a></code> function.</p>

<p>This function passes the result as an 
<code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> structure. 
You can get information from this structure by calling the 
<code><a href="function.htm#parse-result">ldap_parse_result()</a></code> 
function:</p>

<pre class="example code">LDAP_API(int) LDAP_CALL ldap_parse_result( LDAP *ld,
  LDAPMessage *res, int *errcodep, char **matcheddnp,
  char **errmsgp, char ***referralsp,
  LDAPControl ***serverctrlsp, int freeit );</pre>

<p>The different types of information are returned in the following 
parameters of this function:</p>

<ul>
 <li>The LDAP result code is the <code>errcodep</code> argument.
 <li>Additional information from the server is passed back as the 
  <code>errmsgp</code> argument.
 <li>In cases when the server cannot find an entry from a DN, the 
  portion of the DN that identifies an existing entry is passed back 
  as the <code>matcheddnp</code> argument. (See 
  <a href="using.htm#receive_portion_dn_matching_entry">"Receiving the 
  Portion of the DN Matching an Entry"</a> for details.)
</ul>

<p>Note that you can also get the error message describing the LDAP 
result code by using the 
<code><a href="function.htm#err2string">ldap_err2string()</a></code> 
function. (See the section <a href="using.htm#get_error_message">"Getting 
the Error Message"</a> for details.)</p>

<p>For a listing and descriptions of the different LDAP result codes, 
see <a href="error.htm">Chapter 19 - Result Codes</a>.</p>

<p>The following section of code gets and prints information about 
an error returned from the server.</p>

<p>
 <strong>Code Example 5-2 - Receiving and printing error codes from 
 an LDAPMessage structure</strong>
</p>

<pre class="example code">#include &lt;stdio.h&gt;
#include "ldap.h"
...
LDAP              *ld;
LDAPMessage       *res;
int               msgid = 0, rc = 0, parse_rc = 0, finished = 0;
char              *matched_msg = NULL, *error_msg = NULL;
char              **referrals;
LDAPControl       **serverctrls;
struct timeval    zerotime;
...
while ( !finished ) {
  /* Check to see if the server returned a result. */
  rc = ldap_result( ld, msgid, 0, &amp;zerotime, &amp;res );
  switch ( rc ) {
  ...
  default:
    /* The client has received the result of the LDAP operation. */
    finished = 1;

    /* Parse this result to determine if the operation was successful. 
    parse_rc = ldap_parse_result( ld, res, &amp;rc, &amp;matched_msg, 
      &amp;error_msg, &amp;referrals, &amp;serverctrls, 1 );

    /* Verify that the result was parsed correctly. */
    if ( parse_rc != LDAP_SUCCESS ) {
      fprintf( stderr, "ldap_parse_result error: %s\n", 
        ldap_err2string( parse_rc ) );
      ldap_unbind( ld );
      return( 1 );
    }

    /* Check the results of the operation. */
    if ( rc != LDAP_SUCCESS ) {

      /* Print the error message corresponding to the result code. */
      fprintf( stderr, "Error: %s\n", 
        ldap_err2string( rc ) );

      /* If the server sent an additional message, print it out. */
      if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
        fprintf( stderr, "%s\n", error_msg );
      }

      /* If the server cannot find an entry with the specified DN, 
        it may send back the portion of the DN that matches 
        an existing entry, For details, see 
        <a href="using.htm#receive_portion_dn_matching_entry">"Receiving the Portion of the DN Matching an Entry"</a>. */
      if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
        fprintf( stderr, 
          "Part of the DN that matches an existing entry: %s\n", 
          matched_msg );
      }

      /* Disconnect and return. */
      ldap_unbind( ld );
      return( 1 );
    } 
...</pre>

<h4 id="get_info_LDAP">Getting the Information from an LDAP Structure</h4>

<p>In situations where you don't get an 
<code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> structure 
(for example, if you are calling functions that do not interact with 
the server), you can get error information from the connection 
handle (the <code><a href="datatype.htm#LDAP">LDAP</a></code> 
structure).</p>

<p>To get information about the last error that has occurred, call 
the <code><a href="function.htm#get-lderrno">ldap_get_lderrno()</a></code> 
function:</p>

<code>LDAP_API(int) LDAP_CALL ldap_get_lderrno(LDAP *ld, char **m, char **s);</code>

<p>The different types of information are returned in the following 
ways:</p>

<ul>
 <li>The LDAP result code is returned by this function.
 <li>Additional information from the server is passed back as the 
  <code>s</code> argument.
 <li>In cases when the server cannot find an entry from a DN, the 
  portion of the DN that identifies an existing entry is passed 
  back as the <code>m</code> argument. (See 
  <a href="using.htm#receive_portion_dn_matching_entry">"Receiving the Portion of the DN 
  Matching an Entry"</a> for details.)
</ul>

<p>If you do not need to use the parameters returned by the 
<code>ldap_get_lderrno()</code> function, set the parameters to a 
<code>NULL</code> value. For example:</p>

<code>ldap_get_lderrno( ld, NULL, NULL );</code>

<p>The following section of code gets and prints information about 
an error.</p>

<p>
 <strong>Code Example 5-3 - Getting an error message from an LDAP 
 structure</strong>
</p>

<pre class="example code">#include &lt;stdio.h&gt;
#include "ldap.h"
...
LDAP     *ld;
char*    *error_msg = NULL, *matched_msg = NULL;
int      rc;
...
rc = ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
fprintf( stderr, "ldap_result error: %s\n", ldap_err2string( rc ) );
if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
  fprintf( stderr, "%s\n", error_msg );
}

/* If the server cannot find an entry with the specified DN, 
  it may send back the portion of the DN that matches 
  an existing entry, For details, see "Receiving the Portion of the DN Matching an Entry". */
if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
  fprintf( stderr, 
    "Part of the DN that matches an existing entry: %s\n", 
    matched_msg );
}
...</pre>

<h3 id="get_error_message">Getting the Error Message</h3>

<p>If you have an error code and want to retrieve its corresponding 
error message, call the 
<code><a href="function.htm#err2string">ldap_err2string()</a></code> 
function. The function returns a pointer to the error message. For 
example:</p>

<p>
 <strong>Code Example 5-4 - Returning an error message from an 
 error code</strong>
</p>

<pre class="example code">#include &lt;stdio.h&gt;
#include "ldap.h"
...
int      rc;
...
if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "Error: %s\n", ldap_err2string( rc ) );
}
...</pre>

<p>Note that the pointer returned by this function is a pointer to 
static data; do not free this string.</p>

<h3 id="set_error_code">Setting Error Codes</h3>

<p>When an LDAP operation is performed, the error information from 
the operation is specified in the <code>LDAP</code> structure. If 
you want to set error codes and error information in the 
<code>LDAP</code> structure, call the 
<code><a href="function.htm#set-lderrno">ldap_set_lderrno()</a></code> 
function.</p>

<p>The following section of code sets the <code>LDAP_PARAM_ERROR</code> 
error code in the <code>LDAP</code> structure.</p>

<p>
 <strong>Code Example 5-5 - Setting an error code</strong>
</p>

<pre class="example code">#include "ldap.h"
...
LDAP *ld;
char *errmsg = "Invalid parameter";
...
if ( ldap_my_function() != LDAP_SUCCESS ) {
  ldap_set_lderrno( ld, LDAP_PARAM_ERROR, NULL, errmsg );
  return( 1 );
}
...</pre>

<h3 id="print_error_message">Printing Out Error Messages</h3>

<p>To print out the error message describing the last error that 
occurred, call the 
<code><a href="function.htm#get-lderrno">ldap_get_lderrno()</a></code> 
function.</p>

<p>This example prints a message if a function fails to delete an 
entry in the server.</p>

<p>
 <strong>Code Example 5-6 - Printing error codes</strong>
</p>

<pre class="example code">#include "ldap.h"
...
int lderr;
char * errmsg;
LDAP *ld;
char *dn = "uid=bjensen, ou=People, dc=example,dc=com";
...
if ( ldap_delete_s( ld, dn ) != LDAP_SUCCESS ) {
  lderr = ldap_get_lderrno (ld, NULL, &amp;errmsg); 
  if ( errmsg, != NULL ) {
    fprintf(stderr, "ldap_delete_s: %s\n", errmsg );
    ldap_memfree( errmsg );
  }
  return( 1 );
}
...</pre>

<p>In the preceding example, the client prints out this error 
message if it does not have access permissions to delete the entry:</p>

<code>ldap_delete_s: Insufficient access</code>

<h3 id="call_sync_async_function">Calling Synchronous and Asynchronous Functions</h3>

<p>You can perform the operation as a synchronous or asynchronous 
operation. For example, to search the directory, you can call either 
the synchronous function <code>ldap_search_ext_s()</code>, or the 
asynchronous function <code>ldap_search_ext()</code>. In general, 
the synchronous functions have names ending with the characters 
<code>_s</code> (for example, <code>ldap_search_ext_s()</code>).</p>

<ul>
 <li>For details on calling synchronous functions, see 
  <a href="using.htm#call_sync_function">"Calling Synchronous Functions."</a>
 <li>For details on calling asynchronous functions, see 
  <a href="using.htm#call_async_function">"Calling Asynchronous Functions</a>."
</ul>

<h3 id="call_sync_async_function">Calling Synchronous Functions</h3>

<p>When you call a <I>synchronous function</I>, your client waits 
for the operation to complete before executing any subsequent lines 
of code. Synchronous functions return <code>LDAP_SUCCESS</code> if 
successful and an LDAP error code if not successful.</p>

<p>This example calls a synchronous function to delete an entry in 
the directory.</p>

<p>
 <strong>Code Example 5-7 - Calling synchronous functions</strong>
</p>

<pre class="example code">#include &lt;stdio.h&gt;
#include "ldap.h"
...
LDAP      *ld;
char      *matched_msg = NULL, *error_msg = NULL;
int        rc;
...
/* Perform an LDAP delete operation. */
rc = ldap_delete_ext_s( ld, DELETE_DN, NULL, NULL );
if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_delete_ext_s: %s\n", ldap_err2string( rc ) );
  ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
  if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
    fprintf( stderr, "%s\n", error_msg );
  }

  /* If the server cannot find an entry with the specified DN, 
    it may send back the portion of the DN that matches 
    an existing entry, For details, see 
    "Receiving the Portion of the DN Matching an Entry" */
  if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
    fprintf( stderr, 
      "Part of the DN that matches an existing entry: %s\n", 
      matched_msg );
  }
} else {
  printf( "%s deleted successfully.\n", DELETE_DN );
}
...</pre>

<p>To see additional sample programs that call synchronous 
functions, see the source files in the <code>examples</code> 
directory of the Mozilla LDAP C SDK.</p>

<h3 id="call_async_function">Calling Asynchronous Functions</h3>

<p>When you call an asynchronous function, your client does not need 
to wait for the operation to complete. The client can continue 
performing other tasks (such as initiating other LDAP operations) 
while the LDAP operation is executing.</p>

<p>An asynchronous function passes back a unique message ID that 
identifies the operation being performed. You can pass this message 
ID to the <code><a href="function.htm#result">ldap_result()</a></code> 
function to check the status of the LDAP operation.</p>

<p>This section explains how to call an asynchronous function and 
check the results of the LDAP operation. The following topics are 
covered:</p>

<ul>
 <li><a href="using.htm#check_ldap_request_sent">Checking if the LDAP Request was Sent</a>
 <li><a href="using.htm#get_server_response">Getting the Server Response</a>
 <li><a href="using.htm#get_info_server_response">Getting Information from the Server Response</a>
 <li><a href="using.htm#cancel_operation_progress">Canceling an Operation in Progress</a>
</ul>

<p>The section also includes an example of calling an asynchronous 
function (see <a href="using.htm#example_call_async_function">"Example 
of Calling an Asynchronous Function"</a>).</p>

<p>To see sample programs that call asynchronous functions see the 
source files in the <code>examples</code> directory of the Mozilla 
LDAP C SDK.</p>

<h4 id="check_ldap_request_sent">Checking if the LDAP Request was Sent</h4>

<p>Asynchronous functions return an LDAP result code indicating 
whether or not the LDAP request was successfully sent to the server. 
If the function returns <code>LDAP_SUCCESS</code>, the function 
successfully sent the request to the server.</p>

<p>For example, the following section of code send an LDAP delete 
request to the server. The example checks if the result was 
successfully sent.</p>

<p>
 <strong>Code Example 5-8 - Asynchronous return codes</strong>
</p>

<pre class="example code">#include &lt;stdio.h&gt;
#include "ldap.h"
...
/* Change these as needed. */
#define DELETE_DN "uid=wjensen,ou=People,dc=example,dc=com"
...
LDAP       *ld;
int        rc, msgid;
...
/* Send an LDAP delete request to the server. */
rc = ldap_delete_ext( ld, DELETE_DN, NULL, NULL, &amp;msgid );
if ( rc != LDAP_SUCCESS ) {
  /* If the request was not sent successfully, 
    print an error message and return. */
  fprintf( stderr, "ldap_delete_ext: %s\n", ldap_err2string( rc ) );
  ldap_unbind( ld );
  return( 1 );
}
...</pre>

<h4 id="get_server_response">Getting the Server Response</h4>

<p>If the request was successfully sent, the function passes back 
the message ID of the LDAP operation. You can use this message ID to 
determine if the server has sent back the results for this specific 
operation.</p>

<p>To check for results, call the 
<code><a href="function.htm#result">ldap_result()</a></code> 
function, and pass the message ID as a parameter. You can also 
specify a time-out period to wait for results from the server.</p>

<p>The function returns one of the following values:</p>

<ul>
 <li><code>-1</code> indicates that an error occurred.
 <li><code>0</code> indicates that the time-out period has been 
  exceeded and the server has not yet sent a response back to your client.
 <li>Any other value indicates that the server has sent a response 
  for the requested operation back to your client.
</ul>

<p>You can set up a loop to poll for results while doing other work. 
For example, suppose you defined a function that did work while 
waiting for the LDAP operation to complete and the server to send a 
response back to your client:</p>

<pre class="example code">int global_counter = 0;
void
do_other_work()
{
  global_counter++;
}</pre>

<p>You can set up a <code>while</code> loop to call your function 
when you are not checking for the server's response:</p>

<p>
 <strong>Code Example 5-9 - Getting response from a server</strong>
</p>

<pre class="example code">#include &lt;stdio.h&gt;
#include "ldap.h"
...
LDAP              *ld;
LDAPMessage       *res;
LDAPControl       **serverctrls;
char              *matched_msg = NULL, *error_msg = NULL;
char              **referrals;
int               rc, parse_rc, msgid, finished = 0;
struct timeval    zerotime;

zerotime.tv_sec = zerotime.tv_usec = 0L;
...
/* Send an LDAP delete request to the server. */
rc = ldap_delete_ext( ld, DELETE_DN, NULL, NULL, &amp;msgid );
...
/* Poll the server for the results of the LDAP operation. */
while ( !finished ) {
  rc = ldap_result( ld, msgid, 0, &amp;zerotime, &amp;res );

  /* Check to see if a result was received. */
  switch ( rc ) {
  case -1:
    .../* An error occurred. */...
  case 0:
    /* The timeout period specified by zerotime was exceeded.
      This means that the server has still not yet sent the 
      results of the delete operation back to your client.
      Break out of this switch statement, and continue calling 
      ldap_result() to poll for results. */
  default:
    finished = 1;
    .../* Your client received a response from the server. */...
  }

  /* Do other work while waiting. This is 
    called if ldap_result() returns 0 (before you continue 
    to the top of the loop and call ldap_result() again). */
  if ( !finished ) {
    do_other_work();
  }
  ...
}
...</pre>

<h4 id="get_info_server_response">Getting Information from the Server Response</h4>

<p>If the <code><a href="function.htm#result">ldap_result()</a></code> 
function gets the response sent from the server, the 
<code>result</code> parameter passes back a pointer to an 
<code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> structure. 
This structure contains the server's response, which can include the 
following information:</p>

<ul>
 <li>An LDAP result code specifying the result of the operation you 
  requested.
 <li>An additional error message (optional) sent back from the server.
 <li>If the server was not able to find the entry specified by a DN, 
  the portion of the DN that identifies an existing entry (see 
  <a href="using.htm#receive_portion_dn_matching_entry">"Receiving the Portion of the DN 
  Matching an Entry"</a> for details).
 <li>A set of referrals, if the server's directory does not contain 
  the requested entries and if the server is configured to refer 
  clients to other servers.
 <li>A set of server response controls applicable to the operation you 
  requested (see <a href="controls.htm">Chapter 14 - Working with LDAP 
  Controls</a> for information on LDAPv3 controls).
</ul>

<p>Note that when processing LDAP search operations, the server can 
also send back individual entries matching the search, individual 
search references, and chains of entries and search references. For 
information on processing these types of results from the server, 
see <a href="search.htm">Chapter 6 - Searching the Directory</a>.</p>

<p>To get information from a server response, call the 
<code><a href="function.htm#parse-result">ldap_parse_result()</a></code> 
function:</p>

<pre class="example code">LDAP_API(int) LDAP_CALL
ldap_parse_result( LDAP *ld, LDAPMessage *res, int *errcodep,
  char **matcheddnp, char **errmsgp, char ***referralsp,
  LDAPControl ***serverctrlsp, int freeit );</pre>

<p>You can get the following information from parameters of this 
function:</p>

<ul>
 <li><code>errcodep</code> is the LDAP result code of the operation 
  that the server finished processing.
 <li><code>matcheddnp</code> is the portion of the DN that matches 
  an existing entry, if the server is not able to find an entry for 
  a DN that you've specified (for details, see 
  <a href="using.htm#receive_portion_dn_matching_entry">"Receiving the Portion of the DN 
  Matching an Entry"</a>).
 <li><code>errmsgp</code> is an additional error message that the 
  server can send to your client.
 <li><code>referralsp</code> is a set of referrals sent back to your 
  client by the server, if you've requested an entry that is not 
  part of the directory tree managed by the server and if the server 
  is configured to refer clients to other LDAP servers.
 <li><code>serverctrlsp</code> is a set of server response controls 
  applicable to the LDAP operation.
</ul>

<p>When you are done, you should call 
<code><a href="function.htm#msgfree">ldap_msgfree()</a></code> to free 
the <code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> 
structure unless the structure is part of a chain of results. If you 
pass a non-zero value for the <code>freeit</code> parameter, the 
structure is automatically freed after the information is retrieved.</p>

<p>The result code returned by this function is not the same as the 
result code of the operation (<code>errcodep</code>). The result 
code returned by this operation indicates the success or failure of 
parsing the <code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> 
structure.</p>

<p>For example, the following section of code retrieves error 
information from an 
<code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> structure 
returned by the <code><a href="function.htm#result">ldap_result()</a></code>.</p>

<p>
 <strong>Code Example 5-10 - Regiving error information from an 
 LDAPMessage structure</strong>
</p>

<pre class="example code">#include &lt;stdio.h&gt;
#include "ldap.h"
...
LDAP              *ld;
LDAPMessage       *res;
LDAPControl       **serverctrls;
char              *matched_msg = NULL, *error_msg = NULL;
char              **referrals;
int               rc, parse_rc, msgid, finished = 0;
struct timeval    zerotime;

zerotime.tv_sec = zerotime.tv_usec = 0L;
...
rc = ldap_result( ld, msgid, 0, &amp;zerotime, &amp;res );

/* Check to see if a result was received. */
switch ( rc ) {
case -1:
  ...
case 0:
  ...
default:
  ...
  /* Call ldap_parse_result() to get information from the results 
    received from the server. */
  parse_rc = ldap_parse_result( ld, res, &amp;rc, &amp;matched_msg, 
    &amp;error_msg, &amp;referrals, &amp;serverctrls, 1 );

  /* Make sure the results were parsed successfully. */
  if ( parse_rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_parse_result: %s\n", 
      ldap_err2string( parse_rc ) );
    ldap_unbind( ld );
    return( 1 );
  }

  /* Check the results of the LDAP operation. */
  if ( rc != LDAP_SUCCESS ) {
    fprintf(stderr, "Error: %s\n", ldap_err2string(rc));
    if ( error_msg != NULL &amp; *error_msg != '\0' ) {
      fprintf( stderr, "%s\n", error_msg );
    }
    /* If the server returned the portion of the DN 
      that identifies an existing entry, 
      print it out. (For details, see 
      "Receiving the Portion of the DN Matching an Entry") */
    if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
      fprintf( stderr, 
        "Part of the DN that matches an existing entry: %s\n", 
        matched_msg );
    }
  } else {
    printf( "Operation completed successfully" );
  }
}
...</pre>

<h4 id="cancel_operation_progress">Canceling an Operation in Progress</h4>

<p>If you need to cancel the LDAP operation, call the 
<code><a href="function.htm#abandon-ext">ldap_abandon_ext()</a></code> 
function. The function returns <code>LDAP_SUCCESS</code> if 
successful or an LDAP result code if an error occurs.</p>

<p>Once you cancel an LDAP operation, you cannot retrieve the 
results of that operation. (In other words, calling 
<code>ldap_result()</code> does not return any results.)</p>

<h4 id="example_call_async_function">Example of Calling an Asynchronous Function</h4>

<p>The following section of code calls an asynchronous function 
to delete an entry in the directory. The code calls 
<code>ldap_result()</code> within a loop to poll the results of the 
LDAP delete operation.</p>

<p>
 <strong>Code Example 5-11 - Deleting an entry using an asynchronous 
 function call</strong>
</p>

<pre class="example code">#include &lt;stdio.h&gt;
#include "ldap.h"
...
void do_other_work();
int global_counter = 0;
...
/* Change these as needed. */
#define DELETE_DN "uid=wjensen,ou=People,dc=example,dc=com"
...
LDAP              *ld;
LDAPMessage       *res;
LDAPControl       **serverctrls;
char              *matched_msg = NULL, *error_msg = NULL;
char              **referrals;
int               rc, parse_rc, msgid, finished = 0;
struct timeval    zerotime;

zerotime.tv_sec = zerotime.tv_usec = 0L;
...
/* Send an LDAP delete request to the server. */
rc = ldap_delete_ext( ld, DELETE_DN, NULL, NULL, &amp;msgid );
if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_delete_ext: %s\n", ldap_err2string( rc ) );
  ldap_unbind( ld );
  return( 1 );
}

/* Poll the server for the results of the delete operation. */
while ( !finished ) {
  /* Call ldap_result() to get the results of the delete operation. 
    ldap_result() blocks for the time period 
    specified by the timeout argument (set to 
    zerotime here) while waiting for the result 
    from the server. */
  rc = ldap_result( ld, msgid, 0, &amp;zerotime, &amp;res );

  /* Check to see if a result was received. */
  switch ( rc ) {
  case -1:
    /* If ldap_result() returned -1, an error occurred. */
    rc = ldap_get_lderrno( ld, NULL, NULL );
    fprintf( stderr, "ldap_result: %s\n", ldap_err2string( rc ) );
    ldap_unbind( ld );
    return( 1 );

  case 0:
    /* The timeout period specified by zerotime was exceeded.
      This means that the server has still not yet sent the 
      results of the delete operation back to your client.
      Break out of this switch statement, and continue calling 
      ldap_result() to poll for results. */
    break;

  default:
    /* ldap_result() got the results of the delete operation
      from the server. No need to keep polling. */
    finished = 1;

    /* Call ldap_parse_result() to get information from the results 
      received from the server. Note the last
      argument is a non-zero value. This means after the 
      function retrieves information from the 
      LDAPMessage structure , the structure is freed. 
      (You don't need to call ldap_msgfree() to free the structure.)
    */
    parse_rc = ldap_parse_result( ld, res, &amp;rc, &amp;matched_msg, 
      &amp;error_msg, &amp;referrals, &amp;serverctrls, 1 );
    if ( parse_rc != LDAP_SUCCESS ) {
      fprintf( stderr, "ldap_parse_result: %s\n", 
        ldap_err2string( parse_rc ) );
      ldap_unbind( ld );
      return( 1 );
    }

    /* Check the results of the LDAP delete operation. */
    if ( rc != LDAP_SUCCESS ) {
      fprintf(stderr, "ldap_delete_ext: %s\n", ldap_err2string(rc));
      if ( error_msg != NULL &amp; *error_msg != '\0' ) {
        fprintf( stderr, "%s\n", error_msg );
      }
      /* Print the portion of a specified DN 
        that matches an existing entry, if 
        returned by the server. (For details, see 
        "Receiving the Portion of the DN Matching an Entry.") */
      if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
        fprintf( stderr, 
          "Part of the DN that matches an existing entry: %s\n", 
          matched_msg );
      }
    } else {
      printf( "%s deleted successfully.\n"
        "Counted to %d while waiting for the delete operation.\n",
        DELETE_DN, global_counter );
    }
  }

  /* Do other work while waiting for the results of the 
    delete operation. */
  if ( !finished ) {
    do_other_work();
  }
}
ldap_unbind( ld );
return 0;
...

/* Perform other work while polling for results. */
void
do_other_work()
{
  global_counter++;
}
...</pre>

<h3 id="handle_referral">Handling Referrals</h3>

<p>If an LDAP server receives a request for a DN that is not under 
its directory tree, it can refer clients to another LDAP server 
that may contain that DN. This is known as a 
<a href="glossary.htm#referral">referral</a>.</p>

<p>This section explains how to set up your LDAP client to handle 
referrals automatically. The following topics are covered:</p>

<ul>
 <li><a href="using.htm#understand_referral">Understanding Referrals</a>
 <li><a href="using.htm#enable_disable_referral_handle">Enabling or Disabling Referral Handling</a>
 <li><a href="using.htm#limit_referral_hop">Limiting Referral Hops</a>
 <li><a href="using.htm#bind_follow_referral">Binding When Following Referrals</a>
</ul>

<h3 id="understand_referral">Understanding Referrals</h3>

<p>Suppose an LDAP server has a directory that starts under 
"<code>dc=example,dc=com</code>". If your client sends the server a 
request to modify the entry with the DN 
"<code>uid=bjensen,ou=People,o=Example,c=US</code>" (an entry that 
is not under "<code>dc=example,dc=com</code>"), one of the following 
may occur:</p>

<ul>
 <li>If the server is not configured to send a referral, the server 
  sends back an <code>LDAP_NO_SUCH_OBJECT</code> result code.
 <li>If the server is configured to refer you to another LDAP 
  server, the server sends a referral back to your client. This 
  consists of the result code (<code>LDAP_PARTIAL_RESULTS</code> for 
  LDAPv2 clients, <code>LDAP_REFERRAL</code> for LDAPv3 clients) and 
  one or more LDAP URLs.
  <p></p>
  For LDAPv2 clients, the URLs are included in the error message 
  that the server sends to the client. For LDAPv3 clients, the URLs 
  are included in a separate section of the result.
  <p></p>
  Depending on how your LDAP client is configured, one of the 
  following may occur:
   <ul>
   <li>If your client handles referrals automatically, your client 
    connects to the LDAP server specified in the referral and 
    requests the operation from that server. (The client binds 
    anonymously to that server. To bind as a specific user, see the 
    section <a href="using.htm#bind_follow_referral">"Binding When Following 
    Referrals</a>.")
   <li>If your client does not handle referrals automatically, your 
    client returns the result code sent from the server 
    (<code>LDAP_PARTIAL_RESULTS</code> or <code>LDAP_REFERRAL</code>). 
    You can get the LDAP URLs from the result by calling the 
    <code><a href="function.htm#parse-result">ldap_parse_result()</a></code> 
    function.
  </ul>
  By default, clients built with the Mozilla LDAP C SDK are 
  configured to follow referrals automatically.
</ul>

<p>Another concept similar to a referral is a 
<a href="glossary.htm#search_reference">search reference</a>. A search reference 
is an entry with the object class "<code>referral</code>". The 
"<code>ref</code>" attribute of this object contains an LDAP URL 
that identifies another LDAP server.</p>

<p>When your client searches a subtree of the directory that 
contains search references, the server returns a mix of matching 
entries and search references. As your client retrieves search 
references from the server, one of the following occurs:</p>

<ul>
 <li>If your client handles referrals automatically, the LDAP API 
  library retrieves each search reference, binds to the server 
  identified in the reference (see <a href="using.htm#bind_follow_referral">"Binding 
  When Following Referrals"</a> for information on specifying the DN 
  and password for binding), and retrieves the entry.
 <li>If your client does not handle referrals automatically, the 
  LDAP API library simply adds the search reference to the chain of 
  search results. The search reference is a message of the type 
  <code>LDAP_RES_SEARCH_REFERENCE</code>.
  <p></p>
  You can get the search references from a chain of results by 
  calling the 
  <code><a href="function.htm#first-reference">ldap_first_reference()</a></code> 
  and <code><a href="function.htm#next-reference">ldap_next_reference()</a></code> 
  functions. You can also call the 
  <code><a href="function.htm#first-message">ldap_first_message()</a></code> 
  and <code><a href="function.htm#next-message">ldap_next_message()</a></code> 
  functions to get each message in the search results, then call the 
  <code><a href="function.htm#msgtype">ldap_msgtype()</a></code> 
  function to determine if the message is of the type 
  <code>LDAP_RES_SEARCH_REFERENCE</code>.
</ul>

<h3 id="enable_disable_referral_handle">Enabling or Disabling Referral Handling</h3>

<p>By default, Mozilla LDAP C SDK clients automatically follow these 
referrals to other servers.</p>

<p>To change the way referrals are handled, call the 
<code><a href="function.htm#set-option">ldap_set_option()</a></code> 
function and pass <code>LDAP_OPT_REFERRALS</code> as the value of 
the <code>option</code> parameter.</p>

<ul>
 <li>To prevent the client from automatically following referrals, 
  set the <code>optdata</code> parameter to <code>LDAP_OPT_OFF</code>.
 <li>If you want the client to automatically follow referrals again, 
  set the <code>optdata</code> parameter to <code>LDAP_OPT_ON</code>.
</ul>

<p>Note that both <code>LDAP_OPT_OFF</code> and 
<code>LDAP_OPT_ON</code> are cast to <code>(void *)</code>. You can 
pass these parameters directly to the function (see the example below).</p>

<p>The following example prevents the client from automatically 
following referrals to other LDAP servers.</p>

<p>
 <strong>Code Example 5-12 - Disabling referrals</strong>
</p>

<pre class="example code">#include &lt;stdio.h&gt;
#include "ldap.h"
...
LDAP    *ld;
int    &nbsp;rc;
char    *host = "localhost";
...
/* Initialize a session with the LDAP server ldap.example.com:389. */
if ( ( ld = ldap_init( host, LDAP_PORT ) ) == NULL ) { 
  perror( "ldap_init" );
  return( 1 );
}

/* Never follow referrals. */
if (ldap_set_option(ld,LDAP_OPT_REFERRALS,LDAP_OPT_OFF)!=LDAP_SUCCESS){
  rc = ldap_get_lderrno( ld, NULL, NULL );
  fprintf( stderr, "ldap_set_option: %s\n", 
    ldap_err2string( rc );
  return( 1 );
}
...</pre>

<h3 id="limit_referral_hop">Limiting Referral Hops</h3>

<p>As a preference for the connection (or as a search constraint for 
specific search operations), you can specify the maximum number of 
referral hops that should be followed in a sequence of referrals. 
This is called the <a href="glossary.htm#referral_hop_limit">referral hop limit</a>.</p>

<p>For example, suppose you set a limit of 2 referral hops. If your 
client is referred from LDAP server A to LDAP server B, from LDAP 
server B to LDAP server C, and from LDAP server C to LDAP server D, 
your client is being referred 3 times in a row, and it will not 
follow the referral to LDAP server D because this exceeds the 
referral hop limit.</p>

<p>If the referral hop limit is exceeded, the LDAP result code 
<code>LDAP_REFERRAL_LIMIT_EXCEEDED</code> is returned.</p>

<p>To set this limit, pass <code>LDAP_OPT_REFERRAL_HOP_LIMIT</code> 
as the value of the <code>option</code> parameter and pass the 
maximum number of hops as value of the <code>optdata</code> parameter.</p>

<p>By default, the maximum number of hops is 5.</p>

<h3 id="bind_follow_referral">Binding When Following Referrals</h3>

<p>If the session is set up so that referrals are always followed 
(see <a href="using.htm#enable_disable_referral_handle">"Enabling or 
Disabling Referral Handling"</a> for more information), the LDAP server 
that you connect to may refer you to another LDAP server. By default, 
the client binds anonymously (no user name or password specified) when 
following referrals.</p>

<p>This section explains how to set up your client to authenticate 
with a selected DN and credentials when following referrals. Topics 
include:</p>

<ul>
 <li><a href="using.htm#how_bind_work_follow_referral">How Binding Works When Following Referrals</a>
 <li><a href="using.htm#define_rebind_function">Defining the Rebind Function</a>
 <li><a href="using.htm#register_rebind_function">Registering the Rebind Function</a>
</ul>

<h4 id="how_bind_work_follow_referral">How Binding Works When Following Referrals</h4>

<p>If you want your client to authenticate to the LDAP server that 
it is referred to, you need to specify a way to get the DN and 
password to be used for authentication. You need to define a rebind 
function of the type 
<code><a href="datatype.htm#LDAP_REBINDPROC_CALLBACK">LDAP_REBINDPROC_CALLBACK</a></code>. 
Then, you specify that your function should be used if binding to 
other servers when following referrals.</p>

<p>The following steps explain how this works:</p>

<ol>
 <li>The LDAP server sends a referral back to the client. The 
  referral contains an LDAP URL that identifies another LDAP server.
 <li>The client calls the rebind function (the function specified by 
  the <code>LDAP_OPT_REBIND_FN</code> option), passing <code>0</code> 
  as the <code>freeit</code> argument.
 <li>The rebind function sets the <code>dnp</code>, 
  <code>passwdp</code>, and <code>authmethodp</code> arguments to 
  point to the following information:
  <ul>
   <li>The <code>dnp</code> argument is set to point to the DN to be 
    used to authenticate to the new LDAP server.
   <li>The <code>passwdp</code> argument is set to point to the 
    credentials for this DN.
   <li>The <code>authmethodp</code> argument is set to point to the 
    method of authentication used (for example, 
    <code>LDAP_AUTH_SIMPLE</code>).
  </ul>
 <li>If successful, the rebind function returns 
  <code>LDAP_SUCCESS</code>, and referral processing continues.
  <p></p>
  (If any other value is returned, referral processing stops, and 
  that value is returned as the result code for the original LDAP 
  request.)
 <li>The client gets the DN, credentials, and authentication method 
 from the arguments of the rebind function and uses this information 
 to authenticate to the new LDAP server.
 <li>The client calls the rebind function again, passing 1 as the 
  <code>freeit</code> argument.
 <li>The rebind function frees any memory allocated earlier to 
  specify the DN and credentials.
</ol>

<h4 id="define_rebind_function">Defining the Rebind Function</h4>

<p>You need to define a rebind function that does the following:</p>
<ul>
 <li>If <code>freeit</code> is 0, set the following pointers:
  <ul>
   <li>Set <code>dnp</code> to point to the DN to be used for 
    authentication.
   <li>Set <code>passwdp</code> to point to the credentials to be 
    used for authentication.
   <li>Set <code>authmethodp</code> to point to the method of 
    authentication used (for example, <code>LDAP_AUTH_SIMPLE</code>).
  </ul>
  <p></p>
  You can make use of the <code>arg</code> argument, which is a 
  pointer to the argument specified in the 
  <code><a href="function.htm#set-rebind-proc">ldap_set_rebind_proc()</a></code> 
  function.
  <p></p>
  If successful, return <code>LDAP_SUCCESS</code>; otherwise, 
  return the appropriate LDAP error code.
 <li>If <code>freeit</code> is <code>1</code>, free any memory that 
 you allocated to create the DN and credentials.
</ul>

<p>You need to write a function that has the following prototype:</p>

<pre class="example code">int LDAP_CALL LDAP_CALLBACK rebindproc( LDAP *ld, char **dnp,
  char **passwdp, int *authmethodp, int freeit, void *arg );</pre>

<p>The parameters for this prototype are described below:</p>

<p>
 <strong>Table 5-2 - LDAP_CALL_LDAP_CALLBACK parameters</strong>
</p>

<table class="data">
 <tr>
  <th>Parameter Name</th>
  <th>Description</th>
 </tr>
 <tr>
  <td><code><code>ld</td>
  <td>The connection handle to the LDAP server.</td>
 </tr>
 <tr>
  <td><code><code>dnp</td>
  <td>A pointer to the distinguished name of the user (or entity) 
   who wants to perform the LDAP operations. Your function needs to 
   set this value.
  </td>
 </tr>
 <tr>
  <td><code><code>passwdp</td>
  <td>A pointer to the user's (or entity's) password. Your function 
   needs to set this value.
  </td>
 </tr>
 <tr>
  <td><code><code>authmethodp</td>
  <td>A pointer to the method of authentication. Your function needs to 
  set this value.
  </td>
 </tr>
 <tr>
  <td><code><code>freeit</td>
  <td>Specifies whether or not to free the memory allocated by the 
   previous <code>rebindproc()</code> function call (in the event 
   that this function is called more than once). If 
   <code>freeit</code> is set to a non-zero value, your function 
   should free the memory allocated by the previous call.
  </td>
 </tr>
 <tr>
  <td><code><code>arg</td>
  <td>A pointer to data that can be passed to your function.</td>
 </tr>
</table>

<p><code>LDAP_CALL</code> and <code>LDAP_CALLBACK</code> are used to 
set up calling conventions (for example, Pascal calling conventions 
on Windows). These are defined in the <code>lber.h</code> header file.</p>

<h4 id="register_rebind_function">Registering the Rebind Function</h4>

<p>Once you have a function that follows this prototype, you need to 
register the rebind function. You can do this in one of the 
following two ways:</p>

<ul>
 <li>Call the LDAP API function 
  <code><a href="function.htm#set-rebind-proc">ldap_set_rebind_proc()</a></code>, 
  specifying your function and any data that you want passed as an 
  argument.
 <li>Call 
  <code><a href="function.htm#set-option">ldap_set_option()</a></code> to 
  set the <code>LDAP_OPT_REBIND_FN</code> option to your function 
  and the <code>LDAP_OPT_REBIND_ARG</code> option to specify any 
  arguments you want passed to your rebind function.
</ul>

<p>Both of these methods register your rebind function.</p>

<h3 id="setup_mem_cache">Setting Up an In-Memory Cache</h3>

<p>The Mozilla LDAP C SDK includes functions that allow you to create 
an in-memory cache of search results for your client. When send a 
search request and receive results, the results are cached. The next 
time your client issues the same search request, the results are 
read from the cache.</p>

<p>To set up a cache for your connection, do the following:</p>

<ol>
 <li>Call the 
  <code><a href="function.htm#memcache-init">ldap_memcache_init()</a></code> 
  function to create a new 
  <code><a href="datatype.htm#LDAPMemCache">LDAPMemCache</a></code> 
  structure, which is the cache. Pass the pointer to this structure 
  to subsequent operations.
 <li>Call the 
  <code><a href="function.htm#memcache-set">ldap_memcache_set()</a></code> 
  function to associate the cache with an LDAP connection handle 
  (an <a href="datatype.htm#LDAP">LDAP</a> structure).
</ol>

<p>For example:</p>
<p>
 <strong>Code Example 5-13 - Creating an in-memory cache</strong>
</p>

<pre class="example code">#include "ldap.h"
...
#define HOSTNAME "localhost"
#define PORTNUMBER LDAP_PORT
...
LDAP          *ld;
LDAPMemCache  *dircache;
char *matched_msg = NULL, *error_msg = NULL;
int rc;
...
/* Get a handle to an LDAP connection. */
if ( (ld = ldap_init( HOSTNAME, PORTNUMBER )) == NULL ) {
  perror( "ldap_init" );
  return( 1 );
}
...
/* Create an in-memory cache. */
rc = ldap_memcache_init( 0, 0, NULL, NULL, &amp;dircache );
if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_memcache_init: %s\n", ldap_err2string( rc ) );
  ldap_unbind( ld );
  return( 1 );
}

/* Associate the cache with the connection. */
rc = ldap_memcache_set( ld, dircache );
if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_memcache_set: %s\n", ldap_err2string( rc ) );
  ldap_unbind( ld );
  return( 1 );
}
...</pre>

<p>When a search request is cached, the search criteria is used as 
the key to the item in the cache. If you run the same search again, 
the results are read from the cache. If you alter the criteria (for 
example, specifying that you want all attributes returned instead of 
just the <code>uid</code> attribute), your client gets the results 
from the server rather than from the cache.</p>

<p>The cache periodically checks for expired items and removes them 
from the cache. If you are writing a multi threaded application and 
want to set up a separate thread to keep the cache up-to-date, you 
can call the 
<code><a href="function.htm#memcache-update">ldap_memcache_update()</a></code> 
function.</p>

<p>To remove items from the cache or flush the cache, call the 
<code><a href="function.htm#memcache-flush">ldap_memcache_flush()</a></code> 
function. When you are done working with the cache, call the 
<code><a href="function.htm#memcache-destroy">ldap_memcache_destroy()</a></code> 
function.</p>

<h3 id="handle_failover">Handling Failover</h3>

<p>While performing an LDAP operation, if the LDAP client loses the 
connection with the server, the LDAP API library returns an 
<code>LDAP_SERVER_DOWN</code> or <code>LDAP_CONNECT_ERROR</code> 
result code.</p>

<p>To reconnect to the server, you can do one of the following:</p>

<ul>
 <li>Free the current connection handle and create a new connection 
  handle.
  <p></p>
  For details, see <a href="using.htm#create_new_connection_handle">"Creating 
  a New Connection Handle."</a>
 <li>Use the reconnect option (<code>LDAP_OPT_RECONNECT</code>) to 
  connect to the server again with the same connection handle.
  <p></p>
  You can use this option if you do not want to free the connection 
  handle (for example, if multiple threads are sharing the same 
  connection handle). For details, see 
  <a href="using.htm#use_reconnect_option">"Using the Reconnect Option."</a>
</ul>

<h3 id="create_new_connection_handle">Creating a New Connection Handle</h3>

<p>Call the <code><a href="function.htm#unbind">ldap_unbind()</a></code> 
or <code><a href="function.htm#unbind-s">ldap_unbind_s()</a></code> 
function to free the existing connection handle (the 
<code><a href="datatype.htm#LDAP">LDAP</a></code> structure), and 
then call the <code><a href="function.htm#init">ldap_init()</a></code> 
function to open and initialize a new connection. For example:</p>

<p>
 <strong>Code Example 5-14 - Initializing a new connection handle</strong>
</p>

<pre class="example code">...
LDAP</a> *ld;
int tries = 0, rc = 0;
...
do {
  /* Call a function that performs an LDAP operation 
  (my_ldap_request_function() can be any of these functions, 
  such as ldap_search_ext_s()) */
  rc = my_ldap_request_function( ld ); 

  /* Check to see if the connection was lost. */
  if ( rc != LDAP_SERVER_DOWN &amp;&amp; rc != LDAP_CONNECT_ERROR ) {
    return( rc ); /* Return result code. */
  }

  /* If the connection was lost, free the handle. */
  ldap_unbind( ld );

  /* Create a new connection handle and 
   attempt to bind again. */
  if (( ld = ldap_init( hostlist, port )) != NULL ) {
    ldap_simple_bind_s();

    /* Perform any other initialization 
    work on the connection handle. */
  }
} while ( ld != NULL &amp;&amp; ++tries &lt; 2 );
...</pre>

<p>The disadvantage of this approach is that you need free the 
<a href="datatype.htm#LDAP">LDAP</a> connection handle, which can 
make it difficult to share connection handles between threads. If 
you do not want to free the connection handle, you can use the 
reconnect option instead, as described in 
<a href="using.htm#use_reconnect_option">"Using the Reconnect Option."</a></p>

<h3 id="use_reconnect_option">Using the Reconnect Option</h3>

<p>To reconnect to the server without freeing the connection handle 
(for example, if multiple threads need to share the same connection 
handle), call the 
<code><a href="function.htm#set-option">ldap_set_option()</a></code> 
function to set the <code>LDAP_OPT_RECONNECT</code> option to <
code>LDAP_OPT_ON</code>. Do this right after calling 
<code><a href="function.htm#init">ldap_init()</a>:</code></p>

<p>
 <strong>Code Example 5-15 - Reconnecting to an existing connection 
 handle</strong>
</p>

<pre class="example code">...
#define HOSTNAME "localhost"
#define PORTNUMBER LDAP_PORT
...
LDAP</a> *ld;
...
/* Get a handle to an LDAP connection. */
if ( (ld = ldap_init( HOSTNAME, PORTNUMBER )) == NULL ) {
  perror( "ldap_init" );
  return( 1 );
}

/* Set the reconnect option. */
if ( ldap_set_option( ld, LDAP_OPT_RECONNECT, LDAP_OPT_ON ) == 0 ) {
  /* success */
  } else { 
  /* failure */
} 
...</pre>

<p>After setting this option, if the connection to the LDAP server 
has been lost (if the LDAP API library returns an 
<code>LDAP_SERVER_DOWN</code> or <code>LDAP_CONNECT_ERROR</code> 
result code to your client), call the 
<code><a href="function.htm#simple-bind-s">ldap_simple_bind_s()</a></code> 
function to reestablish a connection to one of the hosts specified 
in the <code><a href="function.htm#init">ldap_init()</a></code> 
function call.</p>

<p>If your client is able to reconnect with the server, the 
<code><a href="function.htm#simple-bind-s">ldap_simple_bind_s()</a></code> 
function call issues an LDAP bind request to the server and returns 
the result.</p>

<p>Note that if the client has been successfully authenticated to 
the server using the current 
<code><a href="datatype.htm#LDAP">LDAP</a></code> structure and if 
the connection to the LDAP server has not been lost, 
<code><a href="function.htm#simple-bind-s">ldap_simple_bind_s()</a></code> 
returns <code>LDAP_SUCCESS</code> without contacting the LDAP server.</p>

<p>The function is designed to do this in cases where more than one 
thread shares the same <a href="datatype.htm#LDAP">LDAP</a> 
connection handle and receives an <code>LDAP_SERVER_DOWN</code> or 
<code>LDAP_CONNECT_ERROR</code> error. If multiple threads call the 
<code><a href="function.htm#simple-bind-s">ldap_simple_bind_s()</a></code> 
function, the function is designed so that only one of the threads 
actually issues the bind operation. For the other threads, the 
function returns <code>LDAP_SUCCESS</code> without contacting the 
LDAP server.</p>

<p>The important side effect to note is that if the 
<code>LDAP_OPT_RECONNECT</code> option is set, 
<code><a href="function.htm#simple-bind-s">ldap_simple_bind_s()</a></code> 
may return <code>LDAP_SUCCESS</code> without contacting the LDAP 
server. (The function only returns this if a bind with the DN was 
successfully performed in the past.)</p>

<p>The following section of code attempts to reconnect to the server 
if the client is disconnected from the server:</p>

<p>
 <strong>Code Example 5-16 - Reconnecting to a server after a 
 disconnect</strong>
</p>

<pre class="example code">...
LDAP *ld;
int tries = 0, rc = 0;
...
do {
  /* Call a function that performs an LDAP operation 
  (my_ldap_request_function() can be any of these functions, 
  such as ldap_search_ext_s()) */
  rc = my_ldap_request_function( ld ); 

  /* Check to see if the connection was lost. */
  if ( rc != LDAP_SERVER_DOWN &amp;&amp; rc != LDAP_CONNECT_ERROR ) {
    return( rc ); /* Return the result code. */
  }

  /* If the connection was lost, call 
  ldap_simple_bind_s() to reconnect. */
  if ( ldap_simple_bind_s( ld, dn, passwd ) != LDAP_SUCCESS ) {
    /* failure -- could not reconnect */
    /* remember that ld as bad */
    return( rc );
  }
} while ( ++tries &lt; 2 );</pre>




<hr class="hide">
</div>
</div>
<div id="footer">
<ul>
<li><a href="../../sitemap.html">Site Map</a></li>
<li><a href="../../security/">Security Updates</a></li>
<li><a href="../../contact/">Contact Us</a></li>
<li><a href="../../foundation/donate.html">Donate</a></li>
</ul>
<p class="copyright">
Portions of this content are &copy; 1998&#8211;2009 by individual mozilla.org
contributors; content available under a Creative Commons license | <a
href="http://www.mozilla.org/foundation/licensing/website-content.html">Details</a>.</p>
<p>
<span>Last modified March 16,  2005</span>
<span><a href="http://bonsai-www.mozilla.org/cvslog.cgi?file=mozilla-org/html/directory/csdk-docs/using.htm&amp;rev=&amp;root=/www/">Document History</a></span>
</p>
</div>
</div>
</body>
</html>
