<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<link rel="top" title="Home" href="http://www.mozilla.org/">
<link rel="stylesheet" type="text/css" href="../../css/print.css"  media="print">
<link rel="stylesheet" type="text/css" href="../../css/base/content.css"  media="all">
<link rel="stylesheet" type="text/css" href="../../css/cavendish/content.css" title="Cavendish" media="screen">
<link rel="stylesheet" type="text/css" href="../../css/base/template.css"  media="screen">
<link rel="stylesheet" type="text/css" href="../../css/cavendish/template.css" title="Cavendish" media="screen">
<link rel="icon" href="../../images/mozilla-16.png" type="image/png">

 <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <title>Mozilla LDAP C SDK: Chapter 8 - Adding, Updating, and Deleting Entries</title>
<script src="../../__utm.js" type="text/javascript"></script>
</head>
<body id="www-mozilla-org" class="deepLevel">
<div id="container">
<p class="important">You are currently viewing a snapshot of www.mozilla.org taken on April 21, 2008. Most of this content is
highly out of date (some pages haven't been updated since the project began in 1998) and exists for historical purposes only.  If
there are any pages on this archive site that you think should be added back to www.mozilla.org, please <a
href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Websites&component=www.mozilla.org">file a bug</a>.</p>
<p class="skipLink"><a href="#mainContent" accesskey="2">Skip to main content</a></p>
<div id="header">
<h1><a href="/" title="Return to home page" accesskey="1">Mozilla</a></h1>
<ul>
<li id="menu_aboutus"><a href="../../about/" title="Getting the most out of your online experience">About</a></li>
<li id="menu_developers"><a href="../../developer/" title="Using Mozilla's products for your own applications">Developers</a></li>
<li id="menu_store"><a href="http://store.mozilla.org/?r=mozorg1" title="Shop for Mozilla products on CD and other merchandise">Store</a></li>
<li id="menu_support"><a href="../../support/" title="Installation, trouble-shooting, and the knowledge base">Support</a></li>
<li id="menu_products"><a href="../../products/" title="All software Mozilla currently offers">Products</a></li>
</ul>
<form id="searchbox_002443141534113389537:ysdmevkkknw" action="http://www.google.com/cse" title="mozilla.org Search">
<div>
<label for="q" title="Search mozilla.org's sites">search mozilla:</label>
<input type="hidden" name="cx" value="002443141534113389537:ysdmevkkknw">
<input type="hidden" name="cof" value="FORID:0">
<input type="text" id="q" name="q" accesskey="s" size="30">
<input type="submit" id="submit" value="Go">
</div>
</form>
</div>
<hr class="hide">
<div id="mBody">
<div id="side">

<ul id="nav">
<li><a title="Roadmap" href="../../roadmap.html"><strong> Roadmap</strong></a></li>
<li><a title="Projects" href="../../projects/"><strong> Projects</strong></a></li>
<li><a title="For developers" href="../../developer/"><strong> Coding</strong></a>
<ul>
<li><a title="Module Owners" href="../../owners.html"> Module Owners</a></li>
<li><a title="Hacking" href="../../hacking/"> Hacking</a></li>
<li><a title="Get the Source" href="http://developer.mozilla.org/en/docs/Download_Mozilla_Source_Code"> Get the Source</a></li>
<li><a title="Building Mozilla" href="http://developer.mozilla.org/en/docs/Build_Documentation"> Build It</a></li>
</ul>
</li>
<li><a title="Testing" href="../../quality/"><strong> Testing</strong></a>
<ul>
<li><a title="Downloads of mozilla.org software releases" href="../../download.html"> Releases</a></li>
<li><a title="Latest mozilla builds for testers" href="../../developer/#builds"> Nightly Builds</a></li>
<li><a title="For testers to report bugs" href="https://bugzilla.mozilla.org/"> Report A Problem</a></li>
</ul>
</li>
<li><a title="Tools for mozilla developers" href="../../tools.html"><strong> Tools</strong></a>
<ul>
<li><a title="Bug tracking system for mozilla testers." href="https://bugzilla.mozilla.org/"> Bugzilla</a></li>
<li><a title="Latest status of mozilla builds" href="http://tinderbox.mozilla.org/showbuilds.cgi?tree=Firefox"> Tinderbox</a></li>
<li><a title="Latest checkins" href="http://bonsai.mozilla.org/cvsqueryform.cgi"> Bonsai</a></li>
<li><a title="Source cross reference" href="http://lxr.mozilla.org/seamonkey/"> LXR</a></li>
</ul>
</li>
<li><a title="Frequently Asked Questions." href="../../faq.html"><strong> FAQs</strong></a></li>
</ul>

</div>
<hr class="hide">
<div id="mainContent">





<ul class="snav">
 <li><a href="filter.htm">Previous</a>
 <li><a href="./">Contents</a>
 <li><a href="ix.htm">Index</a>
 <li><a href="compare.htm">Next</a>
</ul>
 
<h1>Mozilla LDAP C SDK Programmer's Guide</h1>
<h2>Chapter 8 - Adding, Updating, and Deleting Entries</h2>

<p>This chapter explains how to use the API functions to add, modify, 
delete, and rename entries in the directory. The chapter also 
provides examples of calling synchronous and asynchronous functions 
to perform these operations.</p>

<p>The chapter includes the following sections:</p>

<ul>
 <li>
  <a href="addmod.htm#specify-new-modified-attribute">Specifying a New 
  or Modified Attribute</a>
 <li><a href="addmod.htm#add-new-entry">Adding a New Entry</a>
  <ul>
   <li>
    <a href="addmod.htm#example-add-entry-directory-sync">Example: 
    Adding an Entry to the Directory (Synchronous)</a>
   <li>
    <a href="addmod.htm#example-add-entry-directory-async">Example: 
    Adding an Entry to the Directory (Asynchronous)</a>
  </ul>
 <li><a href="addmod.htm#modify-entry">Modifying an Entry</a>
  <ul>
   <li>
    <a href="addmod.htm#example-modify-entry-directory-sync">Example: 
    Modifying an Entry in the Directory (Synchronous)</a>
   <li>
    <a href="addmod.htm#example-modify-entry-directory-async">Example: 
    Modifying an Entry in the Directory (Asynchronous)</a>
  </ul>
 <li><a href="addmod.htm#delete-entry">Deleting an Entry</a>
  <ul>
   <li>
    <a href="addmod.htm#example-delete-entry-directory-sync">Example: 
    Deleting an Entry from the Directory (Synchronous)</a>
   <li>
    <a href="addmod.htm#example-delete-entry-directory-async">Example: 
    Deleting an Entry from the Directory (Asynchronous)</a>
  </ul>
 <li><a href="addmod.htm#change-dn-entry">Changing the DN of an Entry</a>
  <ul>
   <li>
    <a href="addmod.htm#example-rename-entry-directory-sync">Example: 
    Renaming an Entry in the Directory (Synchronous)</a>
   <li>
    <a href="addmod.htm#example-rename-entry-directory-async">Example: 
    Renaming an Entry in the Directory (Asynchronous)</a>
  </ul>
</ul>

<h3 id="specify-new-modified-attribute">Specifying a New or Modified Attribute</h3>

<p>In order to add or modify an entry in the directory, you need to 
specify information about the entry's attributes:</p>

<ul>
 <li>
 If you are adding an entry, you must specify the attributes in 
 the new entry.
 <li>
 If you are modifying an entry, you must specify the attributes and 
 values that you are adding, replacing, or removing.
</ul>

<p>In most of the cases above, you need to specify the following 
attribute information:</p>

<ul>
 <li>
 The operation that you are performing, if you are modifying an 
 existing entry (in other words, adding, modifying, or deleting the 
 attribute in the existing entry).
 <li>
 The type of attribute that you are working with (for example, the 
 <code>sn</code> attribute or the <code>telephoneNumber</code> 
 attribute).
 <li>The values that you are adding or replacing in the attribute
</ul>

<p>To specify this information, you use an 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structure.</p>

<p>
 <strong>Code Example 8-1 - Adding or modifying an attribute</strong>
</p>

<pre class="code example">  int mod_op;
  char *mod_type;
  union {
    char **modv_strvals;
    struct berval **modv_bvals;
  } mod_vals;
#define mod_values        mod_vals.modv_strvals
#define mod_bvalues       mod_vals.modv_bvals
} LDAPMod;</pre>

<p>The following table details the fields in the <code>LDAPMod</code> 
data structure:</p>

<p><strong>Table 8-1 - LDAPMod field descriptions</strong></p>

<table class="data">
 <tr>
  <th>Field</th>
  <th>Description</th>
 </tr>
 <tr>
  <td><code>mod_op</td>
  <td>
   The operation to be performed on the attribute and the type of 
   data specified as the attribute values. This field can have one 
   of the following values:
   <p></p>
   <ul>
    <li><code>LDAP_MOD_ADD</code> adds a value to the attribute.
    <li><code>LDAP_MOD_DELETE</code> removes the value from the attribute.
    <li>
     <code>LDAP_MOD_REPLACE</code> replaces all existing values of 
     the attribute.
  </ul>
   <p></p>
   In addition, if you are specifying binary values in the 
   <code>mod_bvalues</code> field, you should use the bitwise OR 
   operator ( | ) to combine <code>LDAP_MOD_BVALUES</code> with the 
   operation type. For example:
   <p></p>
   <code>mod-&gt;mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES</code>
   <p></p>
   Note that if you are using the structure to add a new entry, you 
   can specify 0 for the <code>mod_op</code> field (unless you are 
   adding binary values and need to specify 
   <code>LDAP_MOD_BVALUES</code>). See 
   <a href="addmod.htm#add-new-entry">"Adding a New Entry"</a> for details. 
  </td>
 </tr>
 <tr>
  <td><code>mod_type</td>
  <td>
   The attribute type that you want to add, delete, or replace the 
   values of (for example, "<code>sn</code>" or 
   "<code>telephoneNumber</code>"). 
  </td>
 </tr>
 <tr>
  <td><code>mod_values </td>
  <td>
   A pointer to a <code>NULL</code>-terminated array of string 
   values for the attribute. 
  </td>
 </tr>
 <tr>
  <td><code>mod_bvalues </td>
  <td>
   A pointer to a <code>NULL</code>-terminated array of 
   <a href="datatype.htm#berval">berval</a> structures for the 
   attribute. 
  </td>
 </tr>
</table>

<p>Note the following:</p>

<ul>
 <li>
  If you specify <code>LDAP_MOD_DELETE</code> in the 
  <code>mod_op</code> field and you remove all values in an 
  attribute, the attribute is removed from the entry.
 <li>
  If you specify <code>LDAP_MOD_DELETE</code> in the 
  <code>mod_op</code> field and <code>NULL</code> in the 
  <code>mod_values</code> field, the attribute is removed from the 
  entry.
 <li>
  If you specify <code>LDAP_MOD_REPLACE</code> in the 
  <code>mod_op</code> field and <code>NULL</code> in the 
  <code>mod_values</code> field, the attribute is removed from the 
  entry.
 <li>
  If you specify <code>LDAP_MOD_REPLACE</code> in the 
  <code>mod_op</code> field and the attribute does not exist in the 
  entry, the attribute is added to the entry.
 <li>
  If you specify <code>LDAP_MOD_ADD</code> in the <code>mod_op</code> 
  field and the attribute does not exist in the entry, the attribute 
  is added to the entry.
</ul>

<p>If you've allocated memory for the structures yourself, you 
should free the structures when you're finished by calling the 
<code><a href="function.htm#mods-free">ldap_mods_free()</a></code> 
function.</p>

<p>For information on how to set up 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures to 
add and modify entries in the directory, see the sections 
<a href="addmod.htm#specify-attribute">"Specifying the Attributes"</a> and 
<a href="addmod.htm#specify-changes">"Specifying the Changes."</a></p>

<h3 id="add-new-entry">Adding a New Entry</h3>

<p>To add an entry to the directory:</p>

<ol>
 <li>
  Create an array of 
  <code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures 
  to represent the attributes in the entry. Use the 
  <code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structure to 
  specify the name and values of each attribute.
 <li>
  Call the <code><a href="function.htm#add-ext">ldap_add_ext()</a></code> 
  or <code><a href="function.htm#add-ext-s">ldap_add_ext_s()</a></code>, 
  passing in the array of 
  <code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures 
  and a distinguished name for the entry.
</ol>

<p>After you are done, call the 
<code><a href="function.htm#mods-free">ldap_mods_free()</a></code> 
function to free any 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures 
you've allocated.</p>

<h3 id="specify-attribute">Specifying the Attributes</h3>

<p>This section describes the process of specifying the attributes 
and values of the new entry in the following sections:</p>

<ul>
 <li>
  <a href="addmod.htm#specify-single-value-attribute">Specifying a 
  Single Value in an Attribute</a>
 <li>
  <a href="addmod.htm#specify-multi-value-attribute">Specifying 
  Multiple Values in an Attribute</a>
 <li>
  <a href="addmod.htm#specify-binary-data-value-attribute">Specifying 
  Binary Data as the Values of an Attribute</a>
 <li>
  <a href="addmod.htm#specify-attribute-entry">Specifying the 
  Attributes in the Entry</a>
</ul>

<h4 id="specify-single-value-attribute">Specifying a Single Value in an Attribute</h4>

<p>To specify a value in an attribute, set the <code>mod_op</code>, 
<code>mod_type</code>, and <code>mod_values</code> fields in an 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structure. 
(See the section <a href="addmod.htm#specify-new-modified-attribute">"Specifying 
a New or Modified Attribute"</a> for a brief overview of this structure.)</p>

<p>The following section of code sets up the structure for the 
<code>sn</code> attribute:</p>

<p>
 <strong>Code Example 8-2 - Setting up an attribute structure</strong>
</p>

<pre class="code example">...
LDAPMod attribute1;
char *sn_values[] = { "Jensen", NULL };
...
attribute1.mod_op = 0;
attribute1.mod_type = "sn";
attribute1.mod_values = sn_values;
...</pre>

<p>Note that because you are specifying an attribute for a new entry 
(rather than for an existing entry), you can set the 
<code>mod_op</code> field to <code>0</code>. (For an existing entry, 
the <code>mod_op</code> field identifies the type of change you are 
making to the entry.)</p>

<h4 id="specify-multi-value-attribute">Specifying Multiple Values in an Attribute</h4>

<p>If an attribute has more than one value, specify the values in 
the <code>mod_values</code> array. This example specifies two values 
for the <code>cn</code> attribute:</p>

<p>
 <strong>Code Example 8-3 - Specifying multiple values in an attribute</strong>
</p>

<pre class="code example">...
LDAPMod attribute2, attribute3;
char *cn_values[] = { "Barbara Jensen", "Babs Jensen", NULL };
char *objectClass_values[] = { "top", "person", 
  "organizationalPerson", "inetOrgPerson", NULL };
...
attribute2.mod_op = 0;
attribute2.mod_type = "cn";
attribute2.mod_values = cn_values;
attribute3.mod_op = 0;
attribute3.mod_type = "objectClass";
attribute3.mod_values = objectClass_values;
...</pre>

<h4 id="specify-binary-data-value-attribute">Specifying Binary Data as the Values of an Attribute</h4>

<p>If the attribute contains binary data (rather than string values), 
specify the data in a 
<code><a href="datatype.htm#berval">berval</a></code> structure:</p>

<pre>struct berval {
  unsigned long bv_len;
  char *bv_val;
}</pre>

<p><strong>Table 8-2 - berval field descriptions</strong></p>

<table class="data">
 <tr>
  <td><code>bv_len</code></td>
  <td>The length of the data. 
  </td>
 </tr>
 <tr>
  <td><code>bv_val</code></td>
  <td>A pointer to the binary data. 
  </td>
 </tr>
</table>

<p>After creating the <code>berval</code> structures for the binary 
data, you need to do the following:</p>

<ul>
 <li>
  Add the <code>berval</code> structures to the 
  <code>mod_bvalues</code> field in the 
  <code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structure.
 <li>
  Use the bitwise OR operator ( | ) to combine the value of the 
  <code>mod_op</code> field with <code>LDAP_MOD_BVALUES</code>. 
  (When adding a new entry, you can just set the <code>mod_op</code> 
  field to <code>LDAP_MOD_BVALUES</code>, since the 
  <code>mod_op</code> field is 0 in this case.)
</ul>

<p>For example, suppose the file <code>my_photo.jpg</code> contains 
a JPEG photograph of Barbara Jensen. The following example sets the 
<code>jpegPhoto</code> attribute to the JPEG data of the photograph.</p>

<p>
 <strong>Code Example 8-4 - Adding a value to an attribute</strong>
</p>

<pre class="code example">#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include "ldap.h"
...
char *photo_data;
FILE *fp;
struct stat st;
LDAPMod attribute4;
struct berval photo_berval;
struct berval *jpegPhoto_values[2];
/* Get information about the JPEG file, including its size. */
if ( stat( "my_photo.jpg", &amp;st ) != 0 ) {
  perror( "stat" );
  return( 1 );
}

/* Open the JPEG file and read it into memory. */
if ( ( fp = fopen( "my_photo.jpg", "rb" ) ) == NULL ) {
  perror( "fopen" );
  return( 1 );
}
if ( ( ( photo_data = ( char * )malloc( st.st_size ) ) == NULL ) || 
      ( fread ( photo_data, st.st_size, 1, fp ) != 1 ) ) {
  perror( photo_data ? "fread" : "malloc" );
  return( 1 );
}

fclose( fp );

attribute4.mod_op = LDAP_MOD_BVALUES;
attribute4.mod_type = "jpegPhoto";
photo_berval.bv_len = st.st_size;
photo_berval.bv_val = photo_data;
jpegPhoto_values[0] = &amp;photo_berval;
jpegPhoto_values[1] = NULL;
attribute4.mod_values = jpegPhoto_values;</pre>

<h4 id="specify-attribute-entry">Specifying the Attributes in the Entry</h4>

<p>After specifying the values of attributes in 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures, 
you need to construct an array of these structures. (You will pass a 
pointer to this array as a parameter to the LDAP API function for 
creating a new entry.) 

<p><strong>Note:</strong>Make sure that you created 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures for 
all required attributes in the new entry. For information on which 
attributes are required, see the documentation for your LDAP server.</p>

<p>The following section of code creates an array of 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures:</p>

<p>
 <strong>Code Example 8-5 - Adding an array of structures to an attribute</strong>
</p>

<pre class="code example">LDAPMod *list_of_mods[5]
LDAPMod attribute1, attribute2, attribute3, attribute4;
...
/* Code for filling the LDAPMod structures with values */
...
list_of_mods[0] = &amp;attribute1;
list_of_mods[1] = &amp;attribute2;
list_of_mods[2] = &amp;attribute3;
list_of_mods[3] = &amp;attribute4;
list_of_mods[4] = NULL;
...</pre>

<h3 id="add-entry-directory">Adding the Entry to the Directory</h3>

<p>To add the entry to the directory, call one of the following functions:</p>

<ul>
 <li>
  The synchronous 
  <code><a href="function.htm#add-ext-s">ldap_add_ext_s()</a></code> 
  function (see<a href="addmod.htm#perform-sync-add">"Performing a 
  Synchronous Add Operation"</a>).
 <li>
  The asynchronous 
  <code><a href="function.htm#add-ext">ldap_add_ext()</a></code> 
  function (see<a href="addmod.htm#perform-async-add">"Performing an 
  Asynchronous Add Operation"</a>).
</ul>

<p>(For more information about the difference between synchronous 
and asynchronous functions, see <a href="using.htm#call_sync_async_function">"Calling 
Synchronous and Asynchronous Functions."</a>)</p>

<p>If you've allocated 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures 
yourself, you should free the structures when you are done. Call the 
<code><a href="function.htm#mods-free">ldap_mods_free()</a></code> 
function to free 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures.</p>

<p><strong>Note:</strong>Before you add an entry, you should make 
sure that you've defined all required attributes for the entry type. 
For a listing of the required attributes for the different types of 
entries, see the documentation for your LDAP server.</p>

<h4 id="perform-sync-add">Performing a Synchronous Add Operation</h4>

<p>If you want to wait for the results of the add operation to 
complete before continuing, call the synchronous 
<code><a href="function.htm#add-ext-s">ldap_add_ext_s()</a></code> 
function. This function sends an LDAP add request to the server and 
blocks until the server sends the results of the operation back to 
your client.</p>

<p>The <code>ldap_add_ext_s()</code> function returns 
<code>LDAP_SUCCESS</code> if the operation completed successfully or 
an error code if a problem occurred. See the documentation on the 
<code><a href="function.htm#add-ext-s">ldap_add_ext_s()</a></code> 
function for a list of the possible result codes.</p>

<p>The following section of code uses the synchronous 
<code>ldap_add_ext_s()</code> function to add the user <code>William 
Jensen</code> to the directory.</p>

<p>
 <strong>Code Example 8-6 - Synchronously adding an entry to the 
 directory database</strong>
</p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"
...
#define NEW_DN "uid=wbjensen,ou=People,dc=example,dc=com"
...
LDAP         *ld;
LDAPMod      **mods;
char         *matched_msg = NULL, *error_msg = NULL;
int         rc;
...
/* Perform the add operation. */
rc = ldap_add_ext_s( ld, NEW_DN, mods, NULL, NULL );
if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_add_ext_s: %s\n", ldap_err2string( rc ) );
  ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
  if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
    fprintf( stderr, "%s\n", error_msg );
  }
  if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
    fprintf( stderr, 
      "Part of the DN that matches an existing entry: %s\n", 
      matched_msg );
  }
} else {
  printf( "%s added successfully.\n", NEW_DN );
}
...</pre>

<h4 id="perform-async-add">Performing an Asynchronous Add Operation</h4>

<p>If you want to perform other work (in parallel) while waiting for 
the entry to be added, call the asynchronous 
<code><a href="function.htm#add-ext">ldap_add_ext()</a></code> 
function. This function sends an LDAP add request to the server and 
returns an <code>LDAP_SUCCESS</code> result code if the request was 
successfully sent (or an LDAP result code if an error occurred).</p>

<p>The <code>ldap_add_ext()</code> function passes back a message ID 
identifying the add operation. To determine whether the server sent 
a response for this operation to your client, call the 
<code><a href="function.htm#result">ldap_result()</a></code> function 
and pass in this message ID. The <code>ldap_result()</code> function 
uses the message ID to determine if the server sent the results of 
the add operation. The function passes back the results in an 
<code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> structure.</p>

<p>You can call the 
<code><a href="function.htm#parse-result">ldap_parse_result()</a></code> 
function to parse the 
<code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> structure 
to determine if the operation was successful. For a list of possible 
result codes for an LDAP add operation, see the result code 
documentation for the 
<code><a href="function.htm#add-ext-s">ldap_add_ext_s()</a></code> 
function.</p>

<p>The following section of code calls <code>ldap_add_ext()</code> 
to add the user <code>William Jensen</code> to the directory.</p>

<p>
 <strong>Code Example 8-7 - Performing an asynchronous add operation</strong>
</p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"
...
#define NEW_DN "uid=wbjensen,ou=People,dc=example,dc=com"

...
LDAP           *ld;
LDAPMessage    *res;
LDAPControl    **serverctrls;
char           *matched_msg = NULL, *error_msg = NULL;
char           **referrals;
int            i, rc, parse_rc, msgid, finished = 0;

/* Timeout period for the ldap_result() function to wait for results. */
struct timeval  zerotime;
zerotime.tv_sec = zerotime.tv_usec = 0L;
...
/* Send the LDAP add request. */
rc = ldap_add_ext( ld, NEW_DN, mods, NULL, NULL, &amp;msgid );
if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_add_ext: %s\n", ldap_err2string( rc ) );
  ldap_unbind( ld );
  return( 1 );
}
...
/* Poll the server for the results of the add operation. */
while ( !finished ) {
  rc = ldap_result( ld, msgid, 0, &amp;zerotime, &amp;res );
  switch ( rc ) {
  case -1:
    /* An error occurred. */
    rc = ldap_get_lderrno( ld, NULL, NULL );
    fprintf( stderr, "ldap_result: %s\n", ldap_err2string( rc ) );
    ldap_unbind( ld );
    return( 1 );
  case 0:
    /* The timeout period specified by zerotime was exceeded, 
      so call ldap_result() again and continue polling. */
    break;
  default:
    /* The function has retrieved the results of the add operation. */
    finished = 1;

    /* Parse the result to determine the result of 
      the add operation. */
    parse_rc = ldap_parse_result( ld, res, &amp;rc, &amp;matched_msg, 
      &amp;error_msg, &amp;referrals, &amp;serverctrls, 1 );
    if ( parse_rc != LDAP_SUCCESS ) {
      fprintf( stderr, "ldap_parse_result: %s\n", 
        ldap_err2string( parse_rc ) );
      ldap_unbind( ld );
      return( 1 );
    }

    /* Check the results of the LDAP add operation. */
    if ( rc != LDAP_SUCCESS ) {
      fprintf( stderr, "ldap_add_ext: %s\n", ldap_err2string( rc ) );
      if ( error_msg != NULL &amp; *error_msg != '\0' ) {
        fprintf( stderr, "%s\n", error_msg );
      }
      if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
        fprintf( stderr, 
          "Part of the DN that matches an existing entry: %s\n", 
          matched_msg );
      }
    } else {
      printf( "%s added successfully.\n", NEW_DN );
    }
  }
}
...</pre>

<h3 id="example-add-entry-directory-sync">Example: Adding an Entry to the Directory (Synchronous)</h3>

<p>The following sample program calls the synchronous 
<code><a href="function.htm#add-ext-s">ldap_add_ext_s()</a></code> 
function to add a new user to the directory.</p>

<p><strong>Code Example 8-8 - Synchronous add</strong></p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"
/* Change these as needed. */
#define HOSTNAME "localhost"
#define PORTNUMBER LDAP_PORT
#define BIND_DN "cn=Directory Manager"
#define BIND_PW "23skidoo"
#define NEW_DN "uid=wbjensen,ou=People,dc=example,dc=com"
#define  NUM_MODS 5
int
main( int argc, char **argv )
{
  LDAP           *ld;
  LDAPMod        **mods;
  char           *matched_msg = NULL, *error_msg = NULL;
  int          i, rc;
  char *object_vals[] = { "top", "person", "organizationalPerson", 
    "inetOrgPerson", NULL };

char *cn_vals[] = { "William B Jensen", "William Jensen", "Bill Jensen", 
    NULL };
  char *sn_vals[] = { "Jensen", NULL };
  char *givenname_vals[] = { "William", "Bill", NULL };
  char *telephonenumber_vals[] = { "+1 415 555 1212", NULL };
  /* Get a handle to an LDAP connection. */
  if ( (ld = ldap_init( HOSTNAME, PORTNUMBER )) == NULL ) {
    perror( "ldap_init" );
    return( 1 );
  }
  /* Bind to the server as the Directory Manager. */
  rc = ldap_simple_bind_s( ld, BIND_DN, BIND_PW );
  if ( rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_simple_bind_s: %s\n", ldap_err2string( rc ) );
    ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
    if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
      fprintf( stderr, "%s\n", error_msg );
    }
    if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
      fprintf( stderr, 
        "Part of the DN that matches an existing entry: %s\n", 
        matched_msg );
    }
    ldap_unbind_s( ld );
    return( 1 );
  }
  /* Construct the array of LDAPMod structures representing the attributes 
    of the new entry. */
  mods = ( LDAPMod ** ) malloc(( NUM_MODS + 1 ) * sizeof( LDAPMod * ));
  if ( mods == NULL ) {
    fprintf( stderr, "Cannot allocate memory for mods array\n" );
    exit( 1 );
  }
  for ( i = 0; i &lt; NUM_MODS; i++ ) {
    if (( mods[ i ] = ( LDAPMod * ) malloc( sizeof( LDAPMod ))) == NULL ) {
      fprintf( stderr, "Cannot allocate memory for mods element\n" );
      exit( 1 );
    }
  }
  mods[ 0 ]-&gt;mod_op = 0;
  mods[ 0 ]-&gt;mod_type = "objectclass";
  mods[ 0 ]-&gt;mod_values = object_vals;
  mods[ 1 ]-&gt;mod_op = 0;
  mods[ 1 ]-&gt;mod_type = "cn";
  mods[ 1 ]-&gt;mod_values = cn_vals;
  mods[ 2 ]-&gt;mod_op = 0;
  mods[ 2 ]-&gt;mod_type = "sn";
  mods[ 2 ]-&gt;mod_values = sn_vals;
  mods[ 3 ]-&gt;mod_op = 0;
  mods[ 3 ]-&gt;mod_type = "givenname";
  mods[ 3 ]-&gt;mod_values = givenname_vals;
  mods[ 4 ]-&gt;mod_op = 0;
  mods[ 4 ]-&gt;mod_type = "telephonenumber";
  mods[ 4 ]-&gt;mod_values = telephonenumber_vals;
  mods[ 5 ] = NULL;
  /* Perform the add operation. */
  rc = ldap_add_ext_s( ld, NEW_DN, mods, NULL, NULL );
  if ( rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_add_ext_s: %s\n", ldap_err2string( rc ) );
    ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
    if ( error_msg != NULL &amp; *error_msg != '\0' ) {
      fprintf( stderr, "%s\n", error_msg );
    }
    if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
      fprintf( stderr, 
        "Part of the DN that matches an existing entry: %s\n", 
        matched_msg );
    }
  } else {
    printf( "%s added successfully.\n", NEW_DN );
  }
  ldap_unbind_s( ld );
  for ( i = 0; i &lt; NUM_MODS; i++ ) {
    free( mods[ i ] );
  }
  free( mods );
  return 0;
}</pre>

<h3 id="example-add-entry-directory-async">Example: Adding an Entry to the Directory (Asynchronous)</h3>

<p>The following sample program calls the asynchronous 
<code><a href="function.htm#add-ext">ldap_add_ext()</a></code> 
function to add a new user to the directory.</p>

<p><strong>Code Example 8-9 - Asynchronous add</strong></p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"
void do_other_work();
int global_counter = 0;
void free_mods( LDAPMod **mods );
/* Change these as needed. */
#define HOSTNAME "localhost"
#define PORTNUMBER LDAP_PORT
#define BIND_DN "cn=Directory Manager"
#define BIND_PW "23skidoo"
#define NEW_DN "uid=wbjensen,ou=People,dc=example,dc=com"
#define  NUM_MODS 5
int
main( int argc, char **argv )
{
  LDAP      *ld;
  LDAPMessage    *res;
  LDAPMod      **mods;
  LDAPControl    **serverctrls;
  char           *matched_msg = NULL, *error_msg = NULL;
  char           **referrals;
  int        i, rc, parse_rc, msgid, finished = 0;
  struct timeval  zerotime;
  char *object_vals[] = { "top", "person", "organizationalPerson", "inetOrgPerson", NULL };
  char *cn_vals[] = { "William B Jensen", "William Jensen", "Bill Jensen", NULL };
  char *sn_vals[] = { "Jensen", NULL };
  char *givenname_vals[] = { "William", "Bill", NULL };
  char *telephonenumber_vals[] = { "+1 415 555 1212", NULL };
  zerotime.tv_sec = zerotime.tv_usec = 0L;
  /* Get a handle to an LDAP connection. */
  if ( (ld = ldap_init( HOSTNAME, PORTNUMBER )) == NULL ) {
    perror( "ldap_init" );
    return( 1 );
  }
  /* Bind to the server as the Directory Manager. */
  rc = ldap_simple_bind_s( ld, BIND_DN, BIND_PW );
  if ( rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_simple_bind_s: %s\n", ldap_err2string( rc ) );
    ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
    if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
      fprintf( stderr, "%s\n", error_msg );
    }
    if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
      fprintf( stderr, 
        "Part of the DN that matches an existing entry: %s\n",
        matched_msg );
    }
    ldap_unbind_s( ld );
    return( 1 );
  }
  /* Construct the array of LDAPMod structures representing the attributes 
    of the new entry. */
  mods = ( LDAPMod ** ) malloc(( NUM_MODS + 1 ) * sizeof( LDAPMod * ));
  if ( mods == NULL ) {
    fprintf( stderr, "Cannot allocate memory for mods array\n" );
    exit( 1 );
  }
  for ( i = 0; i &lt; NUM_MODS; i++ ) {
    if (( mods[ i ] = ( LDAPMod * ) malloc( sizeof( LDAPMod ))) == NULL ) {
      fprintf( stderr, "Cannot allocate memory for mods element\n" );
      exit( 1 );
    }
  }
  mods[ 0 ]-&gt;mod_op = 0;
  mods[ 0 ]-&gt;mod_type = "objectclass";
  mods[ 0 ]-&gt;mod_values = object_vals;
  mods[ 1 ]-&gt;mod_op = 0;
  mods[ 1 ]-&gt;mod_type = "cn";
  mods[ 1 ]-&gt;mod_values = cn_vals;
  mods[ 2 ]-&gt;mod_op = 0;
  mods[ 2 ]-&gt;mod_type = "sn";
  mods[ 2 ]-&gt;mod_values = sn_vals;
  mods[ 3 ]-&gt;mod_op = 0;
  mods[ 3 ]-&gt;mod_type = "givenname";
  mods[ 3 ]-&gt;mod_values = givenname_vals;
  mods[ 4 ]-&gt;mod_op = 0;
  mods[ 4 ]-&gt;mod_type = "telephonenumber";
  mods[ 4 ]-&gt;mod_values = telephonenumber_vals;
  mods[ 5 ] = NULL;
  /* Send the LDAP add request. */
  rc = ldap_add_ext( ld, NEW_DN, mods, NULL, NULL, &amp;msgid );
  if ( rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_add_ext: %s\n", ldap_err2string( rc ) );
    ldap_unbind( ld );
    free_mods( mods );
    return( 1 );
  }
  /* Poll the server for the results of the add operation. */
  while ( !finished ) {
    rc = ldap_result( ld, msgid, 0, &amp;zerotime, &amp;res );
    switch ( rc ) {
    case -1:
      /* An error occurred. */
      rc = ldap_get_lderrno( ld, NULL, NULL );
      fprintf( stderr, "ldap_result: %s\n", ldap_err2string( rc ) );
      ldap_unbind( ld );
      free_mods( mods );
      return( 1 );
    case 0:
      /* The timeout period specified by zerotime was exceeded.
        This means that the server has still not yet sent the 
        results of the add operation back to your client.
        Break out of this switch statement, and continue calling 
        ldap_result() to poll for results. */
      break;
    default:
      /* The function has retrieved the results of the add operation
        from the server. */
      finished = 1;
      /* Parse the results received from the server. Note the last
        argument is a non-zero value, which indicates that the 
        LDAPMessage structure will be freed when done. (No need
        to call ldap_msgfree().) */
      parse_rc = ldap_parse_result( ld, res, &amp;rc, &amp;matched_msg, &amp;error_msg, &amp;referrals, &amp;serverctrls, 1 );
      if ( parse_rc != LDAP_SUCCESS ) {
        fprintf( stderr, "ldap_parse_result: %s\n", ldap_err2string( parse_rc ) );
        ldap_unbind( ld );
        free_mods( mods );
        return( 1 );
      }
      /* Check the results of the LDAP add operation. */
      if ( rc != LDAP_SUCCESS ) {
        fprintf( stderr, "ldap_add_ext: %s\n", ldap_err2string( rc ) );
        if ( error_msg != NULL &amp; *error_msg != '\0' ) {
          fprintf( stderr, "%s\n", error_msg );
        }
        if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
          fprintf( stderr, 
            "Part of the DN that matches an existing entry: %s\n", 
            matched_msg );
        }
      } else {
        printf( "%s added successfully.\n"
          "Counted to %d while waiting for the add operation.\n",
          NEW_DN, global_counter );
      }
    }
    /* Do other work while waiting for the results of the add operation. */
    if ( !finished ) {
      do_other_work();
    }
  }
  ldap_unbind( ld );
  free_mods( mods );
  return 0;
}
/*
 * Free a mods array.
 */
void
free_mods( LDAPMod **mods )
{
  int i;
  for ( i = 0; i &lt; NUM_MODS; i++ ) {
  free( mods[ i ] );
  }
  free( mods );
}
  
/*
 * Perform other work while polling for results. This doesn't do anything
 * useful, but it could.
 */
void
do_other_work()
{
  global_counter++;
}</pre>

<h3 id="modify-entry">Modifying an Entry</h3>

<p>To modify an entry:</p>

<ol>
 <li>
  Create an array of 
  <code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures 
  representing the changes that need to be made. Use the 
  <code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structure to 
  specify a change to an attribute.
 <li>
  Call the 
  <code><a href="function.htm#modify-ext">ldap_modify_ext()</a></code> or 
  <code><a href="function.htm#modify-ext-s">ldap_modify_ext_s()</a></code>, 
  passing in the array of 
  <code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures 
  and a distinguished name of the entry that you want modified.
</ol>

<p>After you are done, call the 
<code><a href="function.htm#mods-free">ldap_mods_free()</a></code> 
function to free any 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures 
you've allocated.</p>

<h3 id="specify-changes">Specifying the Changes</h3>

<p>This section describes the process of specifying changes to an entry.</p>

<ul>
 <li><a href="addmod.htm#replace-value-attribute">Replacing the Values of an Attribute</a>
 <li><a href="addmod.htm#remove-value-attribute">Removing Values from an Attribute</a>
 <li><a href="addmod.htm#add-value-attribute">Adding Values to an Attribute</a>
 <li><a href="addmod.htm#remove-attribute">Removing an Attribute</a>
 <li><a href="addmod.htm#add-attribute">Adding an Attribute</a>
 <li><a href="addmod.htm#assemble-list-changes">Assembling the List of Changes</a>
</ul>

<h4 id="replace-value-attribute">Replacing the Values of an Attribute</h4>

<p>To replace all existing values of an attribute, create an 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structure with 
the following:</p>

<ul>
 <li>
  Set the <code>mod_type</code> field to the attribute type that you 
  want to change (for example, "<code>telephoneNumber</code>").
 <li>
  Set the <code>mod_values</code> field to the new values of the 
  attribute.
 <li>
  Set the value of the <code>mod_op</code> field to 
  <code>LDAP_MOD_REPLACE</code>.
</ul>

<p>If you want to specify binary data as 
<a href="datatype.htm#berval">berval</a> structures (as opposed to 
string values), you need to do the following:</p>

<ul>
 <li>
  Instead of using the <code>mod_values</code> field, use the 
  <code>mod_bvalues</code> field.
 <li>Use the bitwise OR operator ( | ) to combine the value 
 <code>LDAP_MOD_BVALUES</code> with the value of the 
 <code>mod_op</code> field.
</ul>

<p>Note the following:</p>

<ul>
 <li>
  If you specify an attribute that does not exist in the entry, the 
  attribute will be added to the entry.
 <li>
  If you set a <code>NULL</code> value for the attribute (either by 
  setting the <code>mod_values</code> field to <code>NULL</code>, or 
  by setting the <code>mod_bvalues</code> field to <code>NULL</code> 
  when the <code>mod_op</code> field contains 
  <code>LDAP_MOD_BVALUES</code>), the attribute will be removed from 
  the entry.
</ul>

<p>The following section of code specifies a change that replaces 
the values of the <code>telephoneNumber</code> attribute.</p>

<p>
 <strong>Code Example 8-10 - Modifying attribute values</strong>
</p>

<pre class="code example">LDAPMod attribute1;
char *telephoneNumber_values[] = { "+1 650 555 1967", NULL };
attribute1.mod_type = "telephoneNumber";
attribute1.mod_op = LDAP_MOD_REPLACE;
attribute1.mod_values = telephoneNumber_values;</pre>

<h4 id="remove-value-attribute">Removing Values from an Attribute</h4>

<p>To remove values from an attribute, create an 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structure with 
the following:</p>

<ul>
 <li>
  Set the <code>mod_type</code> field to the attribute type 
  containing the values that you want to remove (for example, 
  "<code>facsimileTelephoneNumber</code>").
 <li>
  Set the <code>mod_values</code> field to the values that you want 
  removed from the attribute.
 <li>
  Set the value of the <code>mod_op</code> field to 
  <code>LDAP_MOD_DELETE</code>.
</ul>

<p>If you want to specify binary data as 
<a href="datatype.htm#berval">berval</a> structures (as opposed to 
string values), you need to do the following:</p>

<ul>
 <li>
  Instead of using the <code>mod_values</code> field, use the 
  <code>mod_bvalues</code> field.
 <li>
  Use the bitwise OR operator ( | ) to combine the value 
  <code>LDAP_MOD_BVALUES</code> with the value of the 
  <code>mod_op</code> field.
</ul>

<p>Note the following:</p>

<ul>
 <li>
  If you remove all values from the attribute, the attribute will be 
  removed from the entry.
 <li>
  If you set a <code>NULL</code> value for the attribute (either by 
  setting the <code>mod_values</code> field to <code>NULL</code>, or 
  by setting the <code>mod_bvalues</code> field to <code>NULL</code> 
  when the <code>mod_op</code> field contains 
  <code>LDAP_MOD_BVALUES</code>), the attribute will be removed from 
  the entry.
</ul>

<p>The following example specifies the removal of one of the values 
of the <code>facsimileTelephoneNumber</code> attribute in the entry:</p>

<p>
 <strong>Code Example 8-11 - Removing an attribute value</strong>
</p>

<pre class="code example">LDAPMod attribute2;
char *fax_values[] = { "+1 650 555 1967", NULL };
attribute2.mod_type = "facsimileTelephoneNumber";
attribute2.mod_op = LDAP_MOD_DELETE;
attribute2.mod_values = fax_values;
...</pre>

<h4 id="add-value-attribute">Adding Values to an Attribute</h4>

<p>To add values to an attribute to an entry, create an 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structure 
with the following:</p>

<ul>
 <li>
  Set the <code>mod_type</code> field to the attribute type that you 
  want to add values to (for example, "audio").
 <li>
  Set the <code>mod_values</code> field to the new values of the 
  attribute.
 <li>
  Set the value of the <code>mod_op</code> field to 
  <code>LDAP_MOD_ADD</code>.
</ul>

<p>If the attribute contains binary data (as opposed to string 
values), you need to do the following:</p>

<ul>
 <li>
  Instead of using the <code>mod_values</code> field, use the 
  <code>mod_bvalues</code> field. Make sure to put the values in 
  <code><a href="datatype.htm#berval">berval</a></code> structures.
 <li>
  Use the bitwise OR operator ( | ) to combine the value 
  <code>LDAP_MOD_BVALUES</code> with the value of the 
  <code>mod_op</code> field.
</ul>

<p>Note that if the attribute does not already exist in the entry, 
the attribute will be added to the entry.</p>

<p>The following example adds values to the <code>audio</code> 
attribute to an entry:</p>

<p>
 <strong>Code Example 8-12 - Adding values to an attribute</strong>
</p>

<pre class="code example">#include &lt;sys/stat.h&gt;
#include "ldap.h"
...
char *audio_data;
FILE *fp;
struct stat st;
LDAPMod attribute3;
struct berval audio_berval;
struct berval *audio_values[2];
...
/* Get information about the audio file, including its size. */
if ( stat( "my_sounds.au", &amp;st ) != 0 ) {
  perror( "stat" );
  return( 1 );
}

/* Open the audio file and read it into memory. */
if ( ( fp = fopen( "my_sounds.au", "rb" ) ) == NULL ) {
  perror( "fopen" );
  return( 1 );
}

if ( ( ( audio_data = ( char * )malloc( st.st_size ) ) == NULL ) || 
      ( fread ( audio_data, st.st_size, 1, fp ) != 1 ) ) {
  perror( audio_data ? "fread" : "malloc" );
  return( 1 );
}

fclose( fp );
attribute3.mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
attribute3.mod_type = "audio";
audio_berval.bv_len = st.st_size;
audio_berval.bv_val = audio_data;
audio_values[0] = &amp;audio_berval;
audio_values[1] = NULL;
attribute3.mod_values = audio_values;
...</pre>

<h4 id="remove-attribute">Removing an Attribute</h4>

<p>You can remove an attribute from an entry in one of the following ways:</p>

<ul>
 <li>Remove all values from the attribute.
 <li>
  Set the <code>mod_op</code> field to <code>LDAP_MOD_REPLACE</code> 
  or <code>LDAP_MOD_DELETE</code> and specify <code>NULL</code> for 
  the <code>mod_values</code> field.
</ul>

<h4 id="add-attribute">Adding an Attribute</h4>

<p>If you add or replace values in an attribute that does not yet 
exist in the entry, the attribute will be added to the entry.</p>

<h4 id="assemble-list-changes">Assembling the List of Changes</h4>

<p>After specifying the changes to attribute values in 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures, 
you need to construct an array of these structures. (You will pass a 
pointer to this array as a parameter to the LDAP API function for 
modifying the entry.)</p>

<p>The following section of code creates an array of 
<code><a href="datatype.htm#LDAPMod">LDAPMod</a></code> structures:</p>

<p>
 <strong>Code Example 8-13 - Assembling a list of changes</strong>
</p>

<pre class="code example">...
LDAPMod *list_of_mods[4]
LDAPMod attribute1, attribute2, attribute3;
...
/* Code for filling the LDAPMod structures with values */
...
list_of_mods[0] = &amp;attribute1;
list_of_mods[1] = &amp;attribute2;
list_of_mods[2] = &amp;attribute3;
list_of_mods[3] = NULL;
...</pre>

<h3 id="modify-entry-directory">Modifying the Entry in the Directory</h3>

<p>To modify the entry in the directory, call one of the following functions:</p>

<ul>
 <li>
  The synchronous 
  <code><a href="function.htm#modify-ext-s">ldap_modify_ext_s()</a></code> 
  function (see<a href="addmod.htm#perform-sync-modify">"Performing a 
  Synchronous Modify Operation"</a>).
 <li>
  The asynchronous 
  <code><a href="function.htm#modify-ext">ldap_modify_ext()</a></code> 
  function (see<a href="addmod.htm#perform-async-modify">"Performing an 
  Asynchronous Modify Operation</a>").
</ul>

<p>For more information about the difference between synchronous and 
asynchronous functions, see <a href="using.htm#call_sync_async_function">"Calling 
Synchronous and Asynchronous Functions."</a></p>

<h4 id="perform-sync-modify">Performing a Synchronous Modify Operation</h4>

<p>If you want to wait for the results of the modify operation to 
complete before continuing, call the synchronous 
<code><a href="function.htm#modify-ext-s">ldap_modify_ext_s()</a></code> 
function. This function sends an LDAP modify request to the server 
and blocks until the server sends the results of the operation back 
to your client.</p>

<p>The <code>ldap_modify_ext_s()</code> function returns 
<code>LDAP_SUCCESS</code> if the operation completed successfully or 
an error code if a problem occurred. See the documentation on the 
<code><a href="function.htm#modify-ext-s">ldap_modify_ext_s()</a></code> 
function for a list of the possible result codes.</p>

<p>The following section of code uses the synchronous 
<code>ldap_add_ext_s()</code> function to modify the entry for the 
user <code>William Jensen</code> in the directory.</p>

<p>
 <strong>Code Example 8-14 - Performing a synchronous modify operation</strong>
</p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"

#define MODIFY_DN "uid=wbjensen,ou=People,dc=example,dc=com"
...
LDAP      *ld;
LDAPMod   *mods[ 3 ];
char      *matched_msg = NULL, *error_msg = NULL;
int        rc;
...
/* Perform the modify operation. */
rc = ldap_modify_ext_s( ld, MODIFY_DN, mods, NULL, NULL );
if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_modify_ext_s: %s\n", ldap_err2string( rc ) );
  ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
  if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
    fprintf( stderr, "%s\n", error_msg );
  }
  if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
    fprintf( stderr, 
      "Part of the DN that matches an existing entry: %s\n", 
      matched_msg );
  }
} else {
  printf( "%s modified successfully.\n", MODIFY_DN );
}
ldap_unbind_s( ld );
...</pre>

<h4 id="perform-async-modify">Performing an Asynchronous Modify Operation</h4>

<p>If you want to perform other work (in parallel) while waiting for 
the entry to be modified, call the asynchronous 
<code><a href="function.htm#modify-ext">ldap_modify_ext()</a></code> 
function. This function sends an LDAP modify request to the server 
and returns an <code>LDAP_SUCCESS</code> result code if the request 
was successfully sent or it sends an LDAP result code if an error occurred.</p>

<p>The <code>ldap_modify_ext()</code> function passes back a message 
ID identifying the modify operation. To determine whether the server 
sent a response for this operation to your client, call the 
<code><a href="function.htm#result">ldap_result()</a></code> function 
and pass in this message ID. The <code>ldap_result()</code> function 
uses the message ID to determine if the server sent the results of 
the modify operation. The function passes back the results in an 
<code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> structure.</p>

<p>You can call the 
<code><a href="function.htm#parse-result">ldap_parse_result()</a></code> 
function to parse the 
<code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> structure 
to determine if the operation was successful. For a list of possible 
result codes for an LDAP modify operation, see the result code 
documentation for the 
<code><a href="function.htm#modify-ext-s">ldap_modify_ext_s()</a></code> 
function.</p>

<p>The following section of code calls <code>ldap_modify_ext()</code> 
to modify the entry for the user <code>William Jensen</code> in the 
directory.</p>

<p>
 <strong>Code Example 8-15 - Performing an asynchronous modify operation</strong>
</p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"
...
#define MODIFY_DN "uid=wbjensen,ou=People,dc=example,dc=com"
...
LDAP      *ld;
LDAPMessage    *res;
LDAPMod      *mods[ 3 ];
LDAPControl    **serverctrls;
char      *matched_msg = NULL, *error_msg = NULL;
char      **referrals;
int        rc, parse_rc, msgid, finished = 0;

/* Timeout period for the ldap_result() function to wait for results. */
struct timeval  zerotime;
zerotime.tv_sec = zerotime.tv_usec = 0L;
...
/* Send the LDAP modify request. */
rc = ldap_modify_ext( ld, MODIFY_DN, mods, NULL, NULL, &amp;msgid );
if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_modify_ext: %s\n", ldap_err2string( rc ) );
  ldap_unbind( ld );
  return( 1 );
}

/* Poll the server for the results of the modify operation. */
while ( !finished ) {
  rc = ldap_result( ld, msgid, 0, &amp;zerotime, &amp;res );
  switch ( rc ) {
  case -1:
    /* An error occurred. */
      rc = ldap_get_lderrno( ld, NULL, NULL );
      fprintf( stderr, "ldap_result: %s\n", ldap_err2string( rc ) );
      ldap_unbind( ld );
      return( 1 );
  case 0:
    /* The timeout period specified by zerotime was exceeded, 
      so call ldap_result() again and continue polling. */
    break;
  default:
    /* The function has retrieved the results of the 
      modify operation. */
    finished = 1;

    /* Parse the results received from the server. */
    parse_rc = ldap_parse_result( ld, res, &amp;rc, &amp;matched_msg, 
      &amp;error_msg, &amp;referrals, &amp;serverctrls, 1 );
    if ( parse_rc != LDAP_SUCCESS ) {
      fprintf( stderr, "ldap_parse_result: %s\n", 
        ldap_err2string( parse_rc ) );
      ldap_unbind( ld );
      return( 1 );
    }

    /* Check the results of the LDAP modify operation. */
    if ( rc != LDAP_SUCCESS ) {
      fprintf( stderr, "ldap_modify_ext: %s\n", 
        ldap_err2string( rc ) );
      if ( error_msg != NULL &amp; *error_msg != '\0' ) {
        fprintf( stderr, "%s\n", error_msg );
      }
      if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
        fprintf( stderr, 
        "Part of the DN that matches an existing entry: %s\n", 
        matched_msg );
      }
    } else {
      printf( "%s modified successfully.\n", MODIFY_DN );
    }
  }
}
ldap_unbind( ld );
...</pre>

<h3 id="example-modify-entry-directory-sync">Example: Modifying an Entry in the Directory (Synchronous)</h3>

<p>The following sample program calls the synchronous 
<code><a href="function.htm#modify-ext-s">ldap_modify_ext_s()</a></code> 
function to modify a user's entry in the directory. The program 
replaces the values of the mail attribute of the entry and adds a 
description attribute to the entry.</p>

<p><strong>Code Example 8-16 - Synchronous modify</strong></p>

<pre class="code example">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include "ldap.h"
/* Change these as needed. */
#define HOSTNAME "localhost"
#define PORTNUMBER LDAP_PORT
#define BIND_DN "cn=Directory Manager"
#define BIND_PW "23skidoo"
#define MODIFY_DN "uid=wbjensen,ou=People,dc=example,dc=com"
int
main( int argc, char **argv )
{
  LDAP         *ld;
  LDAPMod      mod0, mod1;
  LDAPMod      *mods[ 3 ];
  char         *matched_msg = NULL, *error_msg = NULL;
  char         *vals0[ 2 ], *vals1[ 2 ];
  time_t       now;
  char         buf[ 128 ];
  int          rc;
/* Get a handle to an LDAP connection. */
  if ( (ld = ldap_init( HOSTNAME, PORTNUMBER )) == NULL ) {
    perror( "ldap_init" );
    return( 1 );
  }
/* Bind to the server as the Directory Manager. */
  rc = ldap_simple_bind_s( ld, BIND_DN, BIND_PW );
  if ( rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_simple_bind_s: %s\n", ldap_err2string( rc ) );
    ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
    if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
      fprintf( stderr, "%s\n", error_msg );
    }
    if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
      fprintf( stderr, 
        "Part of the DN that matches an existing entry: %s\n", 
        matched_msg );
    }
    ldap_unbind_s( ld );
    return( 1 );
  }
/* Construct the array of LDAPMod structures representing the changes that you 
   want to make to attributes in the entry. */
/* Specify the first modification, which replaces all values of the
   mail attribute with the value "wbj@example.com". */
  mod0.mod_op = LDAP_MOD_REPLACE;
  mod0.mod_type = "mail";
  vals0[0] = "wbj@example.com";
  vals0[1] = NULL;
  mod0.mod_values = vals0;
/* Specify the second modification, which adds a value to the description 
   attribute. If this attribute does not yet exist, the attribute ia added to the 
   entry. */
  mod1.mod_op = LDAP_MOD_ADD;
  mod1.mod_type = "description";
  time( &amp;now );
  sprintf( buf, "This entry was modified with the modattrs program on %s",
  ctime( &amp;now ));
/* Get rid of \n which ctime put on the end of the time string */
  if ( buf[ strlen( buf ) - 1 ] == '\n' ) {
    buf[ strlen( buf ) - 1 ] = '\0';
  }
  vals1[ 0 ] = buf;
  vals1[ 1 ] = NULL;
  mod1.mod_values = vals1;
  mods[ 0 ] = &amp;mod0;
  mods[ 1 ] = &amp;mod1;
  mods[ 2 ] = NULL;
/* Perform the modify operation. */
  rc = ldap_modify_ext_s( ld, MODIFY_DN, mods, NULL, NULL );
  if ( rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_modify_ext_s: %s\n", ldap_err2string( rc ) );
    ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
    if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
      fprintf( stderr, "%s\n", error_msg );
    }
    if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
      fprintf( stderr, 
        "Part of the DN that matches an existing entry: %s\n", 
        matched_msg );
    }
  } else {
    printf( "%s modified successfully.\n", MODIFY_DN );
  }
  ldap_unbind_s( ld );
  return 0;
}</pre>

<h3 id="example-modify-entry-directory-async">Example: Modifying an Entry in the Directory (Asynchronous)</h3>

<p>The following sample program calls the asynchronous 
<code><a href="function.htm#modify-ext">ldap_modify_ext()</a></code> 
function to modify a user's entry in the directory. The program 
replaces the values of the mail attribute of the entry and adds a 
description attribute to the entry.</p>

<p><strong>Code Example 8-17 - Asynchronous modify</strong></p>

<pre class="code example">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include "ldap.h"
void do_other_work();
int global_counter = 0;
/* Change these as needed. */
#define HOSTNAME "localhost"
#define PORTNUMBER LDAP_PORT
#define BIND_DN "cn=Directory Manager"
#define BIND_PW "23skidoo"
#define MODIFY_DN "uid=wbjensen,ou=People,dc=example,dc=com"
int
main( int argc, char **argv )
{
  LDAP           *ld;
  LDAPMessage    *res;
  LDAPMod        mod0, mod1;
  LDAPMod        *mods[ 3 ];
  LDAPControl    **serverctrls;
  char           *matched_msg = NULL, *error_msg = NULL;
  char           **referrals;
  char           *vals0[ 2 ], *vals1[ 2 ];
  time_t      now;
  char      buf[ 128 ];
  int        rc, parse_rc, msgid, finished = 0;
  struct timeval  zerotime;
  zerotime.tv_sec = zerotime.tv_usec = 0L;
/* Get a handle to an LDAP connection. */
  if ( (ld = ldap_init( HOSTNAME, PORTNUMBER )) == NULL ) {
    perror( "ldap_init" );
    return( 1 );
  }
/* Bind to the server as the Directory Manager. */
  rc = ldap_simple_bind_s( ld, BIND_DN, BIND_PW );
  if ( rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_simple_bind_s: %s\n", ldap_err2string( rc ) );
    ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
    if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
      fprintf( stderr, "%s\n", error_msg );
    }
    if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
      fprintf( stderr, 
        "Part of the DN that matches an existing entry: %s\n", 
        matched_msg );
    }
    ldap_unbind_s( ld );
    return( 1 );
  }
/* Construct the array of LDAPMod structures representing the changes 
   that you want to make to attributes in the entry. */
/* Specify the first modification, which replaces all values of the 
   mail attribute with the value "wbj@example.com". */
  mod0.mod_op = LDAP_MOD_REPLACE;
  mod0.mod_type = "mail";
  vals0[0] = "wbj@example.com";
  vals0[1] = NULL;
  mod0.mod_values = vals0;
/* Specify the second modification, which adds a value to the description 
   attribute. If this attribute does not yet exist, the attribute ia 
   added to the entry. */
  mod1.mod_op = LDAP_MOD_ADD;
  mod1.mod_type = "description";
  time( &amp;now );
  sprintf( buf, "This entry was modified with the modattrs program on %s", ctime( &amp;now ));
/* Get rid of \n which ctime put on the end of the time string */
  if ( buf[ strlen( buf ) - 1 ] == '\n' ) {
    buf[ strlen( buf ) - 1 ] = '\0';
  }
  vals1[ 0 ] = buf;
  vals1[ 1 ] = NULL;
  mod1.mod_values = vals1;
  mods[ 0 ] = &amp;mod0;
  mods[ 1 ] = &amp;mod1;
  mods[ 2 ] = NULL;
/* Send the LDAP modify request. */
  rc = ldap_modify_ext( ld, MODIFY_DN, mods, NULL, NULL, &amp;msgid );
  if ( rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_modify_ext: %s\n", ldap_err2string( rc ) );
    ldap_unbind( ld );
    return( 1 );
  }
/* Poll the server for the results of the modify operation. */
  while ( !finished ) {
    rc = ldap_result( ld, msgid, 0, &amp;zerotime, &amp;res );
    switch ( rc ) {
    case -1:
      /* An error occurred. */
      rc = ldap_get_lderrno( ld, NULL, NULL );
      fprintf( stderr, "ldap_result: %s\n", ldap_err2string( rc ) );
      ldap_unbind( ld );
      return( 1 );
    case 0:
      /* The timeout period specified by zerotime was exceeded.
        This means that the server has still not yet sent the 
        results of the modify operation back to your client.
        Break out of this switch statement, and continue calling 
        ldap_result() to poll for results. */
      break;
    default:
      /* The function has retrieved the results of the modify operation from the server. */
      finished = 1;
      /* Parse the results received from the server. Note the last
        argument is a non-zero value, which indicates that the 
        LDAPMessage structure will be freed when done. (No need
        to call ldap_msgfree().) */
      parse_rc = ldap_parse_result( ld, res, &amp;rc, &amp;matched_msg, &amp;error_msg, &amp;referrals, &amp;serverctrls, 1 );
      if ( parse_rc != LDAP_SUCCESS ) {
        fprintf( stderr, "ldap_parse_result: %s\n", ldap_err2string( parse_rc ) );
        ldap_unbind( ld );
        return( 1 );
      }
      /* Check the results of the LDAP add operation. */
      if ( rc != LDAP_SUCCESS ) {
        fprintf( stderr, "ldap_modify_ext: %s\n", ldap_err2string( rc ) );
        if ( error_msg != NULL &amp; *error_msg != '\0' ) {
          fprintf( stderr, "%s\n", error_msg );
        }
        if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
          fprintf( stderr, 
            "Part of the DN that matches an existing entry: %s\n", 
            matched_msg );
        }
      } else {
        printf( "%s modified successfully.\n"
          "Counted to %d while waiting for the modify operation.\n",
          MODIFY_DN, global_counter );
      }
    }
/* Do other work while waiting for the results of the modify operation. */
    if ( !finished ) {
      do_other_work();
    }
  }
  ldap_unbind( ld );
  return 0;
}
  
/*
 * Perform other work while polling for results. This doesn't do anything
 * useful, but it could.
 */
void
do_other_work()
{
  global_counter++;
}</pre>

<h3 id="delete-entry">Deleting an Entry</h3>

<p>To remove an entry from the directory, call one of the following 
functions:</p>

<ul>
 <li>
  The synchronous 
  <code><a href="function.htm#delete-ext-s">ldap_delete_ext_s()</a></code> 
  function (see<a href="addmod.htm#perform-sync-delete">"Performing a Synchronous 
  Delete Operation</a>").
 <li>
  The asynchronous 
  <code><a href="function.htm#delete-ext">ldap_delete_ext()</a></code> 
  function (see<a href="addmod.htm#perform-async-delete">"Performing an Asynchronous 
  Delete Operation</a>").
</ul>


<p>For more information about the difference between synchronous and 
asynchronous functions, see <a href="using.htm#call_sync_async_function">"Calling 
Synchronous and Asynchronous Functions."</a></p>

<h3 id="perform-sync-delete">Performing a Synchronous Delete Operation</h3>

<p>If you want to wait for the results of the delete operation to 
complete before continuing, call the synchronous 
<code><a href="function.htm#delete-ext-s">ldap_delete_ext_s()</a></code> 
function. This function sends an LDAP delete request to the server 
and blocks until the server sends the results of the operation back 
to your client.</p>

<p>The <code>ldap_delete_ext_s()</code> function returns 
<code>LDAP_SUCCESS</code> if the operation completed successfully or 
an error code if a problem occurred. See the documentation on the 
<code><a href="function.htm#delete-ext-s">ldap_delete_ext_s()</a></code> 
function for a list of the possible result codes.</p>

<p>The following section of code uses the synchronous 
<code>ldap_delete_ext_s()</code> function to remove the entry for 
the user <code>William Jensen</code> from the directory.</p>

<p><strong>Code Example 8-18 - Synchronous deletion</strong></p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"
...
#define DELETE_DN "uid=wjensen,ou=People,dc=example,dc=com"
...
LDAP      *ld;
char      *matched_msg = NULL, *error_msg = NULL;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc;
...
/* Perform the delete operation. */
rc = ldap_delete_ext_s( ld, DELETE_DN, NULL, NULL );
if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_delete_ext_s: %s\n", ldap_err2string( rc ) );
  ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
  if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
    fprintf( stderr, "%s\n", error_msg );
  }
  if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
    fprintf( stderr, 
      "Part of the DN that matches an existing entry: %s\n", 
      matched_msg );
  }
} else {
  printf( "%s deleted successfully.\n", DELETE_DN );
}
ldap_unbind_s( ld );
...</pre>

<h3 id="perform-async-delete">Performing an Asynchronous Delete Operation</h3>

<p>If you want to perform other work (in parallel) while waiting for 
the entry to be deleted, call the asynchronous 
<code><a href="function.htm#delete-ext">ldap_delete_ext()</a></code> 
function. This function sends an LDAP delete request to the server 
and returns an <code>LDAP_SUCCESS</code> result code if the request 
was successfully sent (or an LDAP result code if an error occurred).</p>

<p>The <code>ldap_delete_ext()</code> function passes back a message 
ID identifying the delete operation. To determine whether the server 
sent a response for this operation to your client, call the 
<code><a href="function.htm#result">ldap_result()</a></code> function 
and pass in this message ID. The <code>ldap_result()</code> function 
uses the message ID to determine if the server sent the results of 
the delete operation. The function passes back the results in an 
<code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> structure.</p>

<p>You can call the 
<code><a href="function.htm#parse-result">ldap_parse_result()</a></code> 
function to parse the 
<code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> structure 
to determine if the operation was successful. For a list of possible 
result codes for an LDAP delete operation, see the result code 
documentation for the 
<code><a href="function.htm#delete-ext-s">ldap_delete_ext_s()</a></code> 
function.</p>

<p>The following section of code calls 
<code>ldap_delete_ext()</code> to remove the user <code>William 
Jensen</code> from the directory.</p>

<p<strong>Code Example 8-19 - Asynchronous deletion</strong></p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"
...
#define DELETE_DN "uid=wjensen,ou=People,dc=example,dc=com"
...
LDAP      *ld;
LDAPMessage    *res;
LDAPControl    **serverctrls;
char      *matched_msg = NULL, *error_msg = NULL;
char      **referrals;
int        rc, parse_rc, msgid, finished = 0;

/* Timeout period for the ldap_result() function to wait for results. */
struct timeval  zerotime;
zerotime.tv_sec = zerotime.tv_usec = 0L;
...
/* Send the LDAP delete request. */
rc = ldap_delete_ext( ld, DELETE_DN, NULL, NULL, &amp;msgid );
if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_delete_ext: %s\n", ldap_err2string( rc ) );
  ldap_unbind( ld );
  return( 1 );
}

/* Poll the server for the results of the delete operation. */
while ( !finished ) {
  rc = ldap_result( ld, msgid, 0, &amp;zerotime, &amp;res );
  switch ( rc ) {
  case -1:
    /* An error occurred. */
    rc = ldap_get_lderrno( ld, NULL, NULL );
    fprintf( stderr, "ldap_result: %s\n", ldap_err2string( rc ) );
    ldap_unbind( ld );
    return( 1 );
  case 0:
    /* The timeout period specified by zerotime was exceeded, 
      so call ldap_result() again and continue polling. */
      break;
  default:
    /* The function has retrieved the results of the 
      delete operation. */
      finished = 1;

    /* Parse the results received from the server. */
    parse_rc = ldap_parse_result( ld, res, &amp;rc, &amp;matched_msg, 
      &amp;error_msg, &amp;referrals, &amp;serverctrls, 1 );
    if ( parse_rc != LDAP_SUCCESS ) {
      fprintf( stderr, "ldap_parse_result: %s\n", 
        ldap_err2string( parse_rc ) );
      ldap_unbind( ld );
      return( 1 );
    }
    /* Check the results of the LDAP delete operation. */
    if ( rc != LDAP_SUCCESS ) {
      fprintf( stderr, "ldap_delete_ext: %s\n", 
        ldap_err2string( rc ) );
      if ( error_msg != NULL &amp; *error_msg != '\0' ) {
        fprintf( stderr, "%s\n", error_msg );
      }
      if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
        fprintf( stderr, 
          "Part of the DN that matches an existing entry: %s\n", 
          matched_msg );
      }
    } else {
      printf( "%s deleted successfully.\n", DELETE_DN );
    }
  }
}
ldap_unbind( ld );
...</pre>

<h3 id="example-delete-entry-directory-sync">Example: Deleting an Entry from the Directory (Synchronous)</h3>

<p>The following sample program calls the synchronous 
<code><a href="function.htm#delete-ext-s">ldap_delete_ext_s()</a></code> 
function to delete a user's entry from the directory.</p>

<p><strong>Code Example 8-20 - Synchronous entry deletion</strong></p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"
/* Change these as needed. */
#define HOSTNAME "localhost"
#define PORTNUMBER LDAP_PORT
#define BIND_DN "cn=Directory Manager"
#define BIND_PW "23skidoo"
#define DELETE_DN "uid=wjensen,ou=People,dc=example,dc=com"
int
main( int argc, char **argv )
{
  LDAP      *ld;
  char      *matched_msg = NULL, *error_msg = NULL;
  int        rc;
/* Get a handle to an LDAP connection. */
  if ( (ld = ldap_init( HOSTNAME, PORTNUMBER )) == NULL ) {
    perror( "ldap_init" );
    return( 1 );
  }
/* Bind to the server as the Directory Manager. */
  rc = ldap_simple_bind_s( ld, BIND_DN, BIND_PW );
  if ( rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_simple_bind_s: %s\n", ldap_err2string( rc ) );
    ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
    if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
      fprintf( stderr, "%s\n", error_msg );
    }
    if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
      fprintf( stderr, 
        "Part of the DN that matches an existing entry: %s\n", 
        matched_msg );
    }
    ldap_unbind_s( ld );
    return( 1 );
  }
/* Perform the delete operation. */
  rc = ldap_delete_ext_s( ld, DELETE_DN, NULL, NULL );
  if ( rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_delete_ext_s: %s\n", ldap_err2string( rc ) );
    ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
    if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
      fprintf( stderr, "%s\n", error_msg );
    }
    if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
      fprintf( stderr, 
        "Part of the DN that matches an existing entry: %s\n", 
        matched_msg );
    }
  } else {
    printf( "%s deleted successfully.\n", DELETE_DN );
  }
  ldap_unbind_s( ld );
  return 0;
}</pre>

<h3 id="example-delete-entry-directory-async">Example: Deleting an Entry from the Directory (Asynchronous)</h3>

<p>The following sample program calls the asynchronous 
<code><a href="function.htm#delete-ext">ldap_delete_ext()</a></code> 
function to delete a user's entry from the directory.</p>

<p><strong>Code Example 8-21 - Asynchronous entry deletion</strong></p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"
void do_other_work();
int global_counter = 0;
/* Change these as needed. */
#define HOSTNAME "localhost"
#define PORTNUMBER LDAP_PORT
#define BIND_DN "cn=Directory Manager"
#define BIND_PW "23skidoo"
#define DELETE_DN "uid=wjensen,ou=People,dc=example,dc=com"
int
main( int argc, char **argv )
{
  LDAP      *ld;
  LDAPMessage    *res;
  LDAPControl    **serverctrls;
  char      *matched_msg = NULL, *error_msg = NULL;
  char      **referrals;
  int        rc, parse_rc, msgid, finished = 0;
  struct timeval  zerotime;
  zerotime.tv_sec = zerotime.tv_usec = 0L;
/* Get a handle to an LDAP connection. */
  if ( (ld = ldap_init( HOSTNAME, PORTNUMBER )) == NULL ) {
    perror( "ldap_init" );
    return( 1 );
  }
/* Bind to the server as the Directory Manager. */
  rc = ldap_simple_bind_s( ld, BIND_DN, BIND_PW );
  if ( rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_simple_bind_s: %s\n", ldap_err2string( rc ) );
    ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
    if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
      fprintf( stderr, "%s\n", error_msg );
    }
    if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
      fprintf( stderr, 
        "Part of the DN that matches an existing entry: %s\n", 
        matched_msg );
    }
    ldap_unbind_s( ld );
    return( 1 );
  }
/* Send the LDAP delete request. */
  rc = ldap_delete_ext( ld, DELETE_DN, NULL, NULL, &amp;msgid );
  if ( rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_delete_ext: %s\n", ldap_err2string( rc ) );
    ldap_unbind( ld );
    return( 1 );
  }
/* Poll the server for the results of the delete operation. */
  while ( !finished ) {
    rc = ldap_result( ld, msgid, 0, &amp;zerotime, &amp;res );
    switch ( rc ) {
    case -1:
      /* An error occurred. */
      rc = ldap_get_lderrno( ld, NULL, NULL );
      fprintf( stderr, "ldap_result: %s\n", ldap_err2string( rc ) );
      ldap_unbind( ld );
      return( 1 );
    case 0:
      /* The timeout period specified by zerotime was exceeded.
        This means that the server has still not yet sent the 
        results of the delete operation back to your client.
        Break out of this switch statement, and continue calling 
        ldap_result() to poll for results. */
      break;
    default:
  /* The function has retrieved the results of the delete operation from the server. */
      finished = 1;
      /* Parse the results received from the server. Note the last
        argument is a non-zero value, which indicates that the 
        LDAPMessage structure will be freed when done. (No need
        to call ldap_msgfree().) */
      parse_rc = ldap_parse_result( ld, res, &amp;rc, &amp;matched_msg, &amp;error_msg, 
&amp;referrals, &amp;serverctrls, 1 );
      if ( parse_rc != LDAP_SUCCESS ) {
        fprintf( stderr, "ldap_parse_result: %s\n", ldap_err2string( parse_rc 
) );
        ldap_unbind( ld );
        return( 1 );
      }
      /* Check the results of the LDAP delete operation. */
      if ( rc != LDAP_SUCCESS ) {
        fprintf( stderr, "ldap_delete_ext: %s\n", ldap_err2string( rc ) );
        if ( error_msg != NULL &amp; *error_msg != '\0' ) {
          fprintf( stderr, "%s\n", error_msg );
        }
        if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
        fprintf( stderr, 
          "Part of the DN that matches an existing entry: %s\n", 
          matched_msg );
        }
      } else {
        printf( "%s deleted successfully.\n"
          "Counted to %d while waiting for the delete operation.\n",
          DELETE_DN, global_counter );
      }
    }
    /* Do other work while waiting for the results of the delete operation. */
    if ( !finished ) {
      do_other_work();
    }
  }
  ldap_unbind( ld );
  return 0;
}  
/*
 * Perform other work while polling for results. This doesn't do anything
 * useful, but it could.
 */
void
do_other_work()
{
  global_counter++;
}</pre>

<h3 id="change-dn-entry">Changing the DN of an Entry</h3>

<p>To change the distinguished name (DN) of an entry, call one of 
the following functions:</p>

<ul>
 <li>
  The synchronous 
  <code><a href="function.htm#rename-s">ldap_rename_s()</a></code> 
  function (see <a href="addmod.htm#perform-sync-rename">"Performing a 
  Synchronous Renaming Operation</a>").
 <li>
  The asynchronous 
  <code><a href="function.htm#rename">ldap_rename()</a></code> function 
  (see <a href="addmod.htm#perform-async-rename">"Performing an 
  Asynchronous Renaming Operation</a>").
</ul>

<p>For more information about the difference between synchronous and 
asynchronous functions, see<a href="using.htm#call_sync_async_function">"Calling 
Synchronous and Asynchronous Functions."</a></p>

<p>For both functions, you can choose to delete the attribute that 
represents the old relative distinguished name (RDN) (see 
<a href="addmod.htm#delete-attribute-old-rdn">"Deleting the Attribute 
from the Old RDN"</a> for details). You can also change the location of 
the entry in the directory tree (see 
<a href="addmod.htm#change-location-entry">"Changing the Location of 
the Entry"</a> for details).</p>

<h3 id="perform-sync-rename">Performing a Synchronous Renaming Operation</h3>

<p>If you want to wait for the results of the modify 
DN operation to complete before continuing, call the synchronous 
<code><a href="function.htm#rename-s">ldap_rename_s()</a></code> 
function. This function sends an LDAP modify DN request to the 
server and blocks until the server sends the results of the operation 
back to your client.</p>

<p>The <code>ldap_rename_s()</code> function returns 
<code>LDAP_SUCCESS</code> if the operation completed successfully or 
an error code if a problem occurred. See the documentation on the 
<code><a href="function.htm#rename-s">ldap_rename_s()</a></code> 
function for a list of the possible result codes.</p>

<p>The following section of code uses the synchronous 
<code>ldap_rename_s()</code> function to change the RDN of the entry 
for the user <code>William Jensen</code> in the directory.</p>

<p>
 <strong>Code Example 8-22 - Performing a synchronous modification</strong>
</p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"
...
#define OLD_DN "uid=wbjensen,ou=People,dc=example,dc=com"
#define NEW_RDN "uid=wjensen"
...
LDAP      *ld;
char      *matched_msg = NULL, *error_msg = NULL;
int        rc;
...
/* Perform the modify DN operation. */
rc = ldap_rename_s( ld, OLD_DN, NEW_RDN, NULL, 1, NULL, NULL );
if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_rename_s: %s\n", ldap_err2string( rc ) );
  ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
  if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
    fprintf( stderr, "%s\n", error_msg );
  }
  if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
    fprintf( stderr, 
      "Part of the DN that matches an existing entry: %s\n", 
      matched_msg );
  }
} else {
  printf( "%s renamed successfully.\n", OLD_DN );
}
ldap_unbind_s( ld );
...</pre>

<h3 id="perform-async-rename">Performing an Asynchronous Renaming Operation</h3>

<p>If you want to perform other work (in parallel) while waiting for 
the entry to be renamed, call the asynchronous 
<code><a href="function.htm#rename">ldap_rename()</a></code> 
function. This function sends an LDAP modify DN request to the 
server and returns an <code>LDAP_SUCCESS</code> result code if the 
request was successfully sent (or an LDAP result code if an error 
occurred).</p>

<p>The <code>ldap_rename()</code> function passes back a message ID 
identifying the modify DN operation. To determine whether the server 
sent a response for this operation to your client, call the 
<code><a href="function.htm#result">ldap_result()</a></code> function 
and pass in this message ID. The <code>ldap_result()</code> function 
uses the message ID to determine if the server sent the results of 
the modify DN operation. The function passes back the results in an 
<code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> structure.</p>

<p>You can call the 
<code><a href="function.htm#parse-result">ldap_parse_result()</a></code> 
function to parse the 
<code><a href="datatype.htm#LDAPMessage">LDAPMessage</a></code> structure 
to determine if the operation was successful. For a list of possible 
result codes for an LDAP rename operation, see the result code 
documentation for the 
<code><a href="function.htm#rename-s">ldap_rename_s()</a></code> 
function.</p>

<p>The following section of code calls <code>ldap_rename()</code> to 
change the RDN of the user <code>William Jensen</code> in the 
directory.</p>

<p>
 <strong>Code Example 8-23 - Performing an asynchronous modification</strong>
</p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"
...
#define OLD_DN "uid=wbjensen,ou=People,dc=example,dc=com"
#define NEW_RDN "uid=wjensen"
...
LDAP      *ld;
LDAPMessage    *res;
LDAPControl    **serverctrls;
char      *matched_msg = NULL, *error_msg = NULL;
char      **referrals;
int        rc, parse_rc, msgid, finished = 0;

/* Timeout period for the ldap_result() function to wait for results. */
struct timeval  zerotime;
zerotime.tv_sec = zerotime.tv_usec = 0L;
...
/* Send the LDAP modify DN request. */
rc = ldap_rename( ld, OLD_DN, NEW_RDN, NULL, 1, NULL, NULL, &amp;msgid );
if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_rename: %s\n", ldap_err2string( rc ) );
  ldap_unbind( ld );
  return( 1 );
}
 
/* Poll the server for the results of the modify DN operation. */
while ( !finished ) {
  rc = ldap_result( ld, msgid, 0, &amp;zerotime, &amp;res );
  switch ( rc ) {
  case -1:
    /* An error occurred. */
    rc = ldap_get_lderrno( ld, NULL, NULL );
    fprintf( stderr, "ldap_result: %s\n", ldap_err2string( rc ) );
    ldap_unbind( ld );
    return( 1 );
  case 0:
    /* The timeout period specified by zerotime was exceeded, 
      so call ldap_result() again and continue polling. */
    break;
  default:
    /* The function has retrieved the results of the 
      modify DN operation. */
    finished = 1;

    /* Parse the results received from the server. */
    parse_rc = ldap_parse_result( ld, res, &amp;rc, &amp;matched_msg, 
      &amp;error_msg, &amp;referrals, &amp;serverctrls, 1 );
    if ( parse_rc != LDAP_SUCCESS ) {
      fprintf( stderr, "ldap_parse_result: %s\n", 
        ldap_err2string( parse_rc ) );
      ldap_unbind( ld );
      return( 1 );
    }

    /* Check the results of the LDAP modify DN operation. */
    if ( rc != LDAP_SUCCESS ) {
      fprintf( stderr, "ldap_rename: %s\n", ldap_err2string( rc ) );
      if ( error_msg != NULL &amp; *error_msg != '\0' ) {
        fprintf( stderr, "%s\n", error_msg );
      }
      if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
        fprintf( stderr, 
          "Part of the DN that matches an existing entry: %s\n", 
          matched_msg );
      }
    } else {
      printf( "%s renamed successfully.\n", OLD_DN );
    }
  }
}
ldap_unbind( ld );
...</pre>

<h3 id="delete-attribute-old-rdn">Deleting the Attribute from the Old RDN</h3>

<p>Both <code><a href="function.htm#rename">ldap_rename()</a></code> 
and <code><a href="function.htm#rename-s">ldap_rename_s()</a></code> 
have a <code>deleteoldrdn</code> parameter that allows you to remove 
the old RDN from the entry. The <code>deleteoldrdn</code> parameter 
is best explained through this example. Suppose an entry has the 
following values for the <code>cn</code> attribute:</p>

<pre>cn: Barbara Jensen
cn: Babs Jensen</pre>

<p>The following function call adds "<code>Barbie Jensen</code>" to 
this list of values and removes the "<code>Barbara Jensen</code>" 
value:</p>

<pre>ldap_modrdn2( "cn=Barbara Jensen", "cn=Barbie Jensen", 1 );</pre>

<p>The resulting entry has the following values:</p>

<pre>cn: Barbie Jensen
cn: Babs Jensen</pre>

<p>If instead a <code>0</code> is passed for the <code>deleteoldrdn</code> parameter:</p>

<pre>ldap_modrdn2( "cn=Barbara Jensen", "cn=Barbie Jensen", 0 );</pre>

<p>the "<code>Barbara Jensen</code>" value is not removed from the entry:</p>

<pre>cn: Barbie Jensen
cn: Babs Jensen
cn: Barbara Jensen</pre>

<h3 id="change-location-entry">Changing the Location of the Entry</h3>

<p>Both <code><a href="function.htm#rename">ldap_rename()</a></code> 
and <code><a href="function.htm#rename-s">ldap_rename_s()</a></code> 
have a <code>newparent</code> parameter that allows you to specify a 
new location for the entry in the directory tree.</p>

<p>For example, if you pass 
"<code>ou=Contractors, dc=example,dc=com</code>" as the 
<code>newparent</code> parameter when renaming the entry 
"<code>uid=bjensen,ou=People,dc=example,dc=com</code>", the entry is 
moved under "<code>ou=Contractors, dc=example,dc=com</code>" and the 
new DN for the entry is 
"<code>uid=bjensen,ou=Contractors, dc=example,dc=com</code>".</p>

<p>Note that not all LDAP servers support this feature. At this 
point in time, the Netscape Directory Server does not support this 
feature. If you specify this argument, the Netscape Directory Server 
will send back the LDAP result code 
<code>LDAP_UNWILLING_TO_PERFORM</code> with the error message 
"server does not support moving of entries."</p>

<h3 id="example-rename-entry-directory-sync">
 Example: Renaming an Entry in the Directory (Synchronous)
</h3>

<p>The following sample program calls the synchronous 
<code><a href="function.htm#rename-s">ldap_rename_s()</a></code> function 
to change the RDN of a user's entry in the directory.</p>

<p>
 <strong>Code Example 8-24 - Synchronous renaming of an entry</strong>
</p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"
/* Change these as needed. */
#define HOSTNAME "localhost"
#define PORTNUMBER LDAP_PORT
#define BIND_DN "cn=Directory Manager"
#define BIND_PW "23skidoo"
#define OLD_DN "uid=wbjensen,ou=People,dc=example,dc=com"
#define NEW_RDN "uid=wjensen"
int
main( int argc, char **argv )
{
 LDAP   *ld;
 char   *matched_msg = NULL, *error_msg = NULL;
 int    rc;
/* Get a handle to an LDAP connection. */
 if ( (ld = ldap_init( HOSTNAME, PORTNUMBER )) == NULL ) {
  perror( "ldap_init" );
  return( 1 );
 }
/* Bind to the server as the Directory Manager. */
 rc = ldap_simple_bind_s( ld, BIND_DN, BIND_PW );
 if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_simple_bind_s: %s\n", ldap_err2string( rc ) );
  ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
  if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
   fprintf( stderr, "%s\n", error_msg );
  }
  if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
   fprintf( stderr, 
    "Part of the DN that matches an existing entry: %s\n", 
    matched_msg );
  }
  ldap_unbind_s( ld );
  return( 1 );
 }
/* Perform the modify DN operation. */
 rc = ldap_rename_s( ld, OLD_DN, NEW_RDN, NULL, 1, NULL, NULL );
 if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_rename_s: %s\n", ldap_err2string( rc ) );
  ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
  if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
   fprintf( stderr, "%s\n", error_msg );
  }
  if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
   fprintf( stderr, 
    "Part of the DN that matches an existing entry: %s\n", 
    matched_msg );
  }
 } else {
  printf( "%s renamed successfully.\n", OLD_DN );
 }
 ldap_unbind_s( ld );
 return 0;
}</pre>

<h3 id="example-rename-entry-directory-async">
 Example: Renaming an Entry in the Directory (Asynchronous)
</h3>

<p>The following sample program calls the asynchronous 
<code><a href="function.htm#rename">ldap_rename()</a></code> function to 
change the RDN of a user's entry in the directory.</p>

<p>
 <strong>Code Example 8-25 - Asynchronous renaming of an entry</strong>
</p>

<pre class="code example">#include &lt;stdio.h&gt;
#include "ldap.h"
void do_other_work();
int global_counter = 0;
/* Change these as needed. */
#define HOSTNAME "localhost"
#define PORTNUMBER LDAP_PORT
#define BIND_DN "cn=Directory Manager"
#define BIND_PW "dougy4444"
#define OLD_DN "uid=wbjensen,ou=People,dc=example,dc=com"
#define NEW_RDN "uid=wjensen"
int
main( int argc, char **argv )
{
 LDAP   *ld;
 LDAPMessage  *res;
 LDAPControl  **serverctrls;
 char   *matched_msg = NULL, *error_msg = NULL;
 char   **referrals;
 int    rc, parse_rc, msgid, finished = 0; struct timeval zerotime;
 zerotime.tv_sec = zerotime.tv_usec = 0L;
/* Get a handle to an LDAP connection. */
 if ( (ld = ldap_init( HOSTNAME, PORTNUMBER )) == NULL ) {
  perror( "ldap_init" );
  return( 1 );
 }
/* Bind to the server as the Directory Manager. */
 rc = ldap_simple_bind_s( ld, BIND_DN, BIND_PW );
 if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_simple_bind_s: %s\n", ldap_err2string( rc ) );
  ldap_get_lderrno( ld, &amp;matched_msg, &amp;error_msg );
  if ( error_msg != NULL &amp;&amp; *error_msg != '\0' ) {
   fprintf( stderr, "%s\n", error_msg );
  }
  if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
   fprintf( stderr, 
    "Part of the DN that matches an existing entry: %s\n", 
    matched_msg );
  }
  ldap_unbind_s( ld );
  return( 1 );
 }
/* Send the LDAP modify DN request. */
 rc = ldap_rename( ld, OLD_DN, NEW_RDN, NULL, 1, NULL, NULL, &amp;msgid );
 if ( rc != LDAP_SUCCESS ) {
  fprintf( stderr, "ldap_rename: %s\n", ldap_err2string( rc ) );
  ldap_unbind( ld );
  return( 1 );
 }
/* Poll the server for the results of the modify DN operation. */
 while ( !finished ) {
  rc = ldap_result( ld, msgid, 0, &amp;zerotime, &amp;res );
  switch ( rc ) {
  case -1:
   /* An error occurred. */
   rc = ldap_get_lderrno( ld, NULL, NULL );
   fprintf( stderr, "ldap_result: %s\n", ldap_err2string( rc ) );
   ldap_unbind( ld );
   return( 1 );
  case 0:
   /* The timeout period specified by zerotime was exceeded.
     This means that the server has still not yet sent the 
     results of the modify DN operation back to your client.
     Break out of this switch statement, and continue calling 
     ldap_result() to poll for results. */
   break;
  default:
 /* The function has retrieved the results of the modify DN operation
     from the server. */
   finished = 1;
   /* Parse the results received from the server. Note the last
     argument is a non-zero value, which indicates that the 
     LDAPMessage structure will be freed when done. (No need
     to call ldap_msgfree().) */
   parse_rc = ldap_parse_result( ld, res, &amp;rc, &amp;matched_msg, &amp;error_msg, &amp;referrals, &amp;serverctrls, 1 );
   if ( parse_rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_parse_result: %s\n", ldap_err2string( parse_rc ) );
    ldap_unbind( ld );
    return( 1 );
   }
   /* Check the results of the LDAP modify DN operation. */
   if ( rc != LDAP_SUCCESS ) {
    fprintf( stderr, "ldap_rename: %s\n", ldap_err2string( rc ) );
    if ( error_msg != NULL &amp; *error_msg != '\0' ) {
     fprintf( stderr, "%s\n", error_msg );
    }
    if ( matched_msg != NULL &amp;&amp; *matched_msg != '\0' ) {
     fprintf( stderr, 
      "Part of the DN that matches an existing entry: %s\n", 
      matched_msg );
    }
   } else {
    printf( "%s renamed successfully.\n"
     "Counted to %d while waiting for the modify DN operation.\n",
     OLD_DN, global_counter );
   }
  }
  /* Do other work while waiting for the results of the modify DN operation. */
  if ( !finished ) {
   do_other_work();
  }
 }
 ldap_unbind( ld );
 return 0;
} 
/*
 * Perform other work while polling for results. This doesn't do anything
 * useful, but it could.
 */
void
do_other_work()
{
  global_counter++;
}</pre>




<hr class="hide">
</div>
</div>
<div id="footer">
<ul>
<li><a href="../../sitemap.html">Site Map</a></li>
<li><a href="../../security/">Security Updates</a></li>
<li><a href="../../contact/">Contact Us</a></li>
<li><a href="../../foundation/donate.html">Donate</a></li>
</ul>
<p class="copyright">
Portions of this content are &copy; 1998&#8211;2009 by individual mozilla.org
contributors; content available under a Creative Commons license | <a
href="http://www.mozilla.org/foundation/licensing/website-content.html">Details</a>.</p>
<p>
<span>Last modified March 16,  2005</span>
<span><a href="http://bonsai-www.mozilla.org/cvslog.cgi?file=mozilla-org/html/directory/csdk-docs/addmod.htm&amp;rev=&amp;root=/www/">Document History</a></span>
</p>
</div>
</div>
</body>
</html>
