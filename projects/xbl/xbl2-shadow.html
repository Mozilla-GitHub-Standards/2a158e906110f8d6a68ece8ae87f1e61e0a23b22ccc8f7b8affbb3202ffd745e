<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">

<html lang="en-GB-hixie">
 <head>
  <title>XML Binding Language 2.0</title>

  <link href="http://www.mozilla.org/favicon.ico" rel="icon">

  <style type="text/css">

    html { margin: 0; padding: 0; color: black; background: white; }
    body { margin: 0; padding: 0; background: top left repeat-y url(http://www.mozilla.org/favicon.ico); }

    :link { color: #00C; background: transparent }
    :visited { color: #609; background: transparent }
    :link:active, :visited:active { color: #C00; background: transparent }
    :link:hover, :visited:hover { background: #ffa; }
    code :link, code :visited { color: inherit; }

    h1, h2, h3, h4, h5, h6 { text-align: left }
    h1, h2, h3 { color: #3c790a; background: transparent; }
    h1 { font: 900 170% sans-serif }
    h2 { font: 800 140% sans-serif }
    h3 { font: 700 120% sans-serif }
    h4 { font: bold 100% sans-serif }
    h5 { font: italic 100% sans-serif }
    h6 { font: small-caps 100% sans-serif }

    /* overall semantic structure presentation */
    body { padding: 0 1em 2em 8.5em; line-height: 1.35; }
    pre { margin-left: 2em; /* overflow: auto; */ }
    h1 + h2 { margin-top: 0; }
    h2 { margin: 3em 0 1em 0; }
    h2 + h3 { margin-top: 0; }
    h3 { margin: 2em 0 1em 0; }
    h4 { margin: 1.5em 0 0.75em 0; }
    h5, h6 { margin: 1.5em 0 1em; }
    p { margin: 1em 0; }
    dl, dd { margin-top: 0; margin-bottom: 0; }
    dt { margin-top: 0.75em; margin-bottom: 0.25em; clear: left; }
    dd dt { margin-top: 0.25em; margin-bottom: 0; }
    dd p { margin-top: 0; }
    p + * > li, dd li { margin: 1em 0; }
    dt, dfn { font-weight: bold; font-style: normal; }
    pre, code { font-size: inherit; font-family: monospace; }
    pre strong { color: black; font: inherit; font-weight: bold; background: yellow; }
    pre em { font-weight: bolder; font-style: normal; }
    @media screen { code { color: orangered; } }
    var sub { vertical-align: bottom; font-size: smaller; position: relative; top: 0.1em; }
    table { border-collapse: collapse; border-style: hidden hidden none hidden; }
    table thead { border-bottom: solid; }
    table tbody th:first-child { border-left: solid; }
    table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
    blockquote { margin: 0 0 0 2em; border: 0; padding: 0; font-style: italic; }
    ins { background: green; color: white; /* color: green; border: solid thin lime; padding: 0.3em; line-height: 1.6em; */ text-decoration: none; }
    del { background: maroon; color: white; /* color: maroon; border: solid thin red; padding: 0.3em; line-height: 1.6em; */ text-decoration: line-through; }
    body ins, body del { display: block; }
    body * ins, body * del { display: inline; }

    /* classes */

    ul.toc dfn, h1 dfn, h2 dfn, h3 dfn, h4 dfn, h5 dfn, h6 dfn { font: inherit; }
    img.extra { float: right; }
    hr.bookmark { border: dashed 2em black; background: yellow; }
    pre.idl { border: solid thin; background: #EEEEEE; color: black; padding: 0.5em; }
    pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
    code.property-name { background: #FFFFCC; color: black; }
    code.method-name { background: #CCCCFF; color: black; }
    code.parameter-name { background: #FFCCFF; color: black; }
    code.constant-name { background: #CCFFCC; color: black; }

    div.head { margin: 0 0 1em; padding: 1em 0 0 0; }
    div.head p { margin: 1em 0; }
    div.head h1 { margin: 0; }
    div.head .logo { float: right; margin: 0 1em; }
    div.head .logo img { border: none } /* remove border from top image */
    div.head dl { margin: 1em 0; }
    div.head p.copyright { font-size: smaller; }

    .issue { color: #E50000; background: white; opacity: 0.9; }
    .big-issue { color: #E50000; background: white; border: solid red; padding: 0.5em; margin: 1em 0; }
    .big-issue > :first-child { margin-top: 0; }
    p .big-issue { line-height: 3em; }
    .note { color: green; background: transparent; }
    .warning { color: red; background: transparent; }
    .note, .warning { font-weight: bolder; font-style: italic; padding: 0.5em 2em; }
    .warning:before { font-style: normal; }

    body, th, td { font-family: sans-serif; }
    pre, code { font-family: monospace; }
    .note { font-family: sans-serif; }
    p.note:before { content: 'Note: '; }
    p.warning:before { content: '\26A0 Warning! '; }
    ul.toc { list-style: none; }

    .issue {
      position: absolute;
      top: auto;
      left: 0;
      margin: -1.5em 0.2em 0.2em 0.2em;
      border: solid thin;
      padding: 0.35em;
      width: 12em;
      text-align: left;
      font-size: 0.6em;
    }

    .issue:hover {
      z-index: 1;
    }

    .issue:before {
      content: '\25B6';
      display: block;
      text-align: right;
      position: absolute;
      left: 100%;
      top: 0;
    }

    .critical { margin: 1em; border: double thick red; padding: 1em; background: #FFFFCC; }
    .critical > :first-child { margin-top: 0; }

    .example {
      display: block;
      color: #222222;
      background: #FCFCFC;
      border-left: double;
      margin-left: 1em;
      padding-left: 1em;
    }

    @media aural {  
      h1, h2, h3 { stress: 20; richness: 90 }
      .hide { speak: none }
      p.copyright { volume: x-soft; speech-rate: x-fast }
      dt { pause-before: 20% }
      code, pre { speak-punctuation: code } 
    }

    .hide, #footer { display: none }
  </style>

 <body>

  <div class="head">
   <h1 id="xbl-2.0">XBL 2.0 - Alternate Shadow Tree Proposal</h1>

   <h2 class="no-num no-toc" id="work-in"> Work in Progress &mdash; Last
    Update 22 November 2005</h2>

   <p>XBL 2.0 is part of Mozilla's <a
    href="http://www.mozilla.org/projects/xbl/">XBL Project</a>. For a list
    of other Mozilla projects, see the <a
    href="http://www.mozilla.org/projects/">project page</a>.</p>

   <p>Please send comments to the <a
    href="mailto:mozilla-xbl@mozilla.org">mozilla-xbl@mozilla.org</a> mailing
    list (<a
    href="http://mail.mozilla.org/listinfo/mozilla-xbl">subscribe</a>).</p>

   <p>This document is stored in CVS. <a
    href="http://bonsai-www.mozilla.org/cvslog.cgi?file=mozilla-org/html/projects/xbl/xbl2-shadow.html&root=/www/">View
    document history</a>.</p>

   <p class="copyright">Portions of this content are &copy; 1998&#8211;2005
    by individual mozilla.org contributors; content available under a
    Creative Commons license. (<a
    href="http://www.mozilla.org/foundation/licensing/website-content.html">Details</a>)</p>

  </div>

  <hr>

  <h2 class="no-num no-toc" id="abstract">Abstract</h2>

  <p>This specification describes the ability to map elements to script,
   event handlers, CSS, and more complex content models. This can be used to
   re-order and wrap content so that, for instance, simple HTML or XHTML
   markup can have complex CSS styles applied without requiring that the
   markup be polluted with multiple semantically neutral <code>div</code>
   elements.

  <p>It can also be used to implement new DOM interfaces, and, in conjunction
   with other specifications, enables arbitrary tag sets to be implemented as
   widgets. For example, XBL could in theory be used to implement XForms.

  <h2 class="no-num" id="status">Status of this document</h2>

  <p>This specification is a (non-backwards-compatible) revision of Mozilla's
   XBL 1.0 language, originally developed at Netscape in 2000, and originally
   implemented in the Gecko rendering engine. <a
   href="#refsXBL10">[XBL10]</a>

  <p>This specification was developed by the Mozilla Foundation and its
   contributors, in conjunction with individuals from Opera Software ASA,
   Google, Inc, and Apple Computer, Inc, to address problems found in the
   original language and to allow for implementations in a broader range of
   Web browsers.

  <p>This document is also based, in part, on work done in the W3C's Bindings
   Task Force. However, no text from that collaboration, other than that
   written by the aforementioned contributors, remains in this specification.
   Inspiration was similarly taken from other efforts, such as HTML
   Components. <a href="#refsHTC">[HTC]</a>

  <p>Although they have had related histories, this specification is separate
   from the W3C's "sXBL" drafts, and is not compatible with them. (The two
   efforts use different namespaces, for one.)

  <p>This is the working copy of XBL 2.0. If you wish to make comments
   regarding this document, please send them to <a
   href="mailto:xbl2@mozilla.org">mozilla-xbl@mozilla.org</a>. All feedback
   is welcome.

  <pre class="big-issue">REMAINING ISSUES:
   Make sure we define what happens if the inheritance chain forms a loop (either explicitly or implicitly). **
    + Recommend we say that if a binding is already bound to an element, it doesn't get rebound.
   Add an "explicit inheritance" section before the implicit inheritance one **
    + removing a binding also removes its explicitly inherited base bindings
    + link >inherits< to it.

   Need much better examples. *
   Fix images. *

</pre>

  <h2 class="no-num no-toc" id="table">Table of contents</h2>
  <!--begin-toc-->

  <ul class="toc">
   <li class="no-num"><a href="#status">Status of this document</a>

   <li><a href="#introduction"><span class="secno">1. </span>Introduction</a>

    
    <ul class="toc">
     <li><a href="#terminology"><span class="secno">1.1. </span>Terminology
      and Conventions</a>

     <li><a href="#conformance"><span class="secno">1.2.
      </span>Conformance</a>
      <ul class="toc">
       <li><a href="#attributes"><span class="secno">1.2.1. </span><dfn
        id="attributes13" title="selector">Attributes Containing
        Selectors</dfn></a>

       <li><a href="#attributes0"><span class="secno">1.2.2. </span><dfn
        id="attributes14" title="space-separated">Attributes Containing
        Space-Separated Values</dfn></a>
      </ul>
    </ul>

   <li><a href="#xbl-elements"><span class="secno">2. </span>XBL Elements</a>
    
    <ul class="toc">
     <li><a href="#the-xbl"><span class="secno">2.1. </span>The <dfn
      id="xbl">xbl</dfn> Element</a>

     <li><a href="#the-binding"><span class="secno">2.2. </span>The <dfn
      id="binding4">binding</dfn> Element</a>

     <li><a href="#the-implementation"><span class="secno">2.3. </span>The
      <dfn id="implementation">implementation</dfn> Element</a>

     <li><a href="#the-template"><span class="secno">2.4. </span>The <dfn
      id="template">template</dfn> Element</a>

     <li><a href="#the-element"><span class="secno">2.5. </span>The <dfn
      id="element">element</dfn> Element</a>

     <li><a href="#the-content"><span class="secno">2.6. </span>The <dfn
      id="content">content</dfn> Element</a>

     <li><a href="#the-xblinherits"><span class="secno">2.7. </span>The <dfn
      id="xblinherits" title="attr-inherits">xbl:inherits</dfn> Attribute</a>
      

     <li><a href="#the-xblpseudo"><span class="secno">2.8. </span>The <dfn
      id="xblpseudo" title="attr-pseudo">xbl:pseudo</dfn> Attribute</a>

     <li><a href="#the-handlers"><span class="secno">2.9. </span>The <dfn
      id="handlers">handlers</dfn> Element</a>

     <li><a href="#the-handler"><span class="secno">2.10. </span>The <dfn
      id="handler">handler</dfn> Element</a>

     <li><a href="#the-resources"><span class="secno">2.11. </span>The <dfn
      id="resources0">resources</dfn> Element</a>

     <li><a href="#the-style"><span class="secno">2.12. </span>The <dfn
      id="style">style</dfn> Element</a>

     <li><a href="#the-prefetch"><span class="secno">2.13. </span>The <dfn
      id="prefetch">prefetch</dfn> Element</a>

     <li><a href="#the-script"><span class="secno">2.14. </span>The <dfn
      id="script0">script</dfn> Element</a>

     <li><a href="#the-id"><span class="secno">2.15. </span>The <dfn id="id"
      title="attr-id">id</dfn> Attribute of XBL Elements</a>
    </ul>

   <li><a href="#resources"><span class="secno">3. </span>Resources</a>
    <ul class="toc">

     <li><a href="#loading"><span class="secno">3.1. </span><dfn
      id="loading2">Loading External Resources</dfn></a>

     <li><a href="#loading0"><span class="secno">3.2. </span><dfn
      id="loading3">Loading and Running Scripts</dfn></a>
      <ul class="toc">
       <li><a href="#xforms"><span class="secno">3.2.1. </span>XForms
        Actions</a>

       <li><a href="#scripting"><span class="secno">3.2.2. </span>Scripting
        Model and Security</a>

      </ul>

     <li><a href="#loading1"><span class="secno">3.3. </span><dfn
      id="loading4">Loading Stylesheets</dfn></a>

     <li><a href="#interpretation"><span class="secno">3.4. </span><dfn
      id="interpretation0">Interpretation of URIs to XBL bindings</dfn></a>
    </ul>

   <li><a href="#binding"><span class="secno">4. </span><dfn
    id="binding5">Binding Attachment and Detachment</dfn></a>

    <ul class="toc">
     <li><a href="#attachment"><span class="secno">4.1. </span><dfn
      id="attachment3" title="attachment using binding">Attachment using
      <code title="binding">&lt;binding element=""&gt;</code></dfn></a>
      <ul class="toc">
       <li><a href="#importing"><span class="secno">4.1.1. </span><dfn
        id="importing0" title="import">Importing binding documents</dfn></a>
      </ul>

     <li><a href="#attachment0"><span class="secno">4.2. </span>Attachment
      using CSS</a>

      <ul class="toc">
       <li><a href="#the--xbl-binding"><span class="secno">4.2.1. </span>The
        '-xbl-binding' property</a>

       <li><a href="#processing"><span class="secno">4.2.2. </span>Processing
        model</a>
      </ul>

     <li><a href="#attachment1"><span class="secno">4.3. </span>Attachment
      using the DOM</a>

     <li><a href="#binding0"><span class="secno">4.4. </span><dfn
      id="binding6">Binding Attachment Model</dfn></a>

     <li><a href="#handling"><span class="secno">4.5. </span><dfn
      id="handling1">Handling Insertion and Removal from the
      Document</dfn></a>

     <li><a href="#implied"><span class="secno">4.6. </span><dfn
      id="implied0">Implied Inheritance</dfn></a>

     <li><a href="#views"><span class="secno">4.7. </span>Views and
      Attachment</a>

     <li><a href="#attachment2"><span class="secno">4.8. </span>Attachment
      During Document Load</a>

     <li><a href="#binding1"><span class="secno">4.9. </span>Binding
      Detachment Model</a>
    </ul>

   <li><a href="#shadow"><span class="secno">5. </span><dfn
    id="shadow3">Shadow Content</dfn></a>

    <ul class="toc">
     <li><a href="#rules"><span class="secno">5.1. </span><dfn
      id="rules1">Rules for Shadow Content Generation</dfn></a>

     <li><a href="#rules0"><span class="secno">5.2. </span><dfn
      id="rules2">Rules for Shadow Content Destruction</dfn></a>

     <li><a href="#attribute"><span class="secno">5.3. </span><dfn
      id="attribute0">Attribute Forwarding</dfn></a>

     <li><a href="#processing0"><span class="secno">5.4. </span><dfn
      id="processing1">Processing <code>content</code> Elements</dfn></a>

     <li><a href="#handling0"><span class="secno">5.5. </span>Handling DOM
      Changes</a>

     <li><a href="#shadow0"><span class="secno">5.6. </span>Shadow Content
      and CSS</a>

      <ul class="toc">
       <li><a href="#terminology0"><span class="secno">5.6.1.
        </span>Terminology</a>

       <li><a href="#selectors"><span class="secno">5.6.2. </span><dfn
        id="selectors0">Selectors and Shadow Scopes</dfn></a>

       <li><a href="#the--xbl-bound-element"><span class="secno">5.6.3.
        </span>The <code>:-xbl-bound-element</code> Pseudo-Class</a>

       <li><a href="#matching"><span class="secno">5.6.4. </span><dfn
        id="matching0">Matching Pseudo-Elements</dfn></a>
      </ul>

     <li><a href="#shadow1"><span class="secno">5.7. </span>Shadow Content
      and <code>xml:base</code></a>

     <li><a href="#shadow2"><span class="secno">5.8. </span><dfn id="shadow4"
      title="Semantics of non-XBL elements in XBL contexts">Shadow Content
      and Other Things</dfn></a>

      <ul class="toc">
       <li><a href="#general"><span class="secno">5.8.1. </span>General
        Rules</a>

       <li><a href="#stylesheets"><span class="secno">5.8.2. </span><dfn
        id="stylesheets0">Stylesheets Blocks</dfn></a>

       <li><a href="#script"><span class="secno">5.8.3. </span><dfn
        id="script1">Script Blocks</dfn></a>

       <li><a href="#event"><span class="secno">5.8.4. </span><dfn
        id="event3">Event Handler Blocks</dfn></a>

       <li><a href="#html-forms"><span class="secno">5.8.5. </span>HTML
        Forms</a>

       <li><a href="#svg"><span class="secno">5.8.6. </span>SVG</a>
      </ul>

     <li><a href="#binding2"><span class="secno">5.9. </span><dfn
      id="binding7">Binding Stylesheets</dfn></a>
    </ul>

   <li><a href="#binding3"><span class="secno">6. </span><dfn
    id="binding8">Binding Implementations</dfn></a>
    <ul class="toc">
     <li><a href="#the-xblimplementation"><span class="secno">6.1. </span>The
      <code>XBLImplementation</code> Interface</a>

     <li><a href="#inheritance"><span class="secno">6.2. </span><dfn
      id="inheritance0">Inheritance of Implementations</dfn></a>

     <li><a href="#ecmascript"><span class="secno">6.3. </span><dfn
      id="ecmascript0">ECMAScript Bindings</dfn></a>
    </ul>

   <li><a href="#event0"><span class="secno">7. </span><dfn id="event4">Event
    Handlers</dfn></a>

    <ul class="toc">
     <li><a href="#event1"><span class="secno">7.1. </span><dfn
      id="event5">Event Forwarding</dfn></a>

     <li><a href="#registering"><span class="secno">7.2. </span><dfn
      id="registering0">Registering Event Handlers with the
      <code>handler</code> Element</dfn></a>

     <li><a href="#mouse"><span class="secno">7.3. </span><dfn
      id="mouse0">Mouse Event Handler Filters</dfn></a>

     <li><a href="#key-event"><span class="secno">7.4. </span><dfn
      id="key-event0">Key Event Handler Filters</dfn></a>

     <li><a href="#text-input"><span class="secno">7.5. </span><dfn
      id="text-input0">Text Input Event Handler Filters</dfn></a>

     <li><a href="#mutation"><span class="secno">7.6. </span><dfn
      id="mutation0">Mutation Event Handler Filters</dfn></a>

     <li><a href="#modifiers"><span class="secno">7.7. </span><dfn
      id="modifiers0">Modifiers</dfn></a>

     <li><a href="#event2"><span class="secno">7.8. </span><dfn
      id="event6">Event Flow and Targeting Across Shadow Scopes</dfn></a>

     <li><a href="#focus"><span class="secno">7.9. </span>Focus, DOMFocusIn,
      Blur, and DOMFocusOut Events</a>

     <li><a href="#mouseover"><span class="secno">7.10. </span>Mouseover and
      Mouseout Events</a>
    </ul>

   <li><a href="#dom-interfaces"><span class="secno">8. </span><dfn
    id="dom-interfaces0">DOM Interfaces</dfn></a>
    <ul class="toc">
     <li><a href="#the-documentxbl"><span class="secno">8.1. </span>The
      <code>DocumentXBL</code> Interface</a>

     <li><a href="#the-nodexbl"><span class="secno">8.2. </span>The <dfn
      id="nodexbl">NodeXBL</dfn> Interface</a>

      <ul class="toc">
       <li><a href="#scoping"><span class="secno">8.2.1. </span>Scoping and
        Access Using the DOM</a>

       <li><a href="#dom-traversals"><span class="secno">8.2.2. </span><dfn
        id="dom-traversals0">DOM Traversals in the Presence of XBL</dfn></a>

       <li><a href="#example"><span class="secno">8.2.3. </span>Example of
        XBL DOM Traversals</a>
      </ul>

     <li><a href="#the-xblcontentelement"><span class="secno">8.3. </span>The
      <dfn id="xblcontentelement">XBLContentElement</dfn> Interface</a>

     <li><a href="#the-eventxbl"><span class="secno">8.4. </span>The
      <code>EventXBL</code> Interface</a>

     <li><a href="#the-xbltemplateelement"><span class="secno">8.5.
      </span>The <dfn id="xbltemplateelement">XBLTemplateElement</dfn>
      Interface</a>

     <li><a href="#the-xblpresentation"><span class="secno">8.6. </span>
      The <dfn id="xblpresentation">XBLPresentation</dfn> Interface</a>
    </ul>

   <li><a href="#widget"><span class="secno">9. </span>Widget Bindings</a>
    <ul class="toc">

     <li><a href="#base-bindings"><span class="secno">9.1. </span>Predefined
      Base Bindings</a>
    </ul>

   <li><a href="#examples"><span class="secno">10. </span>Examples</a>
    <ul class="toc">
     <li><a href="#making"><span class="secno">10.1. </span>Making a Popup
      Menu Widget</a>

    </ul>

   <li class="no-num"><a href="#acknowledgments">Acknowledgments</a>

   <li class="no-num"><a href="#references">References</a>
  </ul>
  <!--end-toc-->

  <hr>

  <h2 id="introduction"><span class="secno">1. </span>Introduction</h2>

  <p>This specification defines the XML Binding Language and some supporting
   DOM interfaces and CSS features. XBL is a mechanism for overriding the
   standard presentation and interactive behaviour of particular elements by
   attaching those elements to appropriate definitions, called <span
   title="binding"><a href="#binding11">bindings</a></span>. Bindings can be
   attached to elements using either cascading stylesheets, the document
   object model, or by declaring, in XBL, that a particular element in a
   particular namespace is implemented by a particular binding. The element
   that the binding is attached to, called the <span><a href="#bound">bound
   element</a></span>, acquires the new behaviour and presentation specified
   by the binding.

  <p>Bindings can contain <span title="handlers"><a href="#handlers0">event
   handlers</a></span> that watch for events on the bound element, an
   <span><a href="#implementation0">implementation</a></span> of new methods,
   properties and fields that become accessible from the bound element,
   <span><a href="#shadow8">shadow content</a></span> that is inserted
   around the bound element, and associated <span><a
   href="#resources1">resources</a></span> such as scoped stylesheets and
   precached images, sounds, or videos.

  <p><span title="Except if script invoked by XBL explicitly changes the
   original DOM.">XBL cannot be used to give a document new semantics.</span>

   The meaning of a document is not changed by any bindings that are
   associated with it, only its presentation and interactive behaviour.

  <h3 id="terminology"><span class="secno">1.1. </span>Terminology and
   Conventions</h3>

  <p>A <dfn id="binding9">binding</dfn> is the definition of behaviour that
   can be applied to an element so as to augment its presentation.

  <p>An <dfn id="xbl-subtree">XBL subtree</dfn> is a subtree in an XML
   document (an XML instance), the subtree having as its root
   <!-- XXX better word than
  root? --> node an <code><a
   href="#xbl0">xbl</a></code> element in the XBL namespace, which is used to
   define bindings. XBL subtrees can stand alone in <span title="XBL
   document"><a href="#xbl-document">XBL documents</a></span>, or can be
   included in <span title="compound document"><a href="#compound">compound
   documents</a></span>.

  <p>An <dfn id="xbl-document">XBL document</dfn> is an XML document that has
   the <code><a href="#xbl0">xbl</a></code> element at its root.

  <p>A <dfn id="compound">compound document</dfn> is an XML document that
   contains elements from multiple namespaces, with its root element being
   from a document language (not XBL), such as XHTML.

  <p>The term <dfn id="binding10">binding document</dfn> is used to mean
   either an <span><a href="#xbl-document">XBL document</a></span> or a
   <span><a href="#compound">compound document</a></span> containing one or
   more <span title="XBL subtree"><a href="#xbl-subtree">XBL
   subtrees</a></span>.

  <p>A <dfn id="bound">bound element</dfn> is an element in an arbitrary XML
   namespace, or in an HTML document, to which a binding has been applied.

  <p>A <dfn id="bound0">bound document</dfn> is an XML or HTML document
   containing one or more <span title="bound element"><a href="#bound">bound
   elements</a></span>.

  <p>The <dfn id="content1">content template</dfn> for a binding is the
   subtree of nodes that are attached to a bound element when the binding
   is applied. The contents of the shadow tree augment the bound element's
   standard presentation and interactive behaviour with alternate
   behaviour.

  <p>The <dfn id="shadow11">shadow template</dfn> is the cloned content
   template for a single binding applied to a bound element. The shadow
   tree is attached to the bound element. Once attached, the shadow tree
   can be accessed only via XBL-specific DOM extensions and therefore is
   not accessible via Core DOM navigation facilities such as
   <code>firstChild</code> or <code>nextSibling</code>.  (See: <span><a
   href="#dom-interfaces1">DOM interfaces</a></span>.)

  <p>The <dfn id="shadow5">shadow tree</dfn> for a bound element is the
   combined shadow templates that are attached to a bound element from one
   or bindings. The shadow tree is hidden from normal DOM processing (hence
   the name "shadow").

  <p>The term <dfn id="shadow6" title="">shadow content</dfn> refers to the
   various nodes in the shadow tree of a bound element. Shadow content is
   created by cloning a <span><a href="#shadow7">content
   template</a></span> during binding attachment. (See: <span><a
   href="#shadow8">shadow content</a></span>.)

  <p>In this specification, the term <dfn id="in-error">in error</dfn>,
   typically used of an element or attribute, means that the element,
   attribute, or other construct is not conformant according to the rules of
   this specification. Rules for exactly how the element, attribute, etc,
   must be treated when it is in error are always given when the term is
   used. Typically this will involve <dfn id="ignoring"
   title="ignore">ignoring</dfn> the erroneous nodes, meaning the UA must,
   <em>for the purposes of XBL processing</em>, act as if those nodes were
   absent. UAs must not, however, remove such nodes from the DOM in order to
   ignore them. The nodes retain all their non-XBL semantics.

  <p>UAs should report all errors to users, although they may do this in an
   unobtrusive way, for example in an error console.

  <p>In addition to the error handling rules given in this specification, UAs
   may abort all processing when encountering an error.

  <p>A <dfn id="correct" title="correct">correct</dfn> element, attribute,
   value, or binding is one which is not <span><a href="#in-error">in
   error</a></span>.

  <p>The namespace of all the <dfn id="xbl-elements0">XBL elements</dfn> and
   <dfn id="xbl-global">XBL global attributes</dfn> must be: <code
   class="uri">http://www.mozilla.org/xbl2</code>

  <p>XBL elements are frequently referred to by just their local name in this
   specification. In real documents, they must be associated with the XBL
   namespace as per the rules given in the Namespaces in XML specification <a
   href="#refsXMLNS">[XMLNS]</a>.

  <p>For convenience, elements and attributes from specific namespaces are
   sometimes referred to simply in the form <code>prefix:localname</code>,
   without explicitly stating which namespace the prefix is bound to. When
   this occurs, readers should assume the following prefix declarations are
   in scope:

  <pre><!--xmlns="http://www.mozilla.org/xbl2"
-->xmlns:xbl="http://www.mozilla.org/xbl2"
xmlns:xforms="http://www.w3.org/2002/xforms"
xmlns:ev="http://www.w3.org/2001/xml-events"
xmlns:xlink="http://www.w3.org/1999/xlink"
xmlns:html="http://www.w3.org/1999/xhtml"</pre>

  <p>All element names, attribute names, and attribute values in XBL are case
   sensitive.

  <p>An <dfn id="xml-mime">XML MIME type</dfn> is <code>text/xml</code>,
   <code>application/xml</code>, or any MIME type ending with the string
   <code>+xml</code> (ignoring any MIME parameters).

  <h3 id="conformance"><span class="secno">1.2. </span>Conformance</h3>

  <p>As well as sections marked as non-normative, all diagrams, examples, and
   notes in this specification are non-normative. Everything else in this
   specification is normative.

  <p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the
   normative parts of this document are to be interpreted as described in <a
   href="#refsRFC2119">[RFC2119]</a>. For readability, these words do not
   appear in all uppercase letters in this specification.

  <p>User agents may optimise any algorithm given in this specification, so
   long as the end result is indistinguishable from the result that would be
   obtained by the specification's algorithms. (The algorithms in this
   specification are generally written with more concern over clarity than
   over efficiency.)

  <p><span>XBL subtrees</span> must satisfy the constraints described in this
   specification.

  <p>XBL user agent implementations must behave as described by this
   specification, even when faced with non-conformant XBL subtrees.

  <p>This specification is defined in terms of the DOM. The language in this
   specification assumes that the user agent expands all entity references,
   and therefore not include entity reference nodes in the DOM. If user
   agents do include entity reference nodes in the DOM, then user agents must
   handle them as if they were fully expanded when implementing this
   specification. For example, if a requirement talks about an element's
   child text nodes, then any text nodes that are children of an entity
   reference that is a child of that element must be used as well.

  <h4 id="attributes"><span class="secno">1.2.1. </span><dfn
   id="attributes15" title="selector">Attributes Containing Selectors</dfn></h4>

  <p>The <code title="attr-binding-element"><a
   href="#element">element</a></code> attribute of the <code><a
   href="#binding11">binding</a></code> element and the <code
   title="attr-content-includes"><a href="#includes">includes</a></code>

   attribute of the <code><a href="#content0">content</a></code> element, if
   specified, must be parsed according to the rules in the Selectors
   specification. <a href="#refsSELECTORS">[SELECTORS]</a>

  <p>This specification does not specify what level of Selectors support is
   required.

  <p>Namespace prefixes can be used with selectors. In XBL attributes that
   take selectors, the namespace prefixes that may be used are the prefixes
   that are in scope using the <code>xmlns:*</code> syntax. User agents must
   use the XML namespace prefixes in scope on the attribute's element when
   parsing selectors with namespace prefixes. The default namespace in
   selectors in XBL attributes is always unbound ("*"). <a
   href="#refsXMLNS">[XMLNS]</a>

  <h4 id="attributes0"><span class="secno">1.2.2. </span><dfn
   id="attributes16" title="space-separated">Attributes Containing
   Space-Separated Values</dfn></h4>

  <p>Some attributes are defined as taking space-separated values. The list
   of values for such attributes must be obtained by taking the attribute's
   value, replacing any sequences of U+0020, U+000A, and U+000D characters
   (in any order) with a single U+0020 SPACE character, dropping any leading
   or trailing U+0020 SPACE character, and then chopping the resulting string
   at each occurance of a U+0020 character, dropping that character in the
   process.

  <p>A space-separated attribute whole value is either the empty string or
   that consists of only U+0020, U+000A, and U+000D characters has no values.

  <h2 id="xbl-elements"><span class="secno">2. </span>XBL Elements</h2>

  <p>The start of any XBL subtree is an <code><a href="#xbl0">xbl</a></code>
   element, which is described below.

  <p>When an XBL element is found inside an element other than that listed as
   its "Expected context", it is <span><a href="#in-error">in
   error</a></span>. When an XBL element has a child node that does not
   satisfy the "Expected children" list in its definition (for instance
   because it is the wrong node type, wrong element type, or because too many
   elements of its type preceded it), the child is <span><a
   href="#in-error">in error</a></span>. In both cases, being <span><a
   href="#in-error">in error</a></span> means that the UA must, for the
   purposes of XBL evaluation, treat the XBL subtree as it would if the
   erroneous node and all its descendants were absent.

  <p>However, non-XBL elements retain their semantics, even when considered
   to be <span><a href="#in-error">in error</a></span> for the purposes of
   XBL.

  <p>For cases where unexpected attributes are found on XBL elements, or XBL
   attributes are found on elements other than those listed as the "Expected
   context", the error handling is similar: the attributes must be considered
   to be <span><a href="#in-error">in error</a></span> and the UA must
   <span><a href="#ignoring">ignore</a></span> them, meaning that the
   presence of unexpected attributes in no way affects the XBL processing.

  <p>Further error handling rules for more specific cases are given where
   appropriate.

  <p>XBL user agents should act as if they had the following rules in their
   UA stylesheet:

  <pre>@namespace xbl url(http://www.mozilla.org/xbl2);
xbl|* { display: none; }

</pre>

  <p>That is to say, XBL elements should not be rendered.

  <h3 id="the-xbl"><span class="secno">2.1. </span>The <dfn
   id="xbl0">xbl</dfn> Element</h3>

  <dl>
   <dt>Expected contexts:

   <dd>In an XBL document, none (this is the root element).

   <dd>In a compound document, any non-XBL element whose specification allows
    the <code><a href="#xbl0">xbl</a></code> element as a child.

   <dt>Expected children (in any order):

   <dd><code><a href="#binding11">binding</a></code>: zero or more.

   <dd><code><a href="#script2">script</a></code>: zero or more.

   <dd>Any non-XBL element.
  </dl>

  <p>The <code><a href="#xbl0">xbl</a></code> element is the root element of
   all XBL subtrees.

  <h4 class="no-toc no-num" id="attributes1">Attributes</h4>

  <dl>
   <dt><dfn id="id0" title="attr-xbl-id">id</dfn>

   <dd>The <span title="attr-id"><a href="#id12"><code>id</code>

    attribute</a></span>.

   <dt><dfn id="script-type" title="attr-xbl-script-type">script-type</dfn>

   <dd>The <code title="attr-xbl-script-type"><a
    href="#script-type">script-type</a></code> attribute specifies the MIME
    type of the scripting language used by all bindings and XBL script blocks
    in the XBL subtree. If the attribute is not specified, the default
    language is ECMAScript<!-- XXX MIME type? -->. <a
    href="#refsECMA262">[ECMA262]</a>

   <dt><dfn id="style-type" title="attr-xbl-style-type">style-type</dfn>

   <dd>The <code title="attr-xbl-style-type"><a
    href="#style-type">style-type</a></code> attribute specifies the MIME
    type of the styling language used by all bindings and XBL style blocks in
    the XBL subtree. If the attribute is not specified, the default language
    is CSS (<code class="mimetype">text/css</code>).
  </dl>

  <p>UAs must consider any <code><a href="#xbl0">xbl</a></code> elements that
   have another <code><a href="#xbl0">xbl</a></code> element as an ancestor
   as being <span><a href="#in-error">in error</a></span> and must then
   <span><a href="#ignoring">ignore</a></span> them, meaning those elements
   must never be considered to declare any bindings. For example, UAs must
   never bind elements to bindings defined by <code><a
   href="#binding11">binding</a></code> elements that have two <code><a
   href="#xbl0">xbl</a></code> ancestors.

  <p>Similarly, XBL elements (other than the <code><a
   href="#xbl0">xbl</a></code> element itself) that do not have a <span><a
   href="#correct">correct</a></span> <code><a href="#xbl0">xbl</a></code>

   element as an ancestor are <span><a href="#in-error">in error</a></span>
   too, and UAs must <span><a href="#ignoring">ignore</a></span> them,
   treating them as they would any arbitrary semantic-free XML element. For
   example, UAs must never bind elements to bindings defined by <code><a
   href="#binding11">binding</a></code> elements that have no <code><a
   href="#xbl0">xbl</a></code> ancestors at all.

  <p>The same does not apply to the <code title="attr-xbl-style-type"><a
   href="#style-type">style-type</a></code> and <code
   title="attr-xbl-script-type"><a href="#script-type">script-type</a></code>

   attributes. If the UA does not support the specified styling language, it
   must still apply bindings as appropriate; only <code><a
   href="#style0">style</a></code> blocks must be ignored. Similarly, if the
   UA does not support the specified scripting language, it must still apply
   bindings as appropriate; only <code><a href="#script2">script</a></code>,
   <code><a href="#handler0">handler</a></code> and <code><a
   href="#implementation0">implementation</a></code> sections must be
   ignored.

  <h3 id="the-binding"><span class="secno">2.2. </span>The <dfn
   id="binding11">binding</dfn> Element</h3>

  <dl>
   <dt>Expected context:

   <dd><code><a href="#xbl0">xbl</a></code>

   <dt>Expected children (in any order), if the <code
    title="attr-binding-ref"><a href="#ref">ref</a></code> attribute is not
    specified:

   <dd><code><a href="#implementation0">implementation</a></code>: zero or
    one.

   <dd><code><a href="#template0">template</a></code>: zero or one.

   <dd><code><a href="#handlers0">handlers</a></code>: zero or one.

   <dd><code><a href="#resources1">resources</a></code>: zero or one.

   <dd>Any non-XBL element

   <dt>Expected children (in any order), if the <code
    title="attr-binding-ref"><a href="#ref">ref</a></code> attribute
    <em>is</em> specified:

   <dd>None.
  </dl>

  <p>The <code><a href="#binding11">binding</a></code> element describes a
   single XBL binding that adds presentation and interactive behaviour to XML
   or HTML elements. Each binding has these optional components:

  <p><em title="implementation"><a href="#implementation0">Methods,
   Properties, and Fields</a></em>: A binding can specify additional methods
   that can be invoked on the element. It can also specify additional
   properties and fields that can be retrieved or set on the element. In this
   way the functionality of the bound element becomes extensible. (See:
   <span><a href="#binding15">binding implementations</a></span>.)

  <p><em><a href="#template0">Template</a></em>: The optional <code><a
   href="#template0">template</a></code> defines the <em><a
   href="#content1">content template</a></em> for the bound element.

  <p><em title="handlers"><a href="#handlers0">Behaviour</a></em>: A binding
   can define event listeners for various types of events. Some examples are:
   UI events (e.g., key and mouse events) on the bound element or on elements
   within the shadow content; mutation events on the bound element and its
   descendants; and events having to do with XBL's binding operations (e.g.,
   the <code title="prebind">binding</code> and <code>bound</code> events).
   (See: <span><a href="#event9">event handlers</a></span>.)

  <p><em><a href="#resources1">Resources</a></em>: A binding can list
   stylesheets that are scoped to the bound element, and images, sounds,
   videos, or other files that a user agent can pre-cache in order to improve
   performance. (See: <span><a href="#binding14">binding
   stylesheets</a></span>, <span>prefetching resources</span>.)

  <p>Alternatively, a binding may reference an existing binding, with the
   <code title="attr-binding-ref"><a href="#ref">ref</a></code> attribute. In
   this case, the <code title="attr-binding-ref"><a
   href="#ref">ref</a></code> attribute must reference a <code><a
   href="#binding11">binding</a></code> element which in turn supplies the
   binding definition.

  <p>Bindings may also act as an attachment mechanism, specifying a namespace
   and local name of elements to associate with the given binding when the
   binding is <span title="importing">imported</span>, using the <code
   title="attr-binding-element"><a href="#element">element</a></code>
   attribute.

  <p>In addition to the above, the <code><a
   href="#binding11">binding</a></code> element may contain any element
   outside the XBL namespace. These are handled as they would be in any other
   context, and are ignored by the XBL processing model.

  <h4 class="no-toc no-num" id="attributes2">Attributes</h4>

  <dl>
   <dt><dfn id="id1" title="attr-binding-id">id</dfn>

   <dd>The <span title="attr-id"><a href="#id12"><code>id</code>

    attribute</a></span>.

   <dt><dfn id="ref" title="attr-binding-ref">ref</dfn>

   <dd>
    <p>This attribute specifies a URI to use to find the binding instead of
     looking inside the <code><a href="#binding11">binding</a></code> element
     itself. (See: <span><a href="#interpretation1">interpretation of URIs to
     XBL bindings</a></span>.)</p>

    <p>When a <code><a href="#binding11">binding</a></code> element has a
     <code title="attr-binding-ref"><a href="#ref">ref</a></code> attribute,
     the UA must fetch the specified resource (unless it has <span
     title="loading external resources"><a href="#loading5">already been
     loaded</a></span>).</p>

    <p>If the URI references a <code><a href="#binding11">binding</a></code>
     element, and that element does not have a <code
     title="attr-binding-ref"><a href="#ref">ref</a></code> attribute, then
     for the purposes of the rest of the XBL processing model, the element
     with the <code title="attr-binding-ref"><a href="#ref">ref</a></code>

     attribute is treated as if it had the children nodes and the <code
     title="xbl-binding-extends">extends</code> attribute of the element to
     which it refers.</p>

    <p>If the URI does not reference a <code><a
     href="#binding11">binding</a></code> element, it is <span><a
     href="#in-error">in error</a></span> and must be <span>ignored</span>.</p>

    <p>The referenced <code><a href="#binding11">binding</a></code> element
     cannot have a <code title="attr-binding-ref"><a
     href="#ref">ref</a></code> attribute (i.e., only one level of
     indirection is allowed); otherwise, the original <code><a
     href="#binding11">binding</a></code> element is <span><a
     href="#in-error">in error</a></span> and must also be
     <span>ignored</span>.</p>

   <dt><dfn id="extends" title="attr-binding-extends">extends</dfn>

   <dd>The <code title="attr-binding-extends"><a
    href="#extends">extends</a></code> attribute is used to specify the URI
    of a binding that this binding inherits from. (See: <span><a
    href="#interpretation1">interpretation of URIs to XBL
    bindings</a></span>.) If the URI is in error or does not refer to another
    binding, the UA must <span><a href="#ignoring">ignore</a></span> it,
    meaning that this binding does not explicitly inherit from another
    binding. If the element has a <code title="attr-binding-ref"><a
    href="#ref">ref</a></code> attribute, then the <code
    title="attr-binding-extends"><a href="#extends">extends</a></code>
    attribute is <span><a href="#in-error">in error</a></span> and must be
    <span>ignored</span>.

   <dt><dfn id="element" title="attr-binding-element">element</dfn>

   <dd>
    <p>This attribute specifies a <span><a
     href="#attributes15">selector</a></span>. All elements in the binding
     document, and in any documents that <span
     title="importing">import</span> the binding document, that <span
     title="selectors and shadow scopes"><a href="#selectors1">match the
     given selector</a></span>, must be bound to the binding defined by this
     <code><a href="#binding11">binding</a></code> element. (The element's
     own shadow tree, if any, must not be taken into account when determining
     if it matches a selector for the purposes of this attribute.)</p>

    <p>If an <code title="attr-binding-element"><a
     href="#element">element</a></code> attribute contains an invalid
     selector, it is <span><a href="#in-error">in error</a></span> and must
     be <span>ignored</span>, meaning that while the binding is still parsed
     and may be referenced using other attachment mechanisms, the binding is
     not attached to any element by its <code title="attr-binding-element"><a
     href="#element">element</a></code> attribute, as if the attribute had
     simply been omitted.</p>
  </dl>

  <p>If a <code><a href="#binding11">binding</a></code> element contains both
   a <code title="attr-binding-ref"><a href="#ref">ref</a></code> attribute
   and has child nodes other than comment nodes or whitespace text nodes,
   then it is <span><a href="#in-error">in error</a></span>, and the contents
   of the element must all be ignored for the purposes of XBL processing.

  <p class="note">The <code><a href="#binding11">binding</a></code> element
   defines a presentation and behaviour binding. It does not define an
   element's semantics. If an element has no semantics when processed alone,
   then it has no semantics when processed with XBL.

  <h3 id="the-implementation"><span class="secno">2.3. </span>The <dfn
   id="implementation0">implementation</dfn> Element</h3>

  <dl>
   <dt>Expected context:

   <dd><code><a href="#binding11">binding</a></code>

   <dt>Expected children:

   <dd>Depends on the scripting language.
  </dl>

  <p>The <code><a href="#implementation0">implementation</a></code> element
   describes a set of methods, properties, and fields that are attached to
   the bound element. Once the binding is attached, these methods,
   properties, and fields can be invoked directly from the bound element.

  <p>The <code><a href="#implementation0">implementation</a></code> element,
   if present, must either contain code in the language specified by the XBL
   subtree's <code title="attr-xbl-script-type"><a
   href="#script-type">script-type</a></code> attribute, or have a <code
   title="attr-implementation-src"><a href="#src">src</a></code> attribute
   that points to a resource containing code in the language specified by the
   <code title="attr-xbl-script-type"><a
   href="#script-type">script-type</a></code> attribute. The syntax and
   semantics of this code depend on the specific language. This specification
   defines the semantics for <span title="ECMAScript binding for
   XBL">ECMAScript implementations</span>. (See: <span><a
   href="#binding15">binding implementations</a></span>.)

  <h4 class="no-toc no-num" id="attributes3">Attributes</h4>

  <dl>
   <dt><dfn id="id2" title="attr-implementation-id">id</dfn>

   <dd>The <span title="attr-id"><a href="#id12"><code>id</code>
    attribute</a></span>.

   <dt><dfn id="name" title="attr-implementation-name">name</dfn>

   <dd>The <code title="attr-implementation-name"><a
    href="#name">name</a></code> attribute can be used to provide a specific
    name for an implementation. This name can then be used to reference the
    implementation. For example, in ECMAScript the value of this attribute
    represents the name of the corresponding class that is constructed for
    the implementation. If no name attribute is specified, or if it is
    specified but empty, then the binding's document URI and ID (if any) are
    used to uniquely reference the binding's implementation.

   <dt><dfn id="src" title="attr-implementation-src">src</dfn>

   <dd>The <code title="attr-implementation-src"><a
    href="#src">src</a></code> attribute specifies the URI to a resource of
    the type given by the XBL subtree's <code title="attr-xbl-script-type"><a
    href="#script-type">script-type</a></code> attribute. If the attribute is
    specified, the contents of the element must be ignored (even if the
    resource could not be fetched or was of the wrong type). (See: <span><a
    href="#binding15">binding implementations</a></span>.)
  </dl>

  <p>If an <code><a href="#implementation0">implementation</a></code> element
   is marked (via the <code title="attr-xbl-script-type"><a
   href="#script-type">script-type</a></code> attribute of the <code><a
   href="#xbl0">xbl</a></code> element) as being in a language that the UA
   does not support, or, if the <code><a
   href="#implementation0">implementation</a></code> element points (using
   the <code title="attr-implementation-src"><a href="#src">src</a></code>
   attribute) to a resource that is either unavailable, or not of the type
   specified by the <code title="attr-xbl-script-type"><a
   href="#script-type">script-type</a></code> attribute of the <code><a
   href="#xbl0">xbl</a></code> element, then it is <span><a
   href="#in-error">in error</a></span> and the UA must <span><a
   href="#ignoring">ignore</a></span> it, meaning it must not be used as an
   implementation definition for any binding.

  <p>How UAs must handle nodes inside <code><a
   href="#implementation0">implementation</a></code> elements depends on the
   language used. (See: <span><a href="#loading6">loading and running
   scripts</a></span>, <span><a href="#binding15">binding
   implementations</a></span>.)

  <p><code><a href="#implementation0">implementation</a></code> blocks must
   be evaluated when their binding is attached. Once a binding is attached,
   changes to the <code><a href="#implementation0">implementation</a></code>

   element have no effect on that binding. If an <code><a
   href="#implementation0">implementation</a></code> element is changed,
   however, it shall affect bindings that are attached after the change.

  <p>User agents may support an additional attribute with the name
   <code><var>vendor</var>-binary</code> (e.g. <code>moz-binary=""</code> or
   <code>khtml-binary=""</code>) that contains information on native code
   implementations of the binding, if necessary.

  <h3 id="the-template"><span class="secno">2.4. </span>The <dfn
   id="template0">template</dfn> Element</h3>

  <dl>
   <dt>Expected context:

   <dd><code><a href="#binding11">binding</a></code>

   <dt>Expected children:

   <dd>Anything. Of particular interest, the <code><a
    href="#element0">element</a></code>, <code><a
    href="#content0">content</a></code>, and <code><a
    href="#inherited0">inherited</a></code> elements may occur as
    descendants, and non-XBL descendant elements may host <code
    title="attr-inherits"><a href="#xblinherits0">xbl:inherits</a></code>
    and <code title="attr-pseudo"><a
    href="#xblpseudo0">xbl:pseudo</a></code> attributes.
  </dl>

  <p>The <code><a href="#template0">template</a></code> element contains
   child nodes that can be in any namespace. The subtree specified by the
   <code><a href="#template0">template</a></code> element is referred to as
   the <dfn id="shadow7">content template</dfn>. When a binding is
   attached, the <code><a href="#template0">template</a></code> element and
   its child nodes are cloned and attached to the bound document in place
   of the bound element (where they are accessible via the <code><a
   href="#xblgetshadowtemplate">xblGetShadowTemplate</a></code> DOM
   property). Because these cloned nodes are hidden from their parent and
   exist outside the normal document tree, they are referred to as <span><a
   href="#shadow8">shadow content</a></span>. (See: <span><a
   href="#rules3">rules for shadow content generation</a></span>.)

  <p>If a <code><a href="#template0">template</a></code> element is
   not included in a binding, the default template shall be applied
   which consist of a single <code><a
   href="#element0">element</a></code> element.

  <h4 class="no-toc no-num" id="attributes4">Attributes</h4>

  <dl>
   <dt><dfn id="id3" title="attr-template-id">id</dfn>

   <dd>The <span title="attr-id"><a href="#id12"><code>id</code>
    attribute</a></span>.

   <dt><dfn id="apply-author-sheets"
    title="attr-template-apply-author-sheets">apply-author-sheets</dfn>

   <dd>The <code title="attr-template-apply-author-sheets"><a
    href="#apply-author-sheets">apply-author-sheets</a></code> attribute
    indicates whether or not rules in author stylesheets associated with the
    bound element's document apply to the shadow content generated by the
    binding. Its value must be either <code>true</code> (indicating that they
    do) or <code>false</code> (indicating that they do not). The default
    behaviour, which is used when the attribute is omitted or has a value
    other than the two allowed values, is to not apply the bound document's
    author stylesheets (same as <code>false</code>). (See: <span><a
    href="#binding14">binding stylesheets</a></span>.)

   <dt><dfn id="allow-selectors-through"
    title="attr-template-allow-selectors-through">allow-selectors-through</dfn>

   <dd>The <code title="attr-template-allow-selectors-through"><a
    href="#allow-selectors-through">allow-selectors-through</a></code>
    attribute indicates whether or not rules in CSS can cross scopes. Its
    value must be either <code>true</code> (indicating that they can) or
    <code>false</code> (indicating that they cannot). The default behaviour,
    which is used when the attribute is omitted or has a value other than the
    two allowed values, is to not let selectors cross scopes (same as
    <code>false</code>). (See: <span><a href="#binding14">binding
    stylesheets</a></span>

  </dl>

  <p class="note">The semantics of non-XBL elements inside this element are
   untouched, which can lead to unintuitive results. (See: <span><a
   href="#shadow10">semantics of non-XBL elements in XBL
   contexts</a></span>.)

  <h3 id="the-element"><span class="secno">2.5. </span>The <dfn id="element0">element</dfn> Element</h3>

  <dl>
   <dt>Expected context:

   <dd>Any, but there must be a <span><a href="#correct">correct</a></span>
    <code><a href="#template0">template</a></code> element somewhere in the
    ancestor chain, there may not be more than one <code><a
    href="#element0">element</a></code> element within a <code><a
    href="#template0">template</a></code>, and there must not be any
    <span><a href="#correct">correct</a> <code><a
    href="#content0">content</a></node> elements anywhere in the ancestor
    chain.

   <dt>Expected children:

   <dd>Anything.
  </dl>

  <p>The <code><a href="#element0">element</a></code> element is used
   inside <span><a href="#shadow8">shadow content</a></span> to specify the
   insertion point for the bound element within the shadow content
   structure. As far as the presentation model is concerned, any shadow
   content the binding places between the template element and the <code><a
   href="#element0">element</a></code> element is interleaved between the
   bound element and its <span><a href="#explicit">explicit
   parent</a></span> without affecting the document model. (See: <span><a
   href="#processing2">processing <code title="">content</code>
   elements</a></span>.) If no <code><a
   href="#element0">element</a></code> element is present within a template,
   the bound element is not present in the final flattened tree.

  <h3 id="the-content"><span class="secno">2.6. </span>The <dfn
   id="content0">content</dfn> Element</h3>

  <dl>
   <dt>Expected context:

   <dd>Any, but there must be a <span><a href="#correct">correct</a></span>

    <code><a href="#template0">template</a></code> element somewhere in the
    ancestor chain, and there must not be any <span><a
    href="#correct">correct</a></span> <code><a
    href="#content0">content</a></code> elements anywhere in the ancestor
    chain.

   <dt>Expected children:

   <dd>Anything.
  </dl>

  <p>The <code><a href="#content0">content</a></code> element is used inside
   <span><a href="#shadow8">shadow content</a></span> to specify insertion
   points for <span><a href="#explicit">explicit children</a></span> that
   might already exist underneath the bound element. As far as the
   presentation model is concerned, any shadow content the binding places
   between the bound element and the <code><a
   href="#content0">content</a></code> elements is interleaved between the
   bound element and its <span><a href="#explicit">explicit
   children</a></span> without affecting the document model. (See: <span><a
   href="#processing2">processing <code title="">content</code>
   elements</a></span>.)

  <p>If the <code title="attr-content-includes"><a
   href="#includes">includes</a></code> attribute successfully matches
   against children of the bound element, then those children are inserted
   into the <span><a href="#final">final flattened tree</a></span> in place
   of the <code><a href="#content0">content</a></code> element. If the <code
   title="attr-content-includes"><a href="#includes">includes</a></code>
   attribute does not match against any children, then the child elements of
   the <code><a href="#content0">content</a></code> element are inserted into
   the <span><a href="#final">final flattened tree</a></span> in place of the
   <code><a href="#content0">content</a></code> element instead.

  <h4 class="no-toc no-num" id="attributes5">Attributes</h4>

  <dl>
   <dt><dfn id="id4" title="attr-content-id">id</dfn>

   <dd>The <span title="attr-id"><a href="#id12"><code>id</code>
    attribute</a></span>.

   <dt><dfn id="includes" title="attr-content-includes">includes</dfn>

   <dd>The <code title="attr-content-includes"><a
    href="#includes">includes</a></code> attribute can be used to indicate
    that only certain content should be placed at the <code><a
    href="#content0">content</a></code> element. Its value is a <span><a
    href="#attributes15">selector</a></span>. (See: <span><a
    href="#processing2">processing <code title="">content</code>
    elements</a></span>.)

   <dt><dfn id="apply-binding-sheets"
    title="attr-content-apply-binding-sheets">apply-binding-sheets</dfn>

   <dd>The <code title="attr-content-apply-binding-sheets"><a
    href="#apply-binding-sheets">apply-binding-sheets</a></code> attribute
    indicates whether or not scoped stylesheets loaded for an XBL binding are
    applied to a bound element's <span><a href="#explicit">explicit
    children</a></span> (in addition to the bound element itself) that are
    inserted below this <code><a href="#content0">content</a></code> element
    when it is processed. Its value must be either <code>true</code>
    (indicating that they are) or <code>false</code> (indicating that they
    are not). The default behaviour, which is used when the attribute is
    omitted or has a value other than the two allowed values, is that they
    are not applied (same as <code>false</code>). (See: <span><a
    href="#binding14">binding stylesheets</a></span>.)

   <dt><dfn id="locked" title="attr-content-locked">locked</dfn>

   <dd>The <code title="attr-content-locked"><a
    href="#locked">locked</a></code> attribute indicates whether or not new
    children may be inserted below this <code><a
    href="#content0">content</a></code> element when it is processed. Its
    value must be either <code>true</code> (indicating that they may not) or
    <code>false</code> (indicating that they may). The default behaviour,
    which is used when the attribute is omitted or has a value other than the
    two allowed values, is that they may be inserted (same as
    <code>false</code>). Elements already assigned to a <code><a
    href="#content0">content</a></code> element whose <code
    title="attr-content-locked"><a href="#locked">locked</a></code> attribute
    is dynamically changed are not removed from that element. (See: <span><a
    href="#processing2">processing <code title="">content</code>

    elements</a></span>.)
  </dl>

  <h3 id="the-xblinherits"><span class="secno">2.7. </span>The <dfn
   id="xblinherits0" title="attr-inherits">xbl:inherits</dfn> Attribute</h3>

  <dl>
   <dt>Expected element:

   <dd>Any, but there must be a <span><a href="#correct">correct</a></span>
    <code><a href="#template0">template</a></code> element somewhere in the
    ancestor chain.
  </dl>

  <p>The <code title="attr-inherits"><a
   href="#xblinherits0">xbl:inherits</a></code> attribute is a global
   attribute in the XBL namespace that specifies which attributes on the
   bound element should be forwarded to the element on which the attribute is
   found when the content template is cloned. It is a <span><a
   href="#attributes16">space-separated</a></span> list of QNames or QName
   pairs separated by equal signs, each possibly suffixed by a hash character
   ("#") and a type designation. (See: <span><a href="#attribute1">attribute
   forwarding</a></span>.)

  <h3 id="the-xblpseudo"><span class="secno">2.8. </span>The <dfn
   id="xblpseudo0" title="attr-pseudo">xbl:pseudo</dfn> Attribute</h3>

  <dl>
   <dt>Expected element:

   <dd>Any, but there must be a <span><a href="#correct">correct</a></span>
    <code><a href="#template0">template</a></code> element somewhere in the
    ancestor chain.
  </dl>

  <p>The <code title="attr-pseudo"><a
   href="#xblpseudo0">xbl:pseudo</a></code> attribute is a global attribute
   in the XBL namespace that specifies the pseudo-element that, when used on
   the bound element, must be mapped to the element on which the attribute is
   found. (See: <span><a href="#matching1">matching
   pseudo-elements</a></span>.)

  <h3 id="the-handlers"><span class="secno">2.9. </span>The <dfn
   id="handlers0">handlers</dfn> Element</h3>

  <dl>
   <dt>Expected context:

   <dd><code><a href="#binding11">binding</a></code>

   <dt>Expected children:

   <dd><code><a href="#handler0">handler</a></code>: zero or more.
  </dl>

  <p>The <code><a href="#handlers0">handlers</a></code> element's event
   handlers can be called for events that flow through the bound element.
   During capture, target and bubbling phases, when a given event is received
   by a bound element, if a corresponding event listener has been attached to
   the <code><a href="#handlers0">handlers</a></code> element, then the event
   will be <span title="event forwarding"><a
   href="#event10">forwarded</a></span> to that event listener. (See:
   <span><a href="#event10">event forwarding</a></span>, <span><a
   href="#binding12">binding attachment and detachment</a></span>.)

  <p>Typically, event handlers are defined using <code><a
   href="#handler0">handler</a></code> elements.

  <h4 class="no-toc no-num" id="attributes7">Attributes</h4>

  <dl>
   <dt><dfn id="id6" title="attr-handlers-id">id</dfn>

   <dd>The <span title="attr-id"><a href="#id12"><code>id</code>
    attribute</a></span>.
  </dl>

  <h3 id="the-handler"><span class="secno">2.10. </span>The <dfn
   id="handler0">handler</dfn> Element</h3>

  <dl>
   <dt>Expected context:

   <dd><code><a href="#handlers0">handlers</a></code>

   <dt>Expected children:

   <dd>Depends on the scripting language.
  </dl>

  <p>The <code><a href="#handler0">handler</a></code> element describes a
   single event handler. This handler is attached to its parent <code><a
   href="#handlers0">handlers</a></code> element, which is used as an event
   forwarding target when handling events on the bound element. (See:
   <span><a href="#event9">event handlers</a></span>.) It wraps a script that
   is executed when the event handler is matched.

  <h4 class="no-toc no-num" id="attributes8">Attributes</h4>

  <dl>
   <dt><dfn id="id7" title="attr-handler-id">id</dfn>

   <dd>The <span title="attr-id"><a href="#id12"><code>id</code>
    attribute</a></span>.

   <dt><dfn id="event7" title="attr-handler-event">event</dfn>

   <dd>The <code title="attr-handler-event"><a
    href="#event7">event</a></code> attribute describes the specific event
    that this handler is listening for. (See: <span><a
    href="#registering1">registering event handlers with the
    <code>handler</code> element</a></span>.)

   <dt><dfn id="phase" title="attr-handler-phase">phase</dfn>

   <dd>This attribute specifies the phase of the event flow that this handler
    should monitor. The possible values are <code>capture</code> and
    <code>default</code>. If <code>capture</code> is specified, then the
    event handler must only be fired during the capturing phase of event
    propagation. Otherwise, the handler must only be fired during the target
    and bubbling phases. (See: <span><a href="#registering1">registering
    event handlers with the <code>handler</code> element</a></span>.)

   <dt><dfn id="trusted" title="attr-handler-trusted">trusted</dfn>

   <dd>This attribute specifies whether the handler should be limited to
    trusted events. The possible values are <code>true</code> and
    <code>false</code>. If <code>true</code> is specified, then the event
    handler must only be fired if the event's <code><a
    href="#trusted0">trusted</a></code> attribute is true. Otherwise, the
    value of the <code><a href="#trusted0">trusted</a></code> flag does not
    affect the event handler. (See: <span><a href="#registering1">registering
    event handlers with the <code>handler</code> element</a></span>.)

   <dt><dfn id="propagate" title="attr-handler-propagate">propagate</dfn>

   <dd>The <code title="attr-handler-propagate"><a
    href="#propagate">propagate</a></code> attribute specifies whether after
    processing all listeners at the current node, the event is allowed to
    continue on its path (either in the capture or the bubble phase). (See:
    <span><a href="#registering1">registering event handlers with the
    <code>handler</code> element</a></span>.)

   <dt><dfn id="default-action"
    title="attr-handler-default-action">default-action</dfn>

   <dd>The <code title="attr-handler-default-action"><a
    href="#default-action">default-action</a></code> attribute specifies
    whether after processing of all listeners for the event, the default
    action for the event (if any) should be performed or not. (See: <span><a
    href="#registering1">registering event handlers with the
    <code>handler</code> element</a></span>.)

   <dt><dfn id="button" title="attr-handler-button">button</dfn>

   <dd>The <code title="attr-handler-button"><a
    href="#button">button</a></code> attribute imposes a <em>filter</em> on
    the handler. It is used with mouse handlers to specify a particular
    button. (See: <span><a href="#mouse1">mouse event handler
    filters</a></span>.)

   <dt><dfn id="click-count"
    title="attr-handler-click-count">click-count</dfn>

   <dd>The <code title="attr-handler-click-count"><a
    href="#click-count">click-count</a></code> attribute imposes a
    <em>filter</em> on the handler. It is used with mouse handlers to specify
    how many clicks must have occured. (See: <span><a href="#mouse1">mouse
    event handler filters</a></span>.)

   <dt><dfn id="modifiers1" title="attr-handler-modifiers">modifiers</dfn>

   <dd>The <code title="attr-handler-modifiers"><a
    href="#modifiers1">modifiers</a></code> attribute imposes a filter on key
    and mouse handlers. It is used with mouse and key handlers to specify
    particular modifier keys. (See: <span><a href="#mouse1">mouse event
    handler filters</a></span>, <span><a href="#key-event1">key event handler
    filters</a></span>, <span><a href="#modifiers2">modifiers</a></span>.)

   <dt><dfn id="key" title="attr-handler-key">key</dfn>

   <dd>The <code title="attr-handler-key"><a href="#key">key</a></code>

    attribute imposes a filter on key handlers. It is used with key handlers
    to specify which keys to listen for. (See: <span><a
    href="#key-event1">key event handler filters</a></span>.)

   <dt><dfn id="key-location"
    title="attr-handler-key-location">key-location</dfn>

   <dd>The <code title="attr-handler-key-location"><a
    href="#key-location">key-location</a></code> attribute imposes a filter
    on key handlers. It is used with key handlers to specify which keys to
    listen for. (See: <span><a href="#key-event1">key event handler
    filters</a></span>.)

   <dt><dfn id="text" title="attr-handler-text">text</dfn>

   <dd>The <code title="attr-handler-text"><a href="#text">text</a></code>
    attribute imposes a filter on text input handlers. It is used with text
    input handlers to specify which characters to listen for. (See: <span><a
    href="#text-input1">text input event handler filters</a></span>.)

   <dt><dfn id="prev-value" title="attr-handler-prev-value">prev-value</dfn>

   <dd>The <code title="attr-handler-prev-value"><a
    href="#prev-value">prev-value</a></code> attribute imposes a filter on
    mutation handlers. It is used with mutation handlers to specify what
    <code>prev-value</code> to listen for. (See: <span><a
    href="#mutation1">mutation event handler filters</a></span>.)

   <dt><dfn id="new-value" title="attr-handler-new-value">new-value</dfn>

   <dd>The <code title="attr-handler-new-value"><a
    href="#new-value">new-value</a></code> attribute imposes a filter on
    mutation handlers. It is used with mutation handlers to specify what
    <code>new-value</code> to listen for. (See: <span><a
    href="#mutation1">mutation event handler filters</a></span>)

   <dt><dfn id="attr-name" title="attr-handler-attr-name">attr-name</dfn>

   <dd>The <code title="attr-handler-attr-name"><a
    href="#attr-name">attr-name</a></code> attribute imposes a filter on
    mutation handlers. It is used with attribute mutation handlers to specify
    what attribute to listen for changes for. (See: <span><a
    href="#mutation1">mutation event handler filters</a></span>)

   <dt><dfn id="attr-change"
    title="attr-handler-attr-change">attr-change</dfn>

   <dd>The <code title="attr-handler-attr-change"><a
    href="#attr-change">attr-change</a></code> attribute imposes a filter on
    mutation handlers. It is used with attribute mutation handlers to specify
    what type of change to listen for changes for. (See: <span><a
    href="#mutation1">mutation event handler filters</a></span>.)
  </dl>

  <p>If a <code><a href="#handler0">handler</a></code> element is marked (via
   the <code title="attr-xbl-script-type"><a
   href="#script-type">script-type</a></code> attribute of the <code><a
   href="#xbl0">xbl</a></code> element) as being in a language that the UA
   does not support then the UA must <span><a
   href="#ignoring">ignore</a></span> it, meaning it must not be used for the
   event handler definitions of any binding.

  <p>How UAs must handle nodes inside <code><a
   href="#handler0">handler</a></code> elements depends on the language used.
   (See: <span><a href="#loading6">loading and running scripts</a></span>,
   <span><a href="#event9">event handlers</a></span>.)

  <p><code><a href="#handler0">handler</a></code> blocks are evaluated each
   time they are fired. Changes to the <code><a
   href="#handler0">handler</a></code> elements therefore take effect the
   next time the an event is fired.

  <h3 id="the-resources"><span class="secno">2.11. </span>The <dfn
   id="resources1">resources</dfn> Element</h3>

  <dl>
   <dt>Expected context:

   <dd><code><a href="#binding11">binding</a></code>

   <dt>Expected children (in any order):

   <dd><code><a href="#style0">style</a></code>

   <dd><code><a href="#prefetch0">prefetch</a></code>
  </dl>

  <p>The <code><a href="#resources1">resources</a></code> element contains a
   list of stylesheets to apply when using this binding, as well as a list of
   files (images, videos, sound files, etc) to optionally preload.

  <h4 class="no-toc no-num" id="attributes9">Attributes</h4>

  <dl>
   <dt><dfn id="id8" title="attr-resources-id">id</dfn>

   <dd>The <span title="attr-id"><a href="#id12"><code>id</code>

    attribute</a></span>.
  </dl>

  <h3 id="the-style"><span class="secno">2.12. </span>The <dfn
   id="style0">style</dfn> Element</h3>

  <dl>
   <dt>Expected context:

   <dd><code><a href="#resources1">resources</a></code>

   <dt>Expected children:

   <dd>Depends on the styling language.
  </dl>

  <p>The <code><a href="#style0">style</a></code> element is used to specify
   a stylesheet that is to be applied to the bound element and to the shadow
   content generated by the binding, as well as to any <span><a
   href="#explicit">explicit children</a></span> (and their descendants)
   assigned to insertion points in the shadow content whose <code
   title="attr-content-apply-binding-sheets"><a
   href="#apply-binding-sheets">apply-binding-sheets</a></code> attribute is
   set.

  <h4 class="no-toc no-num" id="attributes10">Attributes</h4>

  <dl>
   <dt><dfn id="id9" title="attr-style-id">id</dfn>

   <dd>The <span title="attr-id"><a href="#id12"><code>id</code>
    attribute</a></span>.

   <dt><dfn id="media" title="attr-style-media">media</dfn>

   <dd>The <code title="attr-style-media"><a href="#media">media</a></code>
    attribute specifies the intended destination medium for style
    information. How the value of this attribute is interpreted is defined by
    Media Queries <a href="#refsMQ">[MQ]</a>. If this attribute is not
    specified, then there is no restriction on which media the stylesheet
    should be applied to (same as specifying <code>media="all"</code>).

   <dt><dfn id="src0" title="attr-style-src">src</dfn>

   <dd>The <code title="attr-style-src"><a href="#src0">src</a></code>

    attribute specifies the URI to a resource of the type given by the XBL
    subtree's <code title="attr-xbl-style-type"><a
    href="#style-type">style-type</a></code> attribute. If the attrbiute is
    specified, the contents of the element must be ignored (even if the
    resource could not be fetched or was of the wrong type). (See: <span><a
    href="#binding14">binding stylesheets</a></span>.)
  </dl>

  <p>If a <code><a href="#style0">style</a></code> element is marked (via the
   <code title="attr-xbl-style-type"><a
   href="#style-type">style-type</a></code> attribute of the <code><a
   href="#xbl0">xbl</a></code> element) as being in a language that the UA
   does not support, or, if the <code><a href="#style0">style</a></code>

   element points (using the <code title="attr-style-src"><a
   href="#src0">src</a></code> attribute) to a resource that is either
   unavailable, or not of the type specified by the <code
   title="attr-xbl-style-type"><a href="#style-type">style-type</a></code>
   attribute of the <code><a href="#xbl0">xbl</a></code> element, then it is
   <span><a href="#in-error">in error</a></span> and the UA must <span><a
   href="#ignoring">ignore</a></span> it, meaning it must not be used to
   style anything.

  <p>How UAs must handle nodes inside <code><a
   href="#style0">style</a></code> elements depends on the language used.
   (See: <span><a href="#binding14">binding stylesheets</a></span>.)

  <h3 id="the-prefetch"><span class="secno">2.13. </span>The <dfn
   id="prefetch0">prefetch</dfn> Element</h3>

  <dl>
   <dt>Expected context:

   <dd><code><a href="#resources1">resources</a></code>

   <dt>Expected children:

   <dd>None.
  </dl>

  <p>The <code><a href="#prefetch0">prefetch</a></code> element can be used
   to list resources that may be pre-loaded for performance reasons. Support
   for this element is optional. UAs may <span><a
   href="#ignoring">ignore</a></span> it.

  <h4 class="no-toc no-num" id="attributes11">Attributes</h4>

  <dl>
   <dt><dfn id="id10" title="attr-prefetch-id">id</dfn>

   <dd>The <span title="attr-id"><a href="#id12"><code>id</code>
    attribute</a></span>.

   <dt><dfn id="src1" title="attr-prefetch-src">src</dfn>

   <dd>A URI to a resource (such as an image) that the binding might use
    later.
  </dl>

  <h3 id="the-script"><span class="secno">2.14. </span>The <dfn
   id="script2">script</dfn> Element</h3>

  <dl>
   <dt>Expected context:

   <dd><code><a href="#xbl0">xbl</a></code>

   <dt>Expected children:

   <dd>Depends on the scripting language.
  </dl>

  <p>The <code><a href="#script2">script</a></code> element contains code
   that is executed when the XBL subtree is loaded. It can therefore be used
   to define helper functions used by the bindings.

  <p>The <code><a href="#script2">script</a></code> element, when present,
   must either contain code in the language specified by the XBL subtree's
   <code title="attr-xbl-script-type"><a
   href="#script-type">script-type</a></code> attribute, or have a <code
   title="attr-script-src"><a href="#src2">src</a></code> attribute that
   points to a resource containing code in the language specified by the
   <code title="attr-xbl-script-type"><a
   href="#script-type">script-type</a></code> attribute. The syntax and
   semantics of this code depend on the specific language. (See: <span><a
   href="#loading6">loading and running scripts</a></span>.)

  <h4 class="no-toc no-num" id="attributes12">Attributes</h4>

  <dl>
   <dt><dfn id="id11" title="attr-script-id">id</dfn>

   <dd>The <span title="attr-id"><a href="#id12"><code>id</code>
    attribute</a></span>.

   <dt><dfn id="src2" title="attr-script-src">src</dfn>

   <dd>The <code title="attr-script-src"><a href="#src2">src</a></code>
    attribute specifies the URI to a resource of the type given by the XBL
    subtree's <code title="attr-xbl-script-type"><a
    href="#script-type">script-type</a></code> attribute. If the attribute is
    specified, the contents of the element must be ignored (even if the
    resource could not be fetched or was of the wrong type). (See: <span><a
    href="#loading6">loading and running scripts</a></span>.)
  </dl>

  <p>If an <code><a href="#script2">script</a></code> element is marked (via
   the <code title="attr-xbl-script-type"><a
   href="#script-type">script-type</a></code> attribute of the <code><a
   href="#xbl0">xbl</a></code> element) as being in a language that the UA
   does not support, or, if the <code><a href="#script2">script</a></code>

   element points (using the <code title="attr-script-src"><a
   href="#src2">src</a></code> attribute) to a resource that is either
   unavailable, or not of the type specified by the <code
   title="attr-xbl-script-type"><a href="#script-type">script-type</a></code>
   attribute of the <code><a href="#xbl0">xbl</a></code> element, then it is
   <span><a href="#in-error">in error</a></span> and the UA must <span><a
   href="#ignoring">ignore</a></span> it, meaning it must not be executed.

  <p>How UAs must handle nodes inside <code><a
   href="#script2">script</a></code> elements depends on the language used.
   (See: <span><a href="#loading6">loading and running scripts</a></span>.)

  <p><code><a href="#script2">script</a></code> blocks must be evaluated when
   their end-tag is parsed, or, for dynamically created elements, when they
   are inserted into a document. Once evaluated, a <code><a
   href="#script2">script</a></code> block is dead and changes to its
   contents have no effect.

  <h3 id="the-id"><span class="secno">2.15. </span>The <dfn id="id12"
   title="attr-id">id</dfn> Attribute of XBL Elements</h3>

  <dl>
   <dt>Expected element:

   <dd>Any element in the XBL namespace.
  </dl>

  <p>The <code title="attr-id"><a href="#id12">id</a></code> attribute
   assigns a name to an element. This name must be unique in the <span><a
   href="#binding10">binding document</a></span>. The <code
   title="attr-id"><a href="#id12">id</a></code> attribute is of type ID. <a
   href="#refsXML">[XML]</a>.

  <p>If the attribute's value is the empty string, the element has no ID.
   Otherwise, the attribute's value must be treated as (one of) the element's
   ID(s).

  <h2 id="resources"><span class="secno">3. </span>Resources</h2>

  <h3 id="loading"><span class="secno">3.1. </span><dfn id="loading5">Loading
   External Resources</dfn></h3>

  <p>Several features in XBL allow external resources to be loaded.

  <p>When the specification says that the resource must be loaded <em>unless
   it has already been loaded</em>, then references to the same resource
   (even if they are somewhat indirect, for example via HTTP redirects) must
   result in the same instance being reused, or shared. To determine if two
   resources are the same, their final base URIs (after all redirects) are
   compared.

  <div class="example">
   <p>A <span><a href="#binding10">binding document</a></span> A contains a
    <code><a href="#binding11">binding</a></code> element that refers to a
    second binding document X. A new DOM <code>Document</code> instance is
    created to represent that instance and the relevant bindings are used.</p>

   <p>Now assume RX is a resource that redirects to resource X using the HTTP
    301 redirection mechanism. A second <code><a
    href="#binding11">binding</a></code> element in the binding document A
    refers to resource RX. When that resource is being loaded, the redirect
    to X would be discovered, and therefore instead of creating a new
    <code>Document</code>, the existing one is reused.</p>
  </div>

  <p>Such resource sharing is limited to resources loaded by a document, its
   binding documents, its scripts, and its stylesheets. Nested documents and
   images do not share resources with each other or with their container
   document.

  <p>Resources that are currently loading count as resources that are already
   loaded for the purposes of this reuse mechanism.

  <div class="example">
   <p>For example, if a document uses a binding document, and its stylesheets
    use that binding document, the same binding document instance will be
    used for both cases. However, if that document contains an
    <code>iframe</code> whose document uses the same binding document, a new
    instance will be used: the binding document instance from the outer
    document is not reused.</p>

  </div>

  <p>When the specification simply says that the external resource must be
   loaded, without giving any caveats regarding multiple accesses of the same
   resource, then each reference must instantiate a new unique copy of the
   document.

  <p class="example">For example, two <code><a
   href="#style0">style</a></code> elements whose <code>src</code> attributes
   point to the same stylesheet must create two different
   <code>Stylesheet</code> instances, such that mutating one does not affect
   the other.

  <p>Several XBL attributes are defined to contain URIs. All URIs may be
   relative. For relative URIs, the rules given in <a
   href="#refsXMLBASE">[XMLBASE]</a> must be used to resolve the value to an
   absolute URI.

  <h3 id="loading0"><span class="secno">3.2. </span><dfn
   id="loading6">Loading and Running Scripts</dfn></h3>

  <p>Scripts in XBL may be found in <code><a
   href="#script2">script</a></code>, <code><a
   href="#implementation0">implementation</a></code>, and <code><a
   href="#handler0">handler</a></code> elements, or in resources that those
   elements point to.

  <p>In the case of <code title="attr-script-src"><a
   href="#src2">script</a></code> and <code
   title="attr-implementation-src"><a href="#src">implementation</a></code>
   elements, if a <code title="">src</code> attribute is present then the the
   contents of the element are ignored (even if fetching the specified URI
   failed).

  <p>In any case, wherever the script is found, the rules for parsing it are
   the same, but depend on the language specified by the author.

  <p>For non-XML languages, if the content is inline, UAs must concatenate
   all the textual contents of text and CDATA child nodes, and must <span><a
   href="#ignoring">ignore</a></span> any other, non-text nodes (such as
   elements and comments) along with all their children. All descendant
   elements must be processed, though, according to their semantics, before
   the XBL script block itself is executed. A script element labelled as
   containing script in a non-XML language yet containing element nodes is
   <span><a href="#in-error">in error</a></span>.

  <div class="example">

   <p>For example, in an XHTML-aware and ECMAScript-capable user agent, the
    following ridiculous code would cause the alerts to appear in the order
    One, Two, Three, and would set the <code>test</code> property in the
    binding document's global script scope to the string "undefinedABC":</p>

   <pre>&lt;xbl xmlns="http://www.mozilla.org/xbl2"&gt;
 &lt;script&gt;
  alert('Two');
  test += "B";
  &lt;script xmlns="http://www.w3.org/1999/xhtml"&gt;

   alert('One');
   test += "A";
  &lt;/script&gt;
  alert('Three');
  test += "C";
 &lt;/script&gt;
&lt;/xbl&gt;</pre>

   <p>Authors must not ever consider doing this.</p>
  </div>

  <p>For XML-based scripting languages, handling of unknown elements and
   unexpected nodes must be defined by that language.

  <p>If the content was in another file, and that file's Content-Type (or
   equivalent for non-HTTP protocols), if any, was of the type <span
   title="attr-xbl-script-type"><a href="#script-type">specified</a></span>
   on the <code><a href="#xbl0">xbl</a></code> element, then the contents of
   that file are used directly, as specified by the relevant language
   specification.

  <p><code title="">src</code> attributes are examined after any children
   have been processed.

  <h4 id="xforms"><span class="secno">3.2.1. </span>XForms Actions</h4>

  <p>It is theoretically possible to use XForms Actions as the scripting
   language in XBL <a href="#refsXFORMS">[XFORMS]</a>. The MIME type that
   indicates this scripting language is tentatively defined to be <code
   class="mimetype">application/x-xforms-actions+xml</code>. XBL elements
   have the following semantics when used with XForms Actions:

  <dl>
   <dt><code><a href="#script2">script</a></code> elements

   <dd>These are exactly equivalent to <code>xforms:action</code> elements
    that trigger immediately upon being added to the document.

   <dt><code><a href="#handler0">handler</a></code> elements

   <dd>These are exactly equivalent to <code>xforms:action</code> elements
    that trigger when the appropriate event on the bound element is detected.

   <dt><code><a href="#implementation0">implementation</a></code> elements

   <dd>Since XForms Actions cannot declare new interfaces, <code><a
    href="#implementation0">implementation</a></code> elements when the
    script language is set to <code
    class="mimetype">application/x-xforms-actions+xml</code> are <span><a
    href="#in-error">in error</a></span> and the UA must <span><a
    href="#ignoring">ignore</a></span> them, by treating <code><a
    href="#implementation0">implementation</a></code> elements like
    <code>xforms:action</code> elements that are not bound to any event.
  </dl>

  <h4 id="scripting"><span class="secno">3.2.2. </span>Scripting Model and
   Security</h4>

  <p>Each document that runs script (including bound documents and binding
   documents) has a <code>DocumentWindow</code> object, a <code>Window</code>
   object, and a script scope.

  <p>The script scope for bound documents is determined by the user agent
   and the script language. (In ECMAScript, the script scope and the
   <code>Window</code> object are one and the same.)

  <p>The script scope for binding documents must include the
   <code>XBLPresentation</code> interface.

  <p>All objects and nodes are associated with a particular
   <code>DocumentWindow</code>, the one associated with the script scope in
   which they were created. In the case of nodes, this is the document
   returned by their <code>ownerDocument</code> DOM attribute.

  <p>Script must always be executed in the context of the script scope of the
   document specified by the script's element's <code>ownerDocument</code>

   DOM attribute. This implies that scripts from different bindings in the
   same binding document bound to different elements in the same bound
   document share the same scripting scope. If the bindings were defined in
   the document itself, then the scope is the same scope as for that
   document.

  <p>Each script scope (and each script running in that scope) has a domain.

  <p>Any attempt to get a reference to an object or node that is either
   from a different domain than the script's scope, or from a scope that is
   a binding document's scope, if that scope is not the same as the
   script's scope, is subject to same-origin security checks and may raise
   a security exception, except if that node or object is one of the
   following exempt nodes or objects:

  <ul>
   <li>a <code>Window</code> object

   <li>a <code>Location</code> object

   <li>an <code>Event</code> object

   <li>a <code>DocumentWindow</code> node

   <li>one of the exempt members of a <code>Window</code> object,
    <code>Location</code> object, <code>Event</code> object, or
    <code>DocumentWindow</code> node (which members are exempt is
    UA-specific)

   <li>an object returned by the <code><a
    href="#xblimplementation0">xblImplementation</a></code> attribute of the
    <code><a href="#nodexbl1">NodeXBL</a></code> interface

   <li>a member of an object returned by the <code><a
    href="#xblimplementation0">xblImplementation</a></code> attribute of the
    <code><a href="#nodexbl1">NodeXBL</a></code> interface
  </ul>

  <p>How to determine if a scope's domain is "different" from another's is
   not defined by this specification. Bindings provided by the user agent
   itself (e.g. any default bindings used to implement form widgets) should
   be considered to be in a different domain than any Web page's content.

  <p>In binding documents, the <code>location</code> and <code>history</code>
   properties of the <code>Window</code> object, and the
   <code>location</code> property of the <code>DocumentWindow</code> object,
   must return null, and any methods that are defined in terms of the
   browsing context's session history must do nothing. <a
   href="#refsHTML5">[HTML5]</a>

  <h3 id="loading1"><span class="secno">3.3. </span><dfn
   id="loading7">Loading Stylesheets</dfn></h3>

  <p>Stylesheets in XBL are only found in <code><a
   href="#style0">style</a></code> elements. If a <code
   title="attr-style-src"><a href="#src0">src</a></code> attribute is
   present, the contents of the element are ignored (even if fetching the
   specified URI failed).

  <p>Wherever the style is found, the rules for parsing it are the same, but
   depend on the language specified by the author.

  <p>For non-XML styling languages, if the content is inline, UAs must
   concatenate all the textual contents of text and CDATA child nodes, and
   the UA must <span><a href="#ignoring">ignore</a></span> any other,
   non-text nodes (such as elements and comments) along with all their
   children. All descendant elements must be processed, though, according to
   their semantics, before the XBL style block itself is parsed. A style
   element labelled as containing a stylesheet in a non-XML language yet
   containing element nodes is <span><a href="#in-error">in error</a></span>.

  <div class="example">

   <p>For example, in an XHTML-aware and ECMAScript-capable user agent, the
    rather dubious code below would result in a binding that enclosed the
    bound element's children in a green box, not a red one:</p>

   <pre>&lt;xbl xmlns="http://www.mozilla.org/xbl2"&gt;
 &lt;binding&gt;
  &lt;template&gt;
   &lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;content/&gt;

   &lt;/div&gt;
  &lt;/template&gt;
  &lt;resources&gt;
   &lt;style id="test"&gt;
    div { background: red; }
    &lt;script xmlns="http://www.w3.org/1999/xhtml"&gt;
     document.getElementById('test').firstChild.data = "div { background: green; }";
    &lt;/script&gt;

    &lt;p xmlns="http://www.w3.org/1999/xhtml"&gt;
     div { border: red solid; }
     This will either be ignored by the XBL processor, or will cause
     it to abort all processing altogether, as this text node is not a
     child of the style element.
    &lt;/p&gt;
   &lt;/style&gt;
  &lt;/resources&gt;
 &lt;/binding&gt;
&lt;/xbl&gt;</pre>

  </div>

  <p>For XML-based styling languages, handling of unknown elements and
   unexpected nodes must be defined by that language.

  <p>If the content was in another file, and that file's Content-Type (or
   equivalent for non-HTTP protocols), if any, was of the type specified on
   the <code><a href="#xbl0">xbl</a></code> element, then the contents of
   that file are used directly, as specified by the relevant language
   specification. The <code title="attr-style-src"><a
   href="#src0">src</a></code> attribute is examined after any children have
   been processed.

  <h3 id="interpretation"><span class="secno">3.4. </span><dfn
   id="interpretation1">Interpretation of URIs to XBL bindings</dfn></h3>

  <p>XBL attachment mechanisms use a URI to specify which binding to attach
   to the designated element. For example:

  <pre class="example">&lt;binding element="my:foo"
            ref="<strong>http://www.example.org/bindings.xml#fooBinding</strong>"/&gt;</pre>

  <p>This section defines how these URIs, which are used in the <code><a
   href="#binding11">binding</a></code> element's <code
   title="attr-binding-ref"><a href="#ref">ref</a></code> attribute, in the
   argument to the <code><a href="#addbinding">addBinding()</a></code>
   method, and in the value of the <span>'-xbl-binding'</span> property, are
   to be interpreted.

  <p>The URI specifies a particular <span><a href="#binding10">binding
   document</a></span> (an XBL document or compound document containing one
   or more XBL subtrees). The user agent must fetch this resource (unless it
   has <span title="loading external resources"><a href="#loading5">already
   been loaded</a></span>).

  <p>If the URI contains a fragment identifier, it must point to a specific
   <code><a href="#binding11">binding</a></code> element (by <code
   title="attr-id"><a href="#id12">id</a></code>) within an XBL subtree in
   the specified document, and that element must be a direct child of an
   <code><a href="#xbl0">xbl</a></code> element that does not itself have an
   <code><a href="#xbl0">xbl</a></code> element as an ancestor; if these
   conditions are not met then the URI is <span><a href="#in-error">in
   error</a></span>.

  <p>If there is no fragment identifier and the URI points to an XBL document
   (not a compound document) then the first <code><a
   href="#binding11">binding</a></code> element in the binding document that
   is a child of the root <code><a href="#xbl0">xbl</a></code> element is
   selected. Otherwise, the URI does not point to a <span><a
   href="#correct">correct</a></span> binding and is <span><a
   href="#in-error">in error</a></span>.

  <p>When an attachment mechanism uses a URI that is in error (as per the
   last two paragraphs), then the user agent must act as if the attachment
   mechanism had not specified that binding.

  <p>Otherwise, the specified binding is attached to the element, as
   described for the relevant attachment mechanism.

  <h2 id="binding"><span class="secno">4. </span><dfn id="binding12">Binding
   Attachment and Detachment</dfn></h2>

  <p>Bindings can be attached and detached dynamically, using several
   mechanisms.

  <p>Bindings must be attached as soon as the following conditions have been
   met:

  <ol>
   <li>it is known that the binding applies to the element,

   <li>the element has been created,

   <li>the binding document defining the binding has loaded.
  </ol>

  <p>In particular, binding can happen before the element is inserted into
   its document.

  <p>If the binding document was already loaded when the element was created,
   or when it became known that the element matched the binding (e.g. because
   the binding's <code title="attr-binding-element"><a
   href="#element">element</a></code> attribute is mutated in a script), then
   the binding must be applied such that to any running scripts it appears
   that the binding was applied immediately.

  <p>If the binding document has yet to be (fully) loaded when it becomes
   known that the binding applies, then the user agent must wait until all
   running scripts have completed before attaching the binding.</p>

  <!-- XXX someone complained last time i used that term
  ("run to completion"), and suggested better text. In the WA1 spec, I
  think. Use that here. [in the thread-safe storage bit, iirc] -->

  <p class="note">If the binding attachment mechanism is the
   <code>'-xbl-binding'</code> property, then it does not become known to the
   user agent that the binding applies (or does not apply) until the next
   time style resolution is performed. This specification does not define
   when style resolution happens.</p>
  <!-- XXX who
  does. HTML5? -->

  <p>Bindings must be detached as soon as it is known that the binding no
   longer applies to the element.

  <p>When it becomes known that a binding is to be detached, it must happen
   such that to any running scripts it appears that the binding was removed
   immediately, except if the script in question is running as part of the
   last step of the binding attachment process, in which case the detachment
   happens after all the bindings being attached have had their methods
   called. (See: <span><a href="#binding13">binding attachment
   model</a></span>.)

  <h3 id="attachment"><span class="secno">4.1. </span><dfn id="attachment4"
   title="attachment using binding">Attachment using <code
   title="binding">&lt;binding element=""&gt;</code></dfn></h3>

  <p>The simplest binding mechanism is the <code><a
   href="#binding11">binding</a></code> element's <code
   title="attr-binding-element"><a href="#element">element</a></code>
   attribute. It declares which bindings should be attached to which
   elements.

  <p>While an element matches the <code title="attr-binding-element"><a
   href="#element">element</a></code> attribute of one of the <code><a
   href="#binding11">binding</a></code> elements that is <span
   title="import"><a href="#importing1">imported</a></span> into, or defined
   in, the element's document, the binding defined by the first such <code><a
   href="#binding11">binding</a></code> element must be bound to the element.
   This applies to all elements that are associated with a document, even
   when they have not yet been inserted into the document, or are not in the
   <span><a href="#final">final flattened tree</a></span>.

  <p>A <code title="attr-binding-ref"><a href="#ref">ref</a></code> attribute
   may be used to defer the binding of the binding to another <code><a
   href="#binding11">binding</a></code> element. (See: <span
   title="binding"><a href="#binding11">the binding element</a></span>.)

  <h4 id="importing"><span class="secno">4.1.1. </span><dfn id="importing1"
   title="import">Importing binding documents</dfn></h4>

  <p>There are two ways to import binding documents (and thus have their
   <code title="binding"><a href="#binding11">&lt;binding
   element=""&gt;</a></code> bindings apply): <span title="xbl-pi"><a
   href="#the-ltxblgt">the <code>&lt;?xbl?&gt;</code> processing
   instruction</a></span>, and the <code><a
   href="#loadbindingdocument">loadBindingDocument()</a></code> method. The
   latter is defined in the section on the <code><a
   href="#documentxbl">DocumentXBL</a></code> interface.

  <p><dfn id="the-ltxblgt" title="xbl-pi">The <code>&lt;?xbl?&gt;</code>

   processing instruction</dfn> specifies a binding document to load. Any
   bindings <span title="attachment using binding"><a
   href="#attachment4">defined in that document</a></span> must be applied to
   matching elements in the document with the processing instruction.

  <p><code>&lt;?xbl?&gt;</code> processing instructions that occur after the
   root element in the markup are <span><a href="#in-error">in
   error</a></span>. <code>&lt;?xbl?&gt;</code> PIs that are dynamically
   inserted through the DOM after the root element has been parsed or
   attached to the document are <span><a href="#in-error">in error</a></span>

   too.

  <p>A <code>&lt;?xbl?&gt;</code> processing instruction that is not in error
   according to the above must be parsed using the same syntax as the XML
   Stylesheet PI. <a href="#refsXMLSSPI">[XMLSSPI]</a> If there are any parse
   errors, then the entire processing instruction is <span><a
   href="#in-error">in error</a></span>.

  <p>Otherwise, if it has an <dfn id="href"
   title="attr-import-href"><code>href</code></dfn> pseudo-attribute then it
   specifies the URI of the binding document to import. If the URI cannot be
   resolved, or returns an error, or does not point to a resource with
   <span>an XML MIME type</span><!-- XXX xref -->, or has any other problem
   that makes it unusable, then the processing instruction is <span><a
   href="#in-error">in error</a></span>.

  <p>If a processing instruction is in error (as described in the previous
   few paragraphs) then it must be ignored.

  <p>Otherwise, the referenced document must be loaded (unless it has <span
   title="loading external resources"><a href="#loading5">already been
   loaded</a></span>), and any bindings defined by that document must be
   applied to matching elements in the document that contained the PI. Once
   loaded, the binding document is added to the <code><a
   href="#bindingdocuments">bindingDocuments</a></code> list of the document
   with the PI.

  <p>Dynamic changes to <code>&lt;?xbl?&gt;</code> processing instructions
   must be ignored from an XBL standpoint.

  <p>An imported binding document is <em>live</em>. For example, if new
   <code><a href="#binding11">binding</a></code> elements are added to it
   (via the DOM), then the new bindings are immediately applied to the
   document that had the PI.

  <p>XBL bindings are always implicitly imported into the document in which
   they are defined.

  <div class="example">

   <p>An XBL subtree that defines some bindings is automatically imported in
    that document, so such mappings are always used. The following example
    demonstrates this.</p>

   <pre><strong>example.xml</strong>

&lt;...&gt;
 &lt;xbl xmlns="http://www.mozilla.org/xbl2" ...&gt;
  &lt;binding element="foo"&gt;
   ...
  &lt;binding&gt;

  &lt;binding element="bar"&gt;
   ...
  &lt;binding&gt;
 &lt;/xbl ...&gt;
 &lt;foo xmlns=""/&gt; &lt;!-- this will have a binding applied --&gt;
 &lt;bar xmlns=""/&gt; &lt;!-- this will have a binding applied --&gt;

&lt;/...&gt;
</pre>

   <p>If the binding definitions are in a separate file, then that file needs
    to be imported explicitly:</p>

   <pre><strong>widgets.xml</strong>

&lt;...&gt;
 &lt;xbl xmlns="http://www.mozilla.org/xbl2" ...&gt;

  &lt;binding element="foo"&gt;
   ...
  &lt;binding&gt;
  &lt;binding element="bar"&gt;
   ...
  &lt;binding&gt;
 &lt;/xbl ...&gt;

&lt;/...&gt;
</pre>

   <pre><strong>example.xml</strong>

<em>&lt;?xbl href="widgets.xml"?&gt;</em>
&lt;...&gt;
 &lt;foo/&gt; &lt;!-- bound --&gt;

 &lt;bar/&gt; &lt;!-- bound --&gt;
&lt;/...&gt;
</pre>

   <p>If a file imports some bindings and the file containing those bindings
    has its own <code>&lt;?xbl?&gt;</code> processing instructions, that
    second PI only affects nodes in the binding document, not the original
    document. For example:</p>

   <pre><strong>foo.xml</strong>

&lt;...&gt;
 &lt;xbl xmlns="http://www.mozilla.org/xbl2" ...&gt;
  &lt;binding element="foo"&gt;
   &lt;content&gt;
    &lt;bar xmlns=""/&gt; &lt;!-- not bound, not even when in shadow content --&gt;

   &lt;/content&gt;
  &lt;binding&gt;
 &lt;/xbl&gt;
&lt;/...&gt;
</pre>

   <pre><strong>bar.xml</strong>

&lt;?xbl href="foo.xml"?&gt;
&lt;...&gt;
 &lt;xbl xmlns="http://www.mozilla.org/xbl2" ...&gt;
  &lt;binding element="bar"&gt;
   &lt;content&gt;
    &lt;foo xmlns=""/&gt; &lt;!-- bound: this document imports foo.xml --&gt;

    &lt;bar xmlns=""/&gt; &lt;!-- bound: bar binding is defined locally --&gt;
   &lt;/content&gt;
  &lt;binding&gt;
 &lt;/xbl&gt;
&lt;/...&gt;
</pre>

   <pre><strong>example.xml</strong>

&lt;?xbl href="bar.xml"?&gt;
&lt;...&gt;
 &lt;foo/&gt; &lt;!-- not bound: foo.xml not imported here --&gt;
 &lt;bar/&gt; &lt;!-- bound --&gt;

&lt;/...&gt;
</pre>
  </div>

  <h3 id="attachment0"><span class="secno">4.2. </span>Attachment using CSS</h3>

  <p>Bindings can be attached to elements through CSS using the
   <span>'-xbl-binding'</span> property.

  <div class="example">

   <p>In the following example, a binding is referenced that will be attached
    to all XHTML checkbox elements.</p>

   <pre>
input[type="checkbox"] {
  binding: url("http://www.example.org/xbl/htmlBindings.xml#checkbox");
}
</pre>
  </div>

  <p>Bindings attached through CSS must only remain on the bound element as
   long as the element continues to match the style rule. If at any time a
   resolution of style on the element determines that a different binding
   should be attached, the old binding (and all bindings that it explicitly
   extends in its inheritance chain) must be detached.

  <p>Whenever an element is removed from a document, any bindings attached to
   that element via CSS must be detached.

  <h4 id="the--xbl-binding"><span class="secno">4.2.1. </span>The
   '-xbl-binding' property</h4>

  <p class="big-issue">We have to do something about this section, we can't
   just go around inventing new CSS properties. Either we'll submit this to
   W3C, or we'll use '-xbl-binding' as the property name.

  <p>A property to bind an XBL binding to a particular element.

  <table class="propdef" id="xbl-binding">
   <caption> <dfn id="xbl-binding0" title="binding
    property">'-xbl-binding'</dfn></caption>

   <tbody>
    <tr>
     <td><em>Value:</em>

     <td>none | [ &lt;uri&gt; ',' ]* &lt;uri&gt;
      <!--XXXPD &lt;predefined binding&gt;-->

    <tr>
     <td><em>Initial:</em>

     <td>none

    <tr>
     <td><em>Applies To:</em>

     <td>all elements (but not pseudo-elements)

    <tr>
     <td><em title="">Inherited:</em>

     <td>no

    <tr>

     <td><em>Percentages:</em>

     <td>n/a

    <tr>
     <td><em>Media:</em>

     <td>all

    <tr>
     <td><em>Computed Value:</em>

     <td>specified value, with URIs resolved to absolute URIs
  </table>

  <dl>
   <dt>none

   <dd>No bindings are to be attached through CSS.

   <dt>&lt;uri&gt;

   <dd>The specified binding is attached. More than one binding can be
    specified, resulting in the bindings being attached in the specified
    order, with the last binding implicitly inheriting from the previous one,
    and so forth, up to the first binding. (See: <span><a
    href="#implied1">implied inheritance</a></span>)</dd>

   <!--XXXPB
   <dt>&lt;predefined binding&gt;</dt>
   <dd>One of the bindings defined in the <a
   href="#base-bindings">Predefined Base Bindings</a> section is
   attached.</dd>
-->
  </dl>

  <h4 id="processing"><span class="secno">4.2.2. </span>Processing model</h4>

  <p>User agents may perform the CSS cascade, inheritance, and computation
   stages either across the entire tree, or per element, or per property per
   element, and either before applying bindings, or simultaneously, while
   applying bindings. In either case, for each element the computed value of
   '-xbl-binding' must be found and then used to apply the bindings to the
   element (when the element is first styled, and each subsequent time the
   styles that match the element change).

  <p>Since each time a binding is applied it can change the computed values
   of properties of elements that are descendants of the bound element, this
   may require several passes. This may be avoided by computing the value of
   the '-xbl-binding' property for the element, and then applying any
   bindings, before any of its descendants.

  <h3 id="attachment1"><span class="secno">4.3. </span>Attachment using the
   DOM</h3>

  <p>Bindings can be attached to elements through the DOM using the <a
   href="#dom-interfaces"><code>NodeXBL</code></a> interface. The method
   <code><a href="#addbinding">addBinding</a></code> takes a binding URI and
   attaches the binding to the element (in all views).

  <pre class="dom
   example">var checkbox = document.getElementById("mycheckbox");
checkbox.addBinding("http://www.example.org/xbl/htmlBindings.xml#checkbox");</pre>

  <p>This attachment is not necessarily synchronous. Scripts that invoke this
   method should not assume that the binding is installed immediately after
   this method returns.

  <p>When a binding is attached using the DOM, it inherits from the current
   most derived binding that is already be attached to the element, if any.
   (See: <span><a href="#implied1">implied inheritance</a></span>.)

  <p>Any bindings attached to an element using the <code><a
   href="#addbinding">addBinding()</a></code> method will remain on the
   element until the element is destroyed or a corresponding <code><a
   href="#removebinding">removeBinding()</a></code> call is made.

  <h3 id="binding0"><span class="secno">4.4. </span><dfn
   id="binding13">Binding Attachment Model</dfn></h3>

  <p>When a new binding is attached, the UA must perform the following steps
   in order (or act as if it did). Implementations may choose to suspend
   redraw during this process.

  <ol>
   <li>The binding's position in the inheritence chain is determined.
    If the binding contains a <code><a
    href="#template0">template</a></code> element, the shadow content
    is cloned and inserted at proper position in the inheritance
    chain. (See: <span>binding inheritance</span>.)

   <li>Events must start being routed through the binding's <code><a
    href="#handlers0">handlers</a></code> element, when there is one. (See:
    <span><a href="#event10">event forwarding</a></span>.)

   <li>If the new binding has an implementation, it is compiled and inserted
    into the implementation chain and made available to scripts.
    Language-specific constructors for the binding implementation must run at
    this point.

  </ol>

  <p>Once the above steps have been completed for any bindings that are known
   to apply to elements, the <code><a
   href="#xblbindingattached">xblBindingAttached()</a></code> method must be
   invoked on the binding's <span><a
   href="#implementation0">implementation</a></span>. In addition, if the
   bound element <span><a href="#is-in">is in a document</a></span>, the
   <code><a href="#xblentereddocument">xblEnteredDocument()</a></code> method
   must be invoked on the binding's <span><a
   href="#implementation0">implementation</a></span>.

  <p>If a binding stops applying to a document while the above steps are
   being applied, the binding is not removed until after the steps above have
   all been completed. Once they have been completed, any bindings that no
   longer apply must be detached.

  <h3 id="handling"><span class="secno">4.5. </span><dfn
   id="handling2">Handling Insertion and Removal from the Document</dfn></h3>

  <p>A bound element <dfn id="is-in">is in a document</dfn> if it has a
   <code>Document</code> node as an ancestor, of it is in a shadow tree and
   that shadow tree's bound element is itself <span title="is in a
   document"><a href="#is-in">in a document</a></span>.

  <p>When a bound element that is not <span title="is in a document"><a
   href="#is-in">in a document</a></span> is affected in such a way that it
   subsequently <span><a href="#is-in"><em>is</em> in a document</a></span>,
   then the <code><a
   href="#xblentereddocument">xblEnteredDocument()</a></code> method must be
   invoked on the binding's <span><a
   href="#implementation0">implementation</a></span>.

  <p>Similarly in reverse: when a bound element that <span><a
   href="#is-in"><em>is</em> in a document</a></span> is affected in such a
   way that it subsequently is <em>not</em> <span title="is in a document"><a
   href="#is-in">in a document</a></span>, then the <code><a
   href="#xblleftdocument">xblLeftDocument()</a></code> method must be
   invoked on the binding's <span><a
   href="#implementation0">implementation</a></span>.

  <p>These methods must be invoked as soon as the DOM is in a stable state,
   after any mutation events have fired, and after all running scripts have
   finished executing. If a bound element is removed and then reinserted into
   a document (or vice versa) during script execution, or while mutation
   events are being fired, the user agent may coalesce all the notifications
   into a single pair of method calls.

  <h3 id="implied"><span class="secno">4.6. </span><dfn id="implied1">Implied
   Inheritance</dfn></h3>

  <p>Bindings can inherit from each other explicitly using the <code
   title="attr-binding-extends"><a href="#extends">extends</a></code>
   attribute. They can also inherit from each other <em>implicitly</em> if
   multiple bindings are attached to an element.

  <p class="note">The results of inheritance are described in the sections on
   <span><a href="#binding15">binding implementations</a></span> and <span><a
   href="#shadow8">shadow content</a></span>.

  <p>When two bindings are both attached (using the mechanisms described
   above), to the same element, the base binding at the end of the
   inheritance chain of the second binding implicitly inherits from the most
   derived binding of the inheritance chain of the first.

  <p>If one of the binding chains is removed, then the remaining binding
   chains are reconnected so that the base binding of the chain after the
   break now inherits from the most derived binding before the break.

  <p>The order of bindings is always such that bindings added via the
   <code><a href="#binding11">binding</a></code> element are first (in the
   order the bindings are specified in the file, with the files, if there are
   more than one, ordered in the same order that they are referred to,
   traversed pre-order, depth-first), the bindings attached via CSS are
   second (in the order specified on the <span>'-xbl-binding'</span>
   property), and the bindings added via <code><a
   href="#addbinding">addBinding</a></code> are third (in the order they were
   attached, most recently attached being the most derived binding).

  <div class="figure">
   <!-- Note: alt="" is correct for the following image, since the
        caption says everything the image says. -->
   
   <p><img alt="" src="images/attachment.gif"></p>

   <p class="caption">The implicit inheritance link can be pictured as having
    several explicit chains adjacent to each other, with the implicit
    inheritance chain going down each explicit inheritance chain
    sequentially.</p>
  </div>

  <div class="example">
   <p>For example, take a binding <em>d<sub>1</sub></em>, which specifies a
    base binding <em>d<sub>2</sub></em> using the <code
    title="attr-binding-extends"><a href="#extends">extends</a></code>
    attribute such that its explicit inheritance chain is:</p>

   <p><em>d<sub>1</sub></em> &rarr; <em>d<sub>2</sub></em></p>

   <p>If this element is attached to an element using <code><a
    href="#addbinding">addBinding</a></code> that already has a binding chain
    of:</p>

   <p><em>s<sub>1</sub></em> &rarr; <em>s<sub>2</sub></em> &rarr;

    <em>s<sub>3</sub></em></p>

   <p>...then the base binding at the end of the inheritance chain,
    <em>d<sub>2</sub></em>, is the one that will inherit from the most
    derived binding that is already attached to the element,
    <em>s<sub>3</sub></em>. The resulting binding chain following the
    addition of the binding is therefore:</p>

   <p><em>d<sub>1</sub></em> &rarr; <em>d<sub>2</sub></em> &rarr;

    <em>s<sub>1</sub></em> &rarr; <em>s<sub>2</sub></em> &rarr;
    <em>s<sub>3</sub></em></p>

   <p>The inheritance between <em>d<sub>3</sub></em> and
    <em>s<sub>1</sub></em> is <em>implicit</em>, meaning that there is no
    connection in the XBL subtrees between the two bindings. The inheritance
    link has been forged dynamically through the invocation of the <code><a
    href="#addbinding">addBinding</a></code> method.</p>

  </div>

  <h3 id="views"><span class="secno">4.7. </span>Views and Attachment</h3>

  <p>Only one set of bindings is attached to the document, and they must
   affect all views in a multi-view UA. Bindings attached via stylesheets
   must be attached based on the stylesheets that apply to the default view.

  <h3 id="attachment2"><span class="secno">4.8. </span>Attachment During
   Document Load</h3>

  <p>Binding loads are asynchronous. That is to say, when a binding is added
   (either via stylesheet, script, or some other method), and the relevant
   <span><a href="#binding10">binding document</a></span> is not yet loaded,
   the load is started in the background and the binding is only attached
   once the document is available. An author can ensure that all bindings are
   synchronously attached by calling <code><a
   href="#loadbindingdocument">loadBindingDocument</a></code> to pre-fetch
   any binding documents that are required.

  <p>The bound document must wait until all XBL dependencies have loaded
   before firing its load event.

  <h3 id="binding1"><span class="secno">4.9. </span>Binding Detachment Model</h3>

  <p>When a binding is detached, the <code><a
   href="#xblleftdocument">xblLeftDocument()</a></code> method must be
   invoked on the binding's <span><a
   href="#implementation0">implementation</a></span>. Then, the
   implementation must be removed from the inheritance chain of the
   bound element's <code><a
   href="#xblimplementation0">xblImplementation</a></code>, the shadow
   template generated by the binding (if present) should be detached, and
   any forwarding of events to the binding must be stopped for this
   bound element.

  <h2 id="shadow"><span class="secno">5. </span><dfn id="shadow8">Shadow
   Content</dfn></h2>

  <p>A binding can specify a <span><a href="#shadow7">shadow content
   template</a></span> using the <code><a
   href="#template0">template</a></code> element. This template describes a
   content tree that will be generated around the bound element during binding
   attachment. An element declared in a bound document using a single element
   can then be constructed out of multiple elements, and this
   implementation is hidden from the bound document.

  <p>When the content template is cloned (as described in this
   section), the clone is called a <span><a href="#shadow5">shadow
   template</a></span>.

  <div class="example">
   <p>For example, the HTML file upload control appears in most browsers as a
    composite widget consisting of a text field and a button. A sample XBL
    binding for the file widget might look as follows:</p>

   <pre>&lt;binding id="fileupload"&gt;
  &lt;template&gt;
    &lt;html:input type="text"/&gt;
    &lt;html:input type="button"/&gt;
  &lt;/template&gt;
&lt;/binding&gt;</pre>

   <p>Because this content is not visible to its parent element, it is said
    to be <em><a href="#shadow8">shadow content</a></em>.</p>
  </div>

  <p class="note">The file control is actually a special case. Due to
   security considerations, untrusted bindings will typically not be able to
   extend the file upload control in UAs intended for use with untrusted
   content.

  <p>Whenever bindings are attached to an element, shadow content will
   potentially be <span title="Rules for Shadow Content Generation"><a
   href="#rules3">generated</a></span> or <span title="Rules for Shadow
   Content Destruction"><a href="#rules4">destroyed</a></span>.

  <p>Once a binding has been attached, changes to the content template do not
   affect the shadow template.

  <p>The <code><a href="#template0">template</a></code> element used to
   generate a binding is always the first such element in a <code><a
   href="#binding11">binding</a></code> element.

  <h3 id="rules"><span class="secno">5.1. </span><dfn id="rules3">Rules for
   Shadow Content Generation</dfn></h3>

  <p>When a binding is applied, user agents must act as follows:

  <p>The content template of the binding is cloned to produce a shadow
   template.

  <p>The bindings in the inheritance chain are processed from the base
   binding sequentially through derived bindings. The shadow template
   of each binding is inserted into the final flattened tree.
   
  <p>The shadow template of each derived binding is inserted at the
   position of the <code><a href="#element0">element</a></code>
   element in the immediate base binding. If the template of the
   immediate base binding does not include an <code><a
   href="#element0">element</a></code> element, no further shadow
   templates are inserted into the final flattened tree.

  <p>The bound element itself is inserted at the position of the
   <code><a href="#element0">element</a></code> element in the
   most-derived binding. If the template of the most derived binding
   does not include an <code><a href="#element0">element</a></code>
   element, the bound element itself is not present in the final
   flattened tree.

  <p>The bindings in the binding's explicit chain are first checked to see if
   any have content templates. If any do, then the most derived such
   template is the <dfn id="primary">primary generating binding</dfn>.
   Otherwise, there isn't one.

  <p>The <code>xml:base</code> data of the cloned <code><a
   href="#template0">template</a></code> element must be set so that the
   <code>baseURI</code> of nodes in the resulting shadow tree is the same as
   their pre-cloning counterparts. All shadow nodes'
   <code>ownerDocument</code> pointers are left pointing at their binding
   documents' <code>Document</code> node(s).

  <p>No mutation events must be fired during the above steps.

  <p>Any bindings that apply to elements in the shadow tree must be applied.

  <p>The <span><a href="#explicit">explicit children</a></span> are
   then distributed to the appropriate <code><a
   href="#content0">content</a></code> elements. The CSS
   cascade and inheritance is be computed along the new tree. (See: <span><a
   href="#processing2">processing <code>content</code> elements</a></span>.)

  <p>After this point, further bindings may need to be applied, or certain
   bindings may need to be removed (because of CSS inheritance or because the
   selectors that decide which elements match which bindings can be affected
   by the shadow tree being associated with the bound element).

  <p>Everything described in this section must be completed atomically
   &mdash; that is, the UA must not execute author scripts during this
   process.

  <p class="note">Some implementations might optimize this algorithm, such as
   using "lazy evaluation" approaches and thereby postpone the cascade and
   inheritance operations.

  <h3 id="rules0"><span class="secno">5.2. </span><dfn id="rules4">Rules for
   Shadow Content Destruction</dfn></h3>

  <p>Shadow content is destroyed when the associated binding is
   detached from an element. Any <span><a href="#explicit">explicit
   children</a></span> inserted into <code><a
   href="#content0">content</a></code> elements being removed are redistributed
   using the rules for <span><a
   href="#processing2">processing <code title="">content</code>
   elements</a></span> elements.

  <h3 id="attribute"><span class="secno">5.3. </span><dfn
   id="attribute1">Attribute Forwarding</dfn></h3>

  <p>Attributes on shadow content elements can be tied to attributes on the
   bound element; then, whenever the attribute is set or removed on the bound
   element, the corresponding attribute on the shadow content is also set or
   removed. On any shadow content element, an <code title="attr-inherits"><a
   href="#xblinherits0">xbl:inherits</a></code> attribute can be used to
   specify a <span><a href="#attributes16">space-separated</a></span> list of
   attributes that should be inherited. Attributes with namespaces can be
   defined using a namespace prefix and the attribute name separate by a
   colon.

  <div class="example">
   <p>For example, returning to the HTML file upload control example above,
    the shadow text field can be set up to automatically inherit the
    <code>value</code> attribute from the bound element.</p>

   <pre>&lt;xbl:binding id="fileUploadControl"&gt;
  &lt;xbl:template&gt;
    &lt;html:input type="text" xbl:inherits="value"/&gt;
    &lt;html:input type="button" value="Browse..."/&gt;
  &lt;/xbl:template&gt;
&lt;/xbl:binding&gt;</pre>

  </div>

  <p>Each entry in the <code title="attr-inherits"><a
   href="#xblinherits0">xbl:inherits</a></code> list can either simply list
   an attribute (A QName, such as <code>value</code> in the example above),
   or it can specify an <code>=</code>-separated pair of QNames consisting of
   the attribute on the shadow content that should be tied to the attribute
   on the bound element. The new shadow content attribute is listed first.

  <p>Each entry may also be suffixed by a single hash mark (#) followed by a
   <span><a href="#type-">type designation</a></span>.

  <p>The <code title="attr-inherits"><a
   href="#xblinherits0">xbl:inherits</a></code> attribute's value must be
   parsed as follows. First, it must be split on spaces (treated as a
   <span><a href="#attributes16">space-separated</a></span> value). Next, it
   must be matched against the following pattern (given here in pseudo-BNF,
   where square brackets indicate optional terms):

  <pre>xbl inherits item := [<var>s1</var> ':'] <var>s2</var> ['=' [<var>s3</var> ':'] <var>s4</var>] ['#' <var>s5</var>]</pre>

  <p>...where <var>s1</var>..<var>s5</var> are strings of characters not
   containing any of ":". "=", or "#".

  <p>If any item does not match this pattern, then the item is <span><a
   href="#in-error">in error</a></span> and must be ignored. Other items in
   the list, if any, are not affected by this.

  <p>The values <var>s1</var>:<var>s2</var> and <var>s3</var>:<var>s4</var>

   (if present) must be resolved to valid qualified names (QName) using the
   attribute QName resolving semantics and the namespaces prefix declarations
   in scope on the element on which the <code title="attr-inherits"><a
   href="#xblinherits0">xbl:inherits</a></code> attribute is found. Any value
   in the list that does not resolve to a valid QName is <span><a
   href="#in-error">in error</a></span> and must be ignored. <a
   href="#refsXMLNS">[XMLNS]</a>

  <p>The special value <dfn id="xbltext"><code>xbl:text</code></dfn> can be
   used in an =-separated pair, where the prefix is associated with the XBL
   namespace. (The value is not a literal; it represents the fictional "text"
   attribute in the XBL namespace.)

  <p>When specified on the left-hand side of the pair it indicates that the
   value of the attribute on the right-hand side should be stored as text
   nodes underneath the shadow element in the <code><a
   href="#xblchildnodes">xblChildNodes</a></code> list. If the element has
   other nodes in its <code><a href="#xblchildnodes">xblChildNodes</a></code>

   list (any nodes, including comment nodes, whitespace text nodes, or even
   empty CDATA nodes) then the pair is <span><a href="#in-error">in
   error</a></span> and UAs must ignore it, meaning the attribute value is
   not forwarded.

  <p>Text nodes created in this way are orphans; their
   <code>parentNode</code>, <code>nextSibling</code>,
   <code>previousSibling</code>, <code>childNodes</code>,
   <code>firstChild</code>, and <code>lastChild</code> attributes are all
   null or empty. Their <code>ownerDocument</code> attribute is set to the
   same as the shadow content node that generated them. Similarly, their
   <code><a href="#xblparentnode">xblParentNode</a></code> attribute points
   to the element that generated them and their <code><a
   href="#xblnextsibling">xblNextSibling</a></code>, <code><a
   href="#xblprevioussibling">xblPreviousSibling</a></code>, <code><a
   href="#xblchildnodes">xblChildNodes</a></code>, <code><a
   href="#xblfirstchild">xblFirstChild</a></code>, and <code><a
   href="#xbllastchild">xblLastChild</a></code> attributes are all null or
   empty.

  <p>When used on the right-hand side, it indicates that any raw text nodes
   (including CDATA nodes) that are <span><a href="#explicit">explicit
   children</a></span> of the bound element should be coalesced and the
   resulting value should be stored as the attribute on the left-hand side.
   <span class="issue">Should we instead use <code>textContent</code>?</span>

  <p>The <code><a href="#xbltext">xbl:text</a></code> value cannot occur by
   itself in the list. It may be used only in an = separated pair where at
   least one value is not <code><a href="#xbltext">xbl:text</a></code>. If it
   occurs by itself, it is <span><a href="#in-error">in error</a></span> and
   UAs must <span><a href="#ignoring">ignore</a></span> that value in the
   <span><a href="#attributes16">space-separated</a></span> list that is the
   <code title="attr-inherits"><a
   href="#xblinherits0">xbl:inherits</a></code> attribute.

  <p>The special value <dfn id="xbllang"><code>xbl:lang</code></dfn> can also
   be used in an =-separated pair. (Again, this is just the fictional "lang"
   attribute in the XBL namespace, not the literal string "xbl:lang", so the
   "xbl" prefix, or whatever prefix is used, must be declared as the XBL
   namespace.)

  <p>When used on the right-hand side, it indicates that the value to be
   copied is the natural language of the bound element, typically given by
   the attribute <code>xml:lang</code> of that element or an ancestor, or by
   HTTP headers, or similar. If no language is defined, then the value to be
   copied must be the empty string.

  <p>The <code><a href="#xbllang">xbl:lang</a></code> value cannot occur by
   itself or on the left-hand side. If it does, it is <span><a
   href="#in-error">in error</a></span> and UAs must <span><a
   href="#ignoring">ignore</a></span> that value in the element's <code
   title="attr-inherits"><a href="#xblinherits0">xbl:inherits</a></code>

   attribute.

  <p>Any other values in the XBL namespace in the list are <span><a
   href="#in-error">in error</a></span> and must be <span title="ignore"><a
   href="#ignoring">ignored</a></span>. (In particular, trying to change or
   set the value of <code title="attr-pseudo"><a
   href="#xblpseudo0">xbl:pseudo</a></code> or, worse, <code
   title="attr-inherits"><a href="#xblinherits0">xbl:inherits</a></code>,
   must not result in any changes to any attributes.)

  <p>If an attribute is listed multiple times on the left hand side (or on
   its own), then the latter designation wins (as if the attributes were each
   forwarded in turn, an earlier forwarding being overwritten by a later
   one).

  <p>If the attribute or attribute pair is followed by a <dfn id="type-">type
   designation</dfn>, in the form of a hash mark character ("#") and by a
   type name, then the value must be processed as described for its type
   below before being forwarded.

  <dl>

   <dt>If the type is <dfn id="url" title="type-url"><code>url</code></dfn>

   <dd>The value must be resolved to an absolute URI using the base URI of
    the source element before being forwarded.

   <dt>If the type is <dfn id="text0"
    title="type-text"><code>text</code></dfn> or any other type not defined
    here

   <dd>The value is forwarded unchanged.
  </dl>

  <div class="example">
   <p>In the following shadow template, the "src" attribute on the bound
    element is forwarded to the "src" attribute on the <code>image</code>

    element in the shadow tree, and the link will work even if the original
    attribute had a relative URI and the base URIs of the various nodes are
    different:</p>

   <pre>
&lt;xbl:template&gt;
  &lt;xul:image xbl:inherits="src#url title alt=xbl:text xml:lang=xbl:lang"/&gt;
&lt;/xbl:template&gt;
    </pre>

   <p>This example also shows how to turn the value of an attribute on the
    bound element, in this case the "alt" attribute, into child nodes of the
    element in the shadow tree, using <code><a
    href="#xbltext">xbl:text</a></code>. For accessibility reasons, the
    language of the element is also explicitly forwarded.</p>

  </div>

  <h3 id="processing0"><span class="secno">5.4. </span><dfn
   id="processing2">Processing <code>content</code> Elements</dfn></h3>

  <p><img alt="" class="extra" src="images/xbl_image_1.gif">XBL bindings can
   interleave shadow content around bound elements and their <span><a
   href="#explicit">explicit children</a></span>. They do so using XBL's
   <code><a href="#content0">content</a></code> element. Any number of
   <code><a href="#content0">content</a></code> nodes may be used in a
   binding's content template.

  <p>When a shadow tree is <span><a href="#applied">applied</a></span>
   to a bound element, the child nodes of the bound element must be
   distributed and assigned to the <code><a
   href="#content0">content</a></code> elements in the new shadow
   tree.

  <p>Expressions specified using the <code title="attr-content-includes"><a
   href="#includes">includes</a></code> attribute determine which <code><a
   href="#content0">content</a></code> element a given child is to be placed
   under.

  <p>If no <code title="attr-content-includes"><a
   href="#includes">includes</a></code> attribute is specified, a <code><a
   href="#content0">content</a></code> element is considered generic and will
   match on all content, including text nodes, CDATA nodes, comments, and so
   on.

  <p>If the <code title="attr-content-includes"><a
   href="#includes">includes</a></code> attribute is specified, it must be
   interpreted as a <span><a href="#attributes15">selector</a></span>, and
   only elements that <span title="selectors and shadow scopes"><a
   href="#selectors1">match the selector</a></span> apply to that insertion
   point. If the selector is invalid, the <code><a
   href="#content0">content</a></code> element does not match any nodes.
   Matching of the elements to the selector is done without taking into
   account the shadow tree in which the insertion point itself is found. <a
   href="#refsSELECTORS">[SELECTORS]</a>

  <p>Nodes never match selectors whose subject is a pseudo-element.

  <p>The <code><a href="#content0">content</a></code> element initially used
   for a given node must be the first encountered with an expression that
   matches the element and that is not <span title="attr-content-locked"><a
   href="#locked">locked</a></span> when doing a pre-order, depth-first walk
   of the content template, ignoring any descendants of <code><a
   href="#content0">content</a></code> elements (so a <code><a
   href="#content0">content</a></code> element that is the descendant of
   another <code><a href="#content0">content</a></code> element within the
   same shadow tree must be ignored.

  <p>The <span><a href="#explicit">explicit children</a></span> must be
   processed in order, so if two nodes match an insertion point, their order
   in the insertion point is the same as their relative order in the <span><a
   href="#explicit">explicit children</a></span> list.

  <p>If an explicit child of the bound element does not match any of the
   <code><a href="#content0">content</a></code> element in the shadow tree
   (or if there are no <code><a href="#content0">content</a></code> elements
   in the shadow tree), then that child does not appear in the <span><a
   href="#final">final flattened tree</a></span>.

  <div class="example">

   <p>Imagine the following simple document:</p>

   <pre>&lt;X&gt;&lt;A/&gt;&lt;B/&gt;&lt;C/&gt;&lt;/X&gt;</pre>

   <p>Imagine that the element X in that document is bound to a binding with
    the following shadow tree template:</p>

   <pre>&lt;template&gt;
 &lt;element&gt;
  &lt;my:T&gt;
   &lt;my:M/&gt;
   &lt;content/&gt;
   &lt;my:N/&gt;
  &lt;/my:T&gt;
 &lt;/element&gt;
&lt;/template&gt;</pre>

   <p>Imagine further that the element T is itself bound to a binding with
    the following template:</p>

   <pre>&lt;template&gt;
 &lt;element&gt;
  &lt;my:R&gt;
   &lt;content includes="N"/&gt;
   &lt;content includes="B"/&gt;
  &lt;/my:R&gt;
 &lt;/element&gt;
&lt;/template&gt;</pre>

   <p>The resulting final flattened tree would be:</p>

   <pre> X
 |
 `-- T
     |
     `-- R
         |
         +-- N
         |
         `-- B</pre>

   <p>In this example, there are two selectors, "N" and "B", both of which
    match just elements with the given tag name.</p>

  </div>

  <p><code><a href="#inherited0">inherited</a></code> elements are handled
   when the shadow tree is cloned, and <code><a
   href="#content0">content</a></code> elements are handled when the shadow
   tree is then attached to the bound element. This ensures that all the
   <code><a href="#content0">content</a></code> elements, from the primary
   generating binding's content template, inherited content
   templates, and fallback content in <code><a
   href="#inherited0">inherited</a></code> elements that were not replaced by
   inherited content templates, are taken into account. (See: <span><a
   href="#rules3">rules for shadow content generation</a></span>.)

  <h3 id="handling0"><span class="secno">5.5. </span>Handling DOM Changes</h3>

  <p>All of the nodes in the shadow tree are live. Whenever an element is
   inserted into, removed from, or appended to the DOM, all the children of
   bound elements must check that their assigned <code><a
   href="#content0">content</a></code> element is still appropriate,
   following all the same rules that applied when first placing <span><a
   href="#explicit">explicit children</a></span> during shadow content
   generation. If one or more nodes stop fitting into any of the <code><a
   href="#content0">content</a></code> elements then they no longer appear in
   the <span><a href="#final">final flattened tree</a></span>. Similarly,
   nodes that previously did not appear in the final flattened tree may start
   matching a <code><a href="#content0">content</a></code> element and thus
   be inserted into the flattened tree.

  <p>It is possible to manipulate the shadow content contained underneath a
   bound element using standard DOM APIs. If shadow content that contains a
   <code><a href="#content0">content</a></code> element is removed, then any
   <span><a href="#explicit">explicit children</a></span> assigned to that
   element are relocated to the first unlocked <code><a
   href="#content0">content</a></code> elements that match them.

  <p><code><a href="#content0">content</a></code> elements may be dynamically
   locked by manipulating their <code title="attr-content-locked"><a
   href="#locked">locked</a></code> attribute. A locked <code><a
   href="#content0">content</a></code> element cannot accept new children
   unless they are explicitly assigned to it using the <code><a
   href="#xblsetinsertionpoint">xblSetInsertionPoint()</a></code> method.
   However, children already under a locked <code><a
   href="#content0">content</a></code> element must remain there while the
   element's <code title="attr-content-includes"><a
   href="#includes">includes</a></code> attribute (or lack thereof) matches
   them.

  <h3 id="shadow0"><span class="secno">5.6. </span>Shadow Content and CSS</h3>

  <p>Special care should be used when considering the interactions of CSS and
   XBL.

  <h4 id="terminology0"><span class="secno">5.6.1. </span>Terminology</h4>

  <p>Shadow content introduces the concept of <dfn id="shadow9">shadow
   scope</dfn> to nodes within a document. Because shadow content elements
   can also have bindings attached that generate their own shadow content,
   this scoping can be taken to an arbitrary level of nesting.

  <p>Shadow content nodes are in <dfn id="binding-level">binding-level shadow
   scopes</dfn>. Binding scopes are determined by the bound element that
   contains the binding responsible for the generation of the shadow nodes.
   The bound element itself is in the shadow scope of the content around it,
   and its binding's shadow content is in a deeper shadow scope. Shadow
   content that contains no elements that are themselves bound is said to be
   in the deepest, or innermost, shadow scope.

  <p>The resulting tree, after all children have been assigned to <code><a
   href="#content0">content</a></code> elements and all attributes forwarded,
   is called the <dfn id="final">final flattened tree</dfn>, and is the tree
   used by the rendering model. (See: <span><a href="#selectors1">selectors
   and shadow scopes</a></span>.)

  <h4 id="selectors"><span class="secno">5.6.2. </span><dfn
   id="selectors1">Selectors and Shadow Scopes</dfn></h4>

  <p>Bindings can interleave shadow elements between the bound element and
   its <span><a href="#explicit">explicit children</a></span>. (See: <span><a
   href="#processing2">processing <code title="">content</code>
   elements</a></span>.) In this situation, a new tree emerges that is
   different from the explicit content node tree. In addition to having a
   single explicit parent (the bound element) and a single set of children
   (the explicit children in the DOM tree), elements also have a set of
   shadow parents and shadow children (introduced by bindings when <code><a
   href="#content0">content</a></code> elements were used). This necessarily
   affects the CSS model.

  <p><em>Combinators:</em> CSS combinators, in the presence of XBL, must act
   as follows. This is intended to match the definitions of CSS in all cases
   other than when a selector would involve one or more XBL elements.

  <dl>

   <dt>A&gt;B

   <dd>
    <p>If "<code>B.parentNode</code>" is an insertion point (a <code><a
     href="#content0">content</a></code> element), let "<code>X</code>" be
     "<code>B.parentNode.parentNode</code>", otherwise let "<code>X</code>"
     be "<code>B.parentNode</code>".</p>

    <p>Now if "<code>X</code>" is the root of a shadow tree, but "<code
     title="attr-template-allow-selectors-through"><a
     href="#allow-selectors-through">allow-selectors-through</a></code>" is
     not <code>true</code>, it doesn't match "<code>B</code>". Otherwise, if
     "<code>X</code>" is the root of a shadow tree and "<code
     title="attr-template-allow-selectors-through"><a
     href="#allow-selectors-through">allow-selectors-through</a></code>" is
     <code>true</code>, then let "<code>X</code>" be
     "<code>B.xblBoundElement</code>".</p>

    <p>Then, it matches "<code>B</code>" if the "<code>X</code>" element is
     the "<code>A</code>" element.</p>

   <dt>A&nbsp;B

   <dd>Matches "<code>B</code>" if either "<code>A&gt;B</code>" matches
    "<code>B</code>", or "<code>C&gt;B</code>" matches "<code>B</code>" and
    "<code>A&nbsp;C</code>" matches "<code>C</code>".

   <dt>A+B

   <dd>If "<code>B.previousSibling</code>" is an insertion point (a <code><a
    href="#content0">content</a></code> element), it doesn't match
    "<code>B</code>", otherwise, it matches if
    "<code>B.previousSibling</code>" is "<code>A</code>".

   <dt>A~B

   <dd>Matches "<code>B</code>" if either "<code>A+B</code>" matches
    "<code>B</code>", or if "<code>C+B</code>" matches "<code>B</code>" and
    "<code>A~C</code>" matches "<code>C</code>".
  </dl>

  <div class="example">
   <p>The selector <code>p ~ p</code> never matches any elements in the
    following example, even if the insertion point matches a <code>p</code>
    element:</p>

   <pre>&lt;template>
 &lt;html:p>...&lt;/p>
 &lt;content includes="p"/>
 &lt;html:p>...&lt;/p>

&lt;/template>
   </pre>
  </div>

  <p><em>Pseudo-classes and pseudo-elements:</em> Pseudo-classes and
   pseudo-elements are unchanged in the presence of XBL. They operate
   exclusively on the core DOM.

  <div class="example">
   <p>In particular, note that this means that the selector
    <code>:nth-child(odd)</code> would match both the <code>A</code> and
    <code>B</code> nodes in the following example:</p>

   <pre>&lt;xbl:template>
  &lt;A/>
  &lt;xbl:content>
  &lt;B/>
 &lt;/xbl:template></pre>

   <p>...regardless of the number of nodes that are inserted at the insertion
    point given by the <code><a href="#content0">content</a></code> element
    (whether that be 0, 1, 2, or more nodes).</p>
  </div>

  <p><em>Inheritance:</em> The final modified content tree determines how CSS
   properties (e.g., fonts and colours) are inherited. An element either ends
   up underneath the bound element (just as in original the content model),
   or it ends up being nested through a series of <code><a
   href="#content0">content</a></code> elements. When nested, it inherits
   from the innermost shadow parent.

  <h4 id="the--xbl-bound-element"><span class="secno">5.6.3. </span>The
   <code><a href="#xbl-bound-element">:-xbl-bound-element</a></code>
   Pseudo-Class</h4>

  <p>The <dfn id="xbl-bound-element"><code>:-xbl-bound-element</code></dfn>
   pseudo-class matches any bound element.

  <h4 id="matching"><span class="secno">5.6.4. </span><dfn
   id="matching1">Matching Pseudo-Elements</dfn></h4>

  <p>Shadow nodes may be associated with various pre-defined pseudo-elements
   of the bound element. On any element in the content template, an
   <code title="attr-pseudo"><a href="#xblpseudo0">xbl:pseudo</a></code>
   attribute (in the XBL namespace) can be used to specify the name of the
   pseudo to associate with that element.

  <div class="example">

   <p>For example, once more returning to the HTML file upload control
    example above, the shadow text field can be set up to be considered a
    match for the selector <span>input[type=file]::value</span> as follows.</p>

   <pre>&lt;xbl:binding id="fileUploadControl"&gt;
  &lt;xbl:template&gt;
    &lt;html:input type="text" xbl:pseudo="value"/&gt;
    &lt;html:input type="button" value="Browse..."/&gt;

  &lt;/xbl:template&gt;
&lt;/xbl:binding&gt;</pre>
  </div>

  <p>The pseudo must be given without its leading double colon.

  <p>If the pseudo-element name is not recognised, it is <span><a
   href="#in-error">in error</a></span> and the UA must <span><a
   href="#ignoring">ignore</a></span> the attribute. User agents must not
   automatically recognise any pseudo-element (as this will break
   forwards-compatibility).

  <p>If an element has multiple nodes with the same pseudo-element, then they
   all match the relevant selector. Matching of nodes based on their
   pseudo-element is unaffected by the <code>apply-author-sheets</code>

   attribute.

  <p>The allowed pseudo-elements are:

  <dl>
   <dt>::value

   <dd>Intended to represent the entire rectangular 'interactive area' (or
    the nearest equivalent in non-visual environments) of a text-entry form
    control, specifically excluding the caption.

   <dt>::choices

   <dd>Intended to represent the entire rectangular 'selection area' (or the
    nearest equivalent in non-visual environments) of a list form control,
    specifically excluding the caption.

   <dt>::label

   <dd>Intended to represent the non-interactive area (or the nearest
    equivalent in non-visual environments) of control, typically the caption.

   <dt>::repeat-item

   <dd>Within a repeating sequence, for example generated by the repeat
    construct in XForms, <!-- or the template stuff in XUL --> each repeated
    item could be labelled as matching a pseudo-element ::repeat-item.

   <dt>::icon

   <dd>Intended to represent the icon part of a control, for example the
    picture in a toolbar button or the icon next to a menu item.</dd>

   <!--
    <dt>::XXX</dt>

    <dd>Intended to represent a specific part (or the nearest equivalent
    in non-visual environments) of a XXX control.</dd>
  -->
   <!-- XXX add more from css3-ui -->
  </dl>

  <p>These pseudo-element descriptions are purely advisory, and while authors
   are encouraged to use them for their predefined roles, it is valid to use
   them for other purposes.

  <div class="example">
   <p>The following XBL is part of the definition of a button control.</p>

   <pre>  &lt;xbl:binding id="imageButton"&gt;

    &lt;xbl:template&gt;
      &lt;html:span xbl:pseudo="icon"/&gt;
      &lt;html:span xbl:inherits="xbl:text=title"/&gt;
    &lt;/xbl:template&gt;
  &lt;/xbl:binding&gt;</pre>

   <p>This control could then be used like this:</p>

   <pre>&lt;button title="Save" class="save-button"/&gt;</pre>

   <p>...and styled like this:</p>

   <pre>  button { binding: url(buttons.xml#imageButton); }
  button.save-button::icon {
     content: url(icons/save.png);
  }
  </pre>
  </div>

  <p>In property descriptions, the term "all elements" in the "Applies To:"
   line includes these pseudo-elements, as they map directly to real elements
   in the binding.

  <h3 id="shadow1"><span class="secno">5.7. </span>Shadow Content and
   <code>xml:base</code></h3>

  <p class="note">This section is intended to re-iterate what the
   <code>xml:base</code> specification already states, in case there is any
   question about how <code>xml:base</code> processing should work in shadow
   trees.

  <p>Relative <code>xml:base</code>s on nodes in shadow trees are resolved
   relative to their <code>parentNode</code>, or the
   <code>ownerDocument</code> if there is no <code>parentNode</code>.

  <h3 id="shadow2"><span class="secno">5.8. </span><dfn id="shadow10"
   title="Semantics of non-XBL elements in XBL contexts">Shadow Content and
   Other Things</dfn></h3>

  <div class="big-issue">Things that need to be defined include <em>binding
   to</em> html:script, html:select, html:textarea, MathML nodes, etc (are
   their semantics based on the shadow tree, the <span><a href="#final">final
   flattened tree</a></span>, or the original tree), as well as having
   elements inside the shadow tree such as html:script, html:style, html:map,
   form controls (are they part of the outer form), html:form (does it wrap
   elements that are assigned to <code><a href="#content0">content</a></code>
   elements?), etc.</div>

  <p>Since the processing rules of all non-XBL elements found while
   processing a binding document are not affected by their being part of an
   XBL subtree, there are certain elements that are unlikely to have the
   desired effect when included in content templates. Some of these
   cases are described below.

  <p class="note">While some of these effects may seem peculiar, it must be
   emphasised that they are merely the result of XBL not affecting the
   semantics of these elements at all. It would have been possible to define
   XBL in such a way that the semantics of various elements from the XHTML,
   XML Events, etc, namespaces were modified, but this would have required
   XBL knowing about special elements from a large number of namespaces,
   causing XBL implementations to have large interdependencies.

  <h4 id="general"><span class="secno">5.8.1. </span>General Rules</h4>

  <p>Shadow content is not considered part of an document, so elements that
   are defined to trigger when they are "inserted into the document" do not
   trigger during binding attachment.

  <p>IDs used in shadow content, as seen on XML Events nodes, in XHTML on the
   <code>html:label</code> element's <code>for</code> attribute, and in many
   other places, must be resolved in the context of the <span><a
   href="#shadow9">shadow scope</a></span> and (failing that) the binding
   document, not the scope of the document into which the shadow content is
   inserted.

  <div class="example">
   <p>If a shadow template has an <code>html:img</code> element that has its
    <code>usemap</code> attribute set:</p>

   <pre>&lt;template ...>
  &lt;html:img src="..." usemap="test" alt="..."/>
&lt;/template></pre>

   <p>If the binding is applied to an element in a document containing an
    <code>html:map</code> element with ID "test", that image map will not be
    associated with this image. If the binding document itself contains an
    <code>html:map</code> element with ID "test", however, that
    <em>would</em> be associated with the element (even if it was, say, in
    another binding's template).</p>

   <p>If the template looked like this:

   <pre>&lt;template ...>
  &lt;html:img src="..." usemap="test" alt="..."/>
  &lt;html:map id="test"> ... &lt;/html:map>
&lt;/template></pre>

   <p>...then the <code>img</code> element would always be attached to that
    <code>map</code> element, regardless of the existence of other
    <code>map</code> elements in the binding document.</p>

  </div>

  <p>When an element's processing model is defined in terms of the element's
   child nodes or descendants, shadow trees do not affect the processing
   model (unless this is called out explicitly below). For instance, an HTML
   <code>title</code> element's behaviour in determining the document title
   is unaffected by XBL, even if the <code>title</code> element is bound or
   has bound elements in its descendants.

  <p>When the nodes are cloned, their <code>xml:base</code> data remains as
   it was in the bindings document (see <span>rules for content
   generation</span>). Therefore URIs consisting of just fragment identifiers
   (such as those in <code>url()</code> notation in <code
   title="">style</code> attributes of, e.g., XHTML nodes) refer to resources
   in the bindings document, not content in the bound document or the shadow
   tree.

  <p type="note">This would cause trouble with <span><a
   href="#attribute1">attribute forwarding</a></span>, so the attribute
   forwarding syntax allows attributes to be marked as being <span
   title="type-url"><a href="#url">of type "url"</a></span>.

  <h4 id="stylesheets"><span class="secno">5.8.2. </span><dfn
   id="stylesheets1">Stylesheets Blocks</dfn></h4>

  <p>The semantics of <code>html:style</code> elements is that they introduce
   new styles for their document. Since the document, in the case of anything
   in an XBL subtree, is the bindings document (or the compound document in
   which the XBL subtree is found), <em>that</em> is the document that must
   be affected by such a stylesheet.

  <p>Since the style sheets of such resource documents generally have no
   effect, placing <code>html:style</code> blocks in XBL binding documents is
   usually redundant. Such an element placed in a content template
   does not affect the documents into which the shadow content is later
   inserted during binding attachment.

  <h4 id="script"><span class="secno">5.8.3. </span><dfn id="script3">Script
   Blocks</dfn></h4>

  <p>Script elements, such as <code>html:script</code> and its ilk, are
   typically evaluated only during parsing, or during parsing and when
   inserted into a document. In all cases, however, they are evaluated in the
   context of their owner document. Therefore such elements must only be
   evaluated during initial parsing, in the context of the XBL subtree's
   document, and not during binding attachment.

  <h4 id="event"><span class="secno">5.8.4. </span><dfn id="event8">Event
   Handler Blocks</dfn></h4>

  <p>XML Events elements in the binding document must result in event
   handlers being registered as event listeners on the nodes in the original
   bindings document (including possibly the <code title="template"><a
   href="#template0">template</a></code> node) as described in XML Events.
   They may be included in content templates, but when the shadow
   content template is cloned, the newly cloned event handlers must cause new
   event listeners to be added to their new DOM Core parent nodes. Thus an
   event handler that is the child of an <code><a
   href="#template0">template</a></code> element in the shadow content
   template will never fire once it has been cloned, since the events <span
   title="Event Flow and Targeting Across Shadow Scopes"><a
   href="#event11">do not bubble into the <code>template</code>

   elements</a></span>. <a href="#refsXMLEvents">[XMLEVENTS]</a>

  <p>Event handler blocks that are children of <code><a
   href="#handlers0">handlers</a></code> elements (in particular XML Events
   handler blocks) cause event listeners to be fired when <span><a
   href="#event10">event forwarding</a></span> happens, just like with XBL
   <code><a href="#handler0">handler</a></code> elements.

  <h4 id="html-forms"><span class="secno">5.8.5. </span>HTML Forms</h4>

  <p>Forms and form controls in shadow trees don't interact with form
   controls and <code>form</code> elements in the bound document. Each
   document and shadow tree creates a new scope for forms and form controls.

  <h4 id="svg"><span class="secno">5.8.6. </span>SVG</h4>

  <p><em>Painting:</em> When painting groups, the the user agent must
   paint the nodes according to the final flattened tree.

  <p><em>Text:</em> When rendering text, the user agent must use the
   nodes according to the final flattened tree. (All other processing,
   e.g. handling of combining characters, must then be done as defined
   for SVG.)

  <p><em>ID references and URIs:</em> When a URI identifies an element with
   an <code><a href="#xblshadowtree">xblShadowTree</a></code>, the SVG
   processor must use the first element node given by the element's <code><a
   href="#xblchildnodes">xblChildNodes</a></code> list instead of the element
   itself. If there are no elements, or if there is more than one element,
   then the SVG document is in error. The SVG specification defines how to
   handle documents that are in error.

  <p class="issue">What does this actually mean? Something about
   animate elements in shadow trees referring to the bound element or
   something?

  <div class="example">
   <p>In the following example, the UA would render the string "Hello Cruel
    World".</p>

   <pre>&lt;svg xmlns="http://www.w3.org/2000/svg">
  &lt;defs>
    &lt;b:xbl xmlns:b="http://www.mozilla.org/xbl2">
      &lt;b:binding <span title="attr-binding-element"><a href="#element">element="|world"</a></span>>
        &lt;b:template>
         &lt;b:element>
          &lt;tspan <span title="attr-inherits"><a href="#xblinherits0">b:inherits</a></span>="<span title="xbl:text"><a href="#xbltext">b:text=data</a></span>"/> World
         &lt;/b:element>
        &lt;/b:template>
      &lt;/b:binding>
    &lt;/b:xbl>
  &lt;/defs>
  &lt;text y="50" font-size="12">
    Hello &lt;world xmlns="" data="Cruel"/>
  &lt;/text>

&lt;/svg></pre>
  </div>

  <h3 id="binding2"><span class="secno">5.9. </span><dfn
   id="binding14">Binding Stylesheets</dfn></h3>

  <p>Shadow content nodes and bound elements are styled using stylesheets
   from a number of sources, depending on the values of certain attributes.
   When multiple bindings are applied to the same bound element, the sheets
   from each binding all contribute to the final set of stylesheets to apply;
   the stylesheets of the most derived binding being walked first. For each
   binding, the stylesheets that apply are as follows, in the order given:

  <p><em>Scoped stylesheets:</em> A binding file can load stylesheets using
   the <code><a href="#style0">style</a></code> element. (See: <span><a
   href="#loading7">loading stylesheets</a></span>.) These stylesheets must
   be applied to the bound element and to all shadow content attached to the
   bound element.

  <p>If the binding was attached using CSS, the scoped stylesheets have the
   same CSS origin as the sheet with the rule responsible for the binding.
   Stylesheets used by bindings that are attached using the DOM or using
   <code title="import"><a href="#importing1">&lt;?xbl?&gt;</a></code> are
   treated as author-level sheets.

  <p>When bindings from multiple levels are applied to the same bound
   element, the stylesheets that apply must cascade according to their own
   levels.

  <p class="example">An element E is attached to binding U from the user
   agent stylesheet, and binding A from the DOM, which places A in the author
   level. When the stylesheets that apply to E are sorted, U must be applied
   at the UA level and A at the author level.

  <p><em>Author sheets</em>: While the <code
   title="attr-template-apply-author-sheets"><a
   href="#apply-author-sheets">apply-author-sheets</a></code>
   attribute on the <code><a href="#template0">template</a></code>
   element</a></code> generating the shadow content DOM attribute is
   set to <code>true</code>, the rules specified in any author sheets
   at <span title="shadow scope"><a href="#shadow9">outer shadow
   scopes</a></span> must be applied to the shadow content. Otherwise,
   only those matched through <a href="#pseudo-list">predefined
   pseudo-elements</a> are used, and other author-level sheets in
   higher shadow scopes must not be applied to the shadow
   content. (The bound element is always styled using the sheets of
   higher shadow scopes.)

  <p>By default, stylesheets specified in bindings (as described above) are
   applied only to shadow content generated by bindings attached to the bound
   element and to the bound element itself. A second attribute, <code
   title="attr-content-apply-binding-sheets"><a
   href="#apply-binding-sheets">apply-binding-sheets</a></code>, can be used
   to indicate that all children of the bound element, both shadow and
   explicit, can be styled by the sheets in the binding's document. This can
   be controlled on a per-insertion-point basis. While this attribute is set
   to <code>true</code> on a <code><a href="#content0">content</a></code>
   node in the shadow tree DOM, any nodes that are assigned to that element,
   and any descendants of those nodes, must have the scoped stylesheets of
   the binding (those that apply to the shadow content as described above)
   applied to them too.

  <p>Sheets are always walked from the innermost shadow scope to the
   outermost shadow scope (with rules in the outermost shadow scope therefore
   overriding rules of equal specificity in the innermost shadow scope). With
   this ordering a binding that defines a widget can define a default look
   for the widget that can then be easily overridden by a client of the
   widget. For multiple bindings attached to the same element, the sheets are
   walked from the base binding down to the most derived binding.

  <p>User agent sheets and user sheets are always applied to all shadow
   scopes.

  <p>Since styles from both author stylesheets and binding stylesheets are
   applied to the bound element, it is possible for an infinite loop to form
   where an author sets the '-xbl-binding' property to a particular binding
   that then explicitly sets the '-xbl-binding' property to 'none' (or
   another binding). This specification does not take any precautions to
   avoid this, any more than it takes precautions to avoid loops caused by
   binding constructors explicitly calling <code><a
   href="#removebinding">removeBinding()</a></code> to remove the binding
   itself and binding detachment event handlers reattaching the bindings.
   Similar potential loops exist also in underlying technologies, for example
   <code>:hover</code> rules that cause elements to no longer be hovered, or
   focus event handlers that move focus to an element and blur event handlers
   that move focus back to the element.

  <p>In so far as XBL is concerned, authors must avoid constructing such
   loops, and implementers must ensure that such loops do not prevent users
   from interacting with the user agent.

  <h2 id="binding3"><span class="secno">6. </span><dfn id="binding15">Binding
   Implementations</dfn></h2>

  <p>Bindings can define methods and properties on a bound element using the
   <code><a href="#implementation0">implementation</a></code> element. A
   binding implementation provides a new set of methods and properties that
   can be invoked directly from the bound element.

  <p>How the binding implementation is defined depends on the scripting
   language used; the details for some languages are defined below. In
   general, however, the implementation defines a class, and that class is
   instantiated for each binding. The instantiated object must be made
   available through the <dfn
   id="xblimplementation"><code>xblImplementation</code></dfn> DOM attribute
   of the element object. This is a member of the <code><a
   href="#nodexbl1">NodeXBL</a></code> interface, which is implemented by any
   node that supports the XBL processing model. For nodes that aren't
   elements, and for elements that aren't bound elements with an
   implementation, it must return null.

  <p>In the ECMAScript binding, any attempts to access members of
   <code>Element</code> object that do not correspond to methods or
   properties on the <code>Element</code> object but do correspond to members
   of the <code><a href="#xblimplementation0">xblImplementation</a></code>

   object must be forwarded to the <code><a
   href="#xblimplementation0">xblImplementation</a></code> object.

  <h3 id="the-xblimplementation"><span class="secno">6.1. </span>The <code><a
   href="#xblimplementation0">XBLImplementation</a></code> Interface</h3>

  <p>Authors can have their <code><a
   href="#implementation0">implementation</a></code> implement the <code><a
   href="#xblimplementation0">XBLImplementation</a></code> interface (in
   addition to any other interfaces it might implement) if they wish to
   receive notifications of the binding's state with respect to its
   environment.

  <pre
   class="idl">interface <dfn id="xblimplementation0">XBLImplementation</dfn> {
  void <span><a href="#xblbindingattached">xblBindingAttached</a></span>();
  void <span><a href="#xblentereddocument">xblEnteredDocument</a></span>();
  void <span><a href="#xblleftdocument">xblLeftDocument</a></span>();
};</pre>

  <p>The <dfn id="xblbindingattached"><code>xblBindingAttached()</code></dfn>
   method is called by the user agent after the binding has been attached.
   (See: <span><a href="#binding13">binding attachment model</a></span>.)

  <p>The <dfn id="xblentereddocument"><code>xblEnteredDocument()</code></dfn>
   method is called by the user agent when the bound element, or one of its
   ancestors, or one of the elements in a higher shadow scope, is inserted
   into the document, and when the binding is originally attached, if the
   bound element is already in the document. (See: <span><a
   href="#binding13">binding attachment model</a></span>, <span><a
   href="#handling2">handling insertion and removal from the
   document</a></span>.)

  <p>The <dfn id="xblleftdocument"><code>xblLeftDocument()</code></dfn>

   method is called by the user agent when the bound element, or one of its
   ancestors, or one of the elements in a higher shadow scope, is removed
   from the document. (See: <span><a href="#handling2">handling insertion and
   removal from the document</a></span>.)

  <p>If the <code><a href="#implementation0">implementation</a></code> does
   not define one of these methods, then when that method is invoked, nothing
   happens. (As if every binding inherited from a base binding that
   implemented these methods as no-ops.)

  <h3 id="inheritance"><span class="secno">6.2. </span><dfn
   id="inheritance1">Inheritance of Implementations</dfn></h3>

  <p>When two bindings in an inheritance chain both supply implementations,
   the derived binding's implementation inherits from the base binding's
   implementation. Method and property lookups are dynamic. Without
   disambiguating, if two bindings define the same method or property, then
   the most derived binding's method or property must be used.

  <p>Implementations can be named using a <code
   title="attr-implementation-name"><a href="#name">name</a></code> attribute
   specified on the <code><a
   href="#implementation0">implementation</a></code> element. When an
   implementation has a name, that name can be used to disambiguate the
   desired method or property. How this works depends on the language used.

  <h3 id="ecmascript"><span class="secno">6.3. </span><dfn
   id="ecmascript1">ECMAScript Bindings</dfn></h3>

  <p>If the content is inline in the <code><a
   href="#implementation0">implementation</a></code> element, UAs must
   concatenate all the textual contents of text and CDATA child nodes, and
   must <span><a href="#ignoring">ignore</a></span> any other, non-text nodes
   (such as elements and comments) along with all their children. All
   descendant elements must be processed, though, according to their
   semantics, before the XBL implementation is evaluated, as for script
   blocks. (See: <span><a href="#loading6">loading and running
   scripts</a></span>)

  <p>If the content is in an external file, and that file is available and of
   the right type, then the contents are used literally.

  <p>Regardless of the source, the processing is the same. The implementation
   script is evaluated as an ECMAScript Program (as defined in ECMA-262
   Edition 3, section 14), in the scope of the binding document. If the
   result is of <code>Object</code> type, then it is used as the prototype
   for the implementation of this binding. Otherwise, it is <span><a
   href="#in-error">in error</a></span>, and there is no implementation for
   this binding. <a href="#refsECMA262">[ECMA262]</a>

  <p>In an implementation definition, the names of base bindings can be used
   to identify specific methods using dot-notation.

  <div class="example">
   <p>For example, given a binding with an implementation
    <code>ColorPickerGrid</code> that derives from an implementation
    <code>ColorPicker</code> where the two implementations both specify the
    <code>setColor</code> method, a caller could invoke
    <code>ColorPicker</code>'s method with the following syntax:</p>

   <pre>... // myElement is bound to a ColorPickerGrid
myElement.implementation.ColorPicker.setColor(); // Calls the ColorPicker method.
myElement.implementation.setColor(); // Calls the ColorPickerGrid method.
...</pre>
  </div>

  <p>In addition to being able to specifically name a base class, the name
   <code>baseBinding</code> can be used to specify the method or property on
   the base binding without necessarily knowing what the base class is. This
   situation can occur when bindings implicitly inherit, e.g., through the
   use of <code><a href="#addbinding">addBinding</a></code>.

  <pre
   class="example">baseBinding.setColor(); // Calls the ColorPicker method.</pre>

  <h2 id="event0"><span class="secno">7. </span><dfn id="event9">Event
   Handlers</dfn></h2>

  <h3 id="event1"><span class="secno">7.1. </span><dfn id="event10">Event
   Forwarding</dfn></h3>

  <p>Whenever an event passes through a bound element, whether during the
   capture, target, or bubble phases, the user agent must also invoke any
   appropriate event listeners attached to the binding's first <code><a
   href="#handlers0">handlers</a></code> element.

  <p>When events are forwarded in this manner, the event handlers attached to
   the <code><a href="#handlers0">handlers</a></code> element must fire after
   all the event handlers on the bound element itself (whether in the
   capture, target, or bubble phase). Since XBL handlers usually constitute
   the default actions for a widget, this allows authors in the bound
   document to write event handlers that potentially suppress the actions
   taken by the XBL handlers (by using the
   <code>stopImmediatePropagation()</code> method).

  <p>Within an XBL inheritance chain, event handlers must fire first on the
   most derived binding and then on its inherited binding, continuing all the
   way up the chain to the base binding. A derived handler then has a way of
   preventing the event from flowing to its base binding handlers (again by
   using the <code>stopImmediatePropagation()</code> method).

  <p>Event handlers may be attached to the <code><a
   href="#handlers0">handlers</a></code> element using any method, including
   DOM3 Events' <code>addEventListener()</code> method and the <code><a
   href="#handler0">handler</a></code> XBL element. All event handlers
   registered on the first <code><a href="#handlers0">handlers</a></code>

   element of the binding are considered, not just those attached using the
   <code><a href="#handler0">handler</a></code> element.

  <div class="example">
   <p>In the following example, the bound element is the <code>hotspot</code>
    element. When either it is clicked or the element inside it is clicked,
    an alert is generated containing the text "Hello World".</p>

   <p>The bound document is:</p>

   <pre>&lt;hotspot message="Hello World"&gt;
  &lt;instruction&gt; Activate this text. &lt;/instruction&gt;
&lt;/hotspot&gt;</pre>

   <p>The binding is:</p>

   <pre>&lt;binding&gt;
  &lt;handlers&gt;
    &lt;handler event="click"&gt;
      alert(event.currentTarget.getAttribute('message'));
    &lt;/handler&gt;
  &lt;/handlers&gt;
&lt;/binding&gt;</pre>

   <p>Note that the event object passed to the <code><a
    href="#handlers0">handlers</a></code>'s handlers is the same as would
    have been passed to event handlers registered directly on the bound
    element. This is why <code>currentTarget</code> in this example points to
    the bound element.</p>
  </div>

  <h3 id="registering"><span class="secno">7.2. </span><dfn
   id="registering1">Registering Event Handlers with the <code>handler</code>

   Element</dfn></h3>

  <p>Whenever the <code>event</code> or <code>phase</code> attributes of an
   XBL <code><a href="#handler0">handler</a></code> element change, or
   whenever a <code><a href="#handler0">handler</a></code> element's parent
   changes, an event listener must be registered on the element's parent
   element, if it has one; and if an event listener had previously been
   registered for that <code><a href="#handler0">handler</a></code> element,
   it must be removed.

  <p class="issue">This implies that <code><a
   href="#handler0">handler</a></code> elements can be used anywhere, not
   just in <code><a href="#handlers0">handlers</a></code>. That seems
   over-enthusiastic.

  <p>In terms of the DOM3 Events <code>addEventListenerNS()</code> method,
   the arguments used when registering the new event listener must be set as
   follows:

  <dl>

   <dt><code>namespaceURI</code>

   <dd>Always <code>null</code> in this version of XBL.

   <dt><code>type</code>

   <dd>The literal value of the <code title="attr-handler-event"><a
    href="#event7">event</a></code> attribute, or the empty string if the
    attribute is missing.

   <dt><code>listener</code>

   <dd>The <code><a href="#handler0">handler</a></code> element itself
    (<code><a href="#handler0">handler</a></code> elements implement the
    <code>EventListener</code> interface, as described below).

   <dt><code>useCapture</code>

   <dd>True if the <code title="attr-handler-phase"><a
    href="#phase">phase</a></code> attribute is present and has the literal
    value <code>capture</code>, otherwise false.

   <dt><code>evtGroup</code>

   <dd>Always <code>null</code> in this version of XBL. (Event listeners
    registered with <code><a href="#handler0">handler</a></code> elements are
    registered in the default event group.)
  </dl>

  <p>Thus, the <code title="attr-handler-event"><a
   href="#event7">event</a></code> attribute specifies the event type, and
   the <code title="attr-handler-phase"><a href="#phase">phase</a></code>

   attribute the listener type. If the <code title="attr-handler-event"><a
   href="#event7">event</a></code> attribute is missing or its value is the
   empty string, it is <span><a href="#in-error">in error</a></span>. If the
   <code title="attr-handler-phase"><a href="#phase">phase</a></code>
   attribute is present but has a value other than the literal strings
   <code>capture</code> and <code>default</code>, it is <span><a
   href="#in-error">in error</a></span>. (However, their being in error does
   not affect the processing model described above.)

  <p><code><a href="#handler0">handler</a></code> elements must implement the
   <code>EventListener</code> interface, exposing it to scripts using
   binding-specific casting methods. When the <code>handleEvent()</code>

   method of that interface is invoked, user agents must check any relevant
   filters specified on the element. If any of them fail to match the event,
   then the <code>handleEvent()</code> method must do nothing else in this
   invocation. (The filter attributes are defined in the next few sections.)

  <p>Otherwise, if all the filters match, then the user agent must execute
   the contents of the <code><a href="#handler0">handler</a></code> element,
   treating it as being in the language specified by the <code
   title="attr-xbl-script-type"><a href="#script-type">script-type</a></code>
   attribute. (See: <span><a href="#loading6">loading and running
   scripts</a></span>.) The script script must be run in the context of the
   binding document (and not, e.g., in the bound document's context).

  <p>The <code title="attr-handler-propagate"><a
   href="#propagate">propagate</a></code> attribute specifies whether, after
   processing all listeners at the current node, the event is allowed to
   continue on its path (either in the capture or the bubble phase). The
   possible values are <code>stop</code> and <code>continue</code> (the
   default). If <code>stop</code> is specified, then after the event handler
   has been fired, the event's <code>stopPropagation()</code> method must be
   called.

  <p>The <code title="attr-handler-default-action"><a
   href="#default-action">default-action</a></code> attribute specifies
   whether, after processing of all listeners for the event, the default
   action for the event (if any) should be performed or not. For instance, in
   XHTML the default action for a mouse click on an <code>html:a</code>

   element or one of its descendents is to traverse the link. The possible
   values are <code>cancel</code> and <code>perform</code> (the default). If
   <code>cancel</code> is specified, then after the event handler has been
   fired, the event's <code>preventDefault()</code> method must be called.

  <p>The <code title="attr-handler-trusted"><a
   href="#trusted">trusted</a></code> attribute is a filter that, if set to
   the value <code>true</code>, matches only events whose <code><a
   href="#trusted0">trusted</a></code> attribute is true. Otherwise, if it
   has another value or if it is not specified, any event matches this
   filter. This filter can be used regardless of the type of the event.

  <p>In addition to the <code title="attr-handler-trusted"><a
   href="#trusted">trusted</a></code> filter, event-specific filters may be
   used, as described in the following sections. Only filters appropriate to
   the given event type may be used; all other filter attributes, if
   specified, are <span><a href="#in-error">in error</a></span> and UAs must
   <span><a href="#ignoring">ignore</a></span> them.

  <h3 id="mouse"><span class="secno">7.3. </span><dfn id="mouse1">Mouse Event
   Handler Filters</dfn></h3>

  <p>For events that use or derive from the <code>MouseEvent</code>
   interface, three event-specific filter attributes may be used. <a
   href="#refsDOM3EVENTS">[DOM3EVENTS]</a>

  <p>The filters are:

  <dl>
   <dt><code title="attr-handler-button"><a href="#button">button</a></code>

   <dd>A <span><a href="#attributes16">space-separated</a></span> list of
    values, at least one of which must exactly match the <code>button</code>
    attribute on the event object for the XBL event handler to fire. If the
    attribute is not specified, then any value of the <code>button</code>
    attribute on the event object must be considered a match.

   <dt><code title="attr-handler-click-count"><a
    href="#click-count">click-count</a></code>

   <dd>A <span><a href="#attributes16">space-separated</a></span> list of
    values, at least one of which must exactly match the <code>detail</code>

    attribute on the event object for the XBL event handler to fire. If the
    attribute is not specified, then any value of the <code>detail</code>
    attribute on the event object must be considered a match. Note that this
    is checked for <em>any</em> event that uses the <code>MouseEvent</code>
    interface, not just those for which <code>detail</code> is defined.
    Authors should take care to not specify this attribute with, for example,
    <code>mouseover</code> events, since in that context <code>detail</code>

    is undefined.

   <dt><code title="attr-handler-modifiers"><a
    href="#modifiers1">modifiers</a></code>

   <dd>See <span><a href="#modifiers2">modifiers</a></span>.
  </dl>

  <h3 id="key-event"><span class="secno">7.4. </span><dfn id="key-event1">Key
   Event Handler Filters</dfn></h3>

  <p>For events that use or derive from the <code>KeyboardEvent</code>

   interface, three event-specific filter attributes may be used. <a
   href="#refsDOM3EVENTS">[DOM3EVENTS]</a>

  <p>The filters are:

  <dl>
   <dt><code title="attr-handler-key"><a href="#key">key</a></code>

   <dd>The key identifier. If specified, the value must be an exact literal
    match of the <code>keyIdentifier</code> attribute of the event object.
    For example, <code>Enter</code>. If this filter is specified but the
    <code title="attr-handler-modifiers"><a
    href="#modifiers1">modifiers</a></code> attribute is not, the user agent
    must act as if the <code title="attr-handler-modifiers"><a
    href="#modifiers1">modifiers</a></code> attribute had been set with the
    value "<code>none</code>".

   <dt><code title="attr-handler-key-location"><a
    href="#key-location">key-location</a></code>

   <dd>A <span><a href="#attributes16">space-separated</a></span> list of
    values from the four literal (case-sensitive) keywords
    <code>standard</code>, <code>left</code>, <code>right</code>, and
    <code>numpad</code>, which map to the DOM values 0x00, 0x01, 0x02, or
    0x03 respectively. If specified, the event object's
    <code>key-location</code> attribute must have a value equal to the
    numeric value of one of the specified keywords. Unknown and duplicate
    values are <span><a href="#in-error">in error</a></span> and UAs must
    <span><a href="#ignoring">ignore</a></span> them (although without
    dropping any <span><a href="#correct">correct</a></span> values).

   <dt><code title="attr-handler-modifiers"><a
    href="#modifiers1">modifiers</a></code>

   <dd>See <span><a href="#modifiers2">modifiers</a></span>.
  </dl>

  <h3 id="text-input"><span class="secno">7.5. </span><dfn
   id="text-input1">Text Input Event Handler Filters</dfn></h3>

  <p>For events that use or derive from the <code>TextEvent</code> interface,
   one event-specific filter attribute may be used. <a
   href="#refsDOM3EVENTS">[DOM3EVENTS]</a>

  <p>The filter is:

  <dl>
   <dt><code title="attr-handler-text"><a href="#text">text</a></code>

   <dd>The text data to match. If specified, the value must be an exact
    literal match of the <code>data</code> attribute of the event object.
  </dl>

  <h3 id="mutation"><span class="secno">7.6. </span><dfn
   id="mutation1">Mutation Event Handler Filters</dfn></h3>

  <p>For events that use or derive from the <code>MutationEvent</code>
   interface, four event-specific filter attributes may be used. <a
   href="#refsDOM3EVENTS">[DOM3EVENTS]</a>

  <p>The filters are:

  <dl>
   <dt><code title="attr-handler-prev-value"><a
    href="#prev-value">prev-value</a></code>

   <dd>If specified, the value must be an exact literal match of the
    <code>prev-value</code> attribute of the event object.

   <dt><code title="attr-handler-new-value"><a
    href="#new-value">new-value</a></code>

   <dd>If specified, the value must be an exact literal match of the
    <code>new-value</code> attribute of the event object.

   <dt><code title="attr-handler-attr-name"><a
    href="#attr-name">attr-name</a></code>

   <dd>If specified, the value must be an exact literal match of the
    <code>attr-name</code> attribute of the event object.

   <dt><code title="attr-handler-attr-change"><a
    href="#attr-change">attr-change</a></code>

   <dd>A <span><a href="#attributes16">space-separated</a></span> list of
    values from the three literal (case-sensitive) keywords
    <code>modification</code>, <code>addition</code>, <code>removal</code>,
    which map to the DOM values 0x00, 0x01, or 0x02 respectively. If
    specified, the event object's <code>attr-change</code> attribute must
    have a value equal to the numeric value of one of the specified keywords.
    Unknown and duplicate values are <span><a href="#in-error">in
    error</a></span> and the UA must <span><a
    href="#ignoring">ignore</a></span> them, although without causing
    <span><a href="#correct">correct</a></span> values to be dropped.
  </dl>

  <p>There are currently no attributes specifically designed to be used with
   events that use the <code>MutationEventName</code> interface.

  <h3 id="modifiers"><span class="secno">7.7. </span><dfn
   id="modifiers2">Modifiers</dfn></h3>

  <p>The <code title="attr-handler-modifiers"><a
   href="#modifiers1">modifiers</a></code> attribute specifies a filter
   dependent on which keyboard accelerator keys ("modifiers") are set.

  <p>The attribute is a <span><a
   href="#attributes16">space-separated</a></span> list of values.

  <p>To process this filter, the user agent must first invoke the
   <code>getModifierState()</code> method of the event for all the modifiers
   the UA supports, noting the return value for each modifier. The user agent
   must then walk through all the values in the <code
   title="attr-handler-modifiers"><a href="#modifiers1">modifiers</a></code>

   attribute, as described in the list below. The filter matches if all the
   modifiers that returned true are accounted for, and none of the values
   made the filter fail.

  <p class="note">The <code>getModifierState()</code> method, and the
   modifiers that go with it, are defined in DOM3 Events. <a
   href="#refsDOM3EVENTS">[DOM3EVENTS]</a>

  <p>By default, only the <code>CapsLock</code>, <code>NumLock</code>, and
   <code>Scroll</code> modifiers are accounted for. Values on the attribute
   cause other modifiers to be accounted for.

  <p>Before comparing the modifiers to the attribute values, the user agent
   must convert all the modifiers to lowercase.

  <p>User agents must recognise the <code>accel</code> keyword as a synonym
   for the modifier that is the primary accelerator key on the platform (on
   Windows, this would typically be <code>control</code>, on Mac it would
   typically be <code>meta</code>).

  <p>User agents must also recognise the <code>access</code> keyword as a
   synonym for the primary shortcut mnemonic key on the platform (on Windows,
   this would typically be <code>alt</code>).

  <p>The attribute values must be handled as follows:

  <dl>

   <dt><code>any</code>

   <dd>If the keyword <code>any</code> is specified, then all the modifiers
    are accounted for.

   <dt><code>none</code>

   <dd>The keyword <code>none</code> makes the filter fail if any modifiers
    returned true, except for the <code>CapsLock</code>,
    <code>NumLock</code>, and <code>Scroll</code> modifiers, which are
    ignored for the purposes of this keyword.

   <dt><code>+<var>modifier</var></code>

   <dd>The <var>modifier</var> modifier is accounted for. If the given
    modifier does not correspond to the lowercase version of one of the
    modifiers supported by the UA, or if the <code>getModifierState()</code>
    method did not actually return true for the corresponding modifier, then
    it makes the filter fail.

   <dt><code>-<var>modifier</var></code>

   <dd>If the <code>getModifierState()</code> method returned true for the
    modifier corresponding to <var>modifier</var>, then it makes the filter
    fail.

   <dt><code><var>modifier</var>?</code>

   <dd>The <var>modifier</var> modifier is accounted for. If the
    <code>getModifierState()</code> method did not actually return true for
    the modifier corresponding to <var>modifier</var>, the value is ignored.

   <dt>Anything else ("<code><var>modifier</var></code>")

   <dd>Treated the same as <code>+<var>modifier</var></code>.
  </dl>

  <p>A modifier can be listed multiple times, though this is not
   particularily useful.

  <div>
   <p>Here are some examples of what this means:</p>

   <dl>
    <dt><code title="">modifiers</code> not specified

    <dd>The modifiers are ignored, unless the <code
     title="attr-handler-key"><a href="#key">key</a></code> attribute is
     specified, in which case there must be no modifiers pressed for the
     event handler to be invoked.

    <dt><code title="">modifiers=""</code>

    <dt><code title="">modifiers="none"</code>

    <dd>The event handler is only invoked if no modifiers are pressed.

    <dt><code title="">modifiers="any"</code>

    <dd>The modifiers are ignored.

    <dt><code title="">modifiers="alt control"</code>

    <dd>The filter matches if both alt and control were pressed, and no
     others.

    <dt><code title="">modifiers="alt control?"</code>

    <dd>The filter matches if alt was pressed, and no others, except maybe
     control.

    <dt><code title="">modifiers="any -control"</code>

    <dd>The filter matches if the control key was not pressed, regardless of
     the state of other modifiers.

    <dt><code title="">modifiers="Alt"</code>

    <dd>Never matches, since the user agent must compare the given values to
     <em>lowercase</em> modifier names.

    <dt><code title="">modifiers="accel -capslock"</code>

    <dd>Matches when the platform's accelerator key is pressed, but only if
     the caps lock key is not active.

    <dt><code title="">modifiers="alt alt alt"</code>

    <dd>Same as just listing the alt modifier once: the filter matches if
     only the alt modifier is pressed.

    <dt><code title="">modifiers="+alt -accel"</code>

    <dd>Matches when the platform's accelerator key is pressed, but the alt
     modifier is not pressed. If the platform's accelerator key is in fact
     the alt key, this filter can never match.
   </dl>
  </div>

  <h3 id="event2"><span class="secno">7.8. </span><dfn id="event11">Event
   Flow and Targeting Across Shadow Scopes</dfn></h3>

  <p>DOM events can fire on shadow targets just as they can on explicit
   targets. As long as the event flows within the same shadow tree <span
   title="shadow scope"><a href="#shadow9">scope</a></span>, it is no
   different from the behaviour outlined in the DOM Events specification.

  <p>Events must flow through the final transformed content model (the
   <span><a href="#final">final flattened tree</a></span>) after all elements
   have been repositioned through the usage of <code><a
   href="#content0">content</a></code> elements.

  <p>Whenever events originating from a shadow tree flow from a shadow
   element in that shadow tree to the bound element, one of two actions
   occurs. Either the event is retargeted so that the bound element becomes
   the target, or the event is stopped and flow proceeds to the next phase.
   Whenever an event is retargeted, the event is cloned, with the clone's
   <code>target</code> field set to the bound element. The original event
   pointing at the shadow content responsible for the event can be obtained
   from a new field of the event object, <code><a
   href="#originalevent">originalEvent</a></code>, which is set to the event
   that was cloned.

  <p>The <code>currentTarget</code> of the <code><a
   href="#originalevent">originalEvent</a></code> is set to null.

  <p>The action taken (retarget vs. stop) is specific to the event type. In
   general, UI events must be retargeted and mutation events must be stopped.
   Exceptions to the rule are noted below. The goal of this retargeting or
   stopping is to stop outer shadow scopes from being exposed to nodes from
   inner shadow scopes, and to stop outer shadow scopes from getting
   apparently meaningless events that only make sense in the context of inner
   shadow scopes.

  <p>During the capture phase, the semantics are exactly reversed. The first
   node to see the event is the node after which bubbling stops; and the
   target node, when the event is passing through a node at a higher shadow
   scope than the event target, is always the bound element in whose shadow
   content the event target lies. The <code><a
   href="#originalevent">originalEvent</a></code> chain leads from the event
   for the outermost scope to the event at the scope of the original target
   element (whose event's <code><a
   href="#originalevent">originalEvent</a></code> attribute is null).

  <p>Events do not bubble into deeper scopes; for example, an event fired on
   a bound element's <span title="explicit children"><a
   href="#explicit">explicit child</a></span> does not bubble into the
   <code><a href="#content0">content</a></code> element of the insertion
   point that the element was positioned under. If a binding wants to catch
   events occuring to its bound element's explicit children, it can register
   event handlers on the bound element itself (e.g. using <span title="event
   handlers"><a href="#event9">XBL event handlers</a></span>).

  <h3 id="focus"><span class="secno">7.9. </span>Focus, DOMFocusIn, Blur, and
   DOMFocusOut Events</h3>

  <p>If shadow content underneath a focusable bound element loses focus and
   shadow content also underneath the bound element takes focus, then both
   focus change events must be stopped. As far as the bound element is
   concerned, it retains focus throughout the two events. (Other
   specifications may go into more detail as to how to determine if an
   element can be focussed.)

  <p>The <span>'nav-index'</span> property defined in the CSS UI module <a
   href="#refsCSS3UI">[CSS3UI]</a> can be used to specify the tab order for
   focusable elements. This property can be specified on shadow content. Each
   shadow scope has a unique tab order. The <span>'nav-index'</span> values
   used in one shadow scope are ignored by other shadow scopes. The tab order
   is resolved in the shadow tree first to produce a list of elements in the
   tab order. This list is substituted in place of the bound element in the
   bound element's tree tab order.

  <div class="example">
   <p>As an example, consider the HTML file upload control. It is a focusable
    element that in turn is made up of two focusable shadow elements: a text
    field and a button. Tab indices can be specified on the text field and
    the button to indicate the order in which the components of the file
    control should be accessed when tabbing.</p>

   <p>When the user tabs such that the file control should become focused,
    the user agent determines if any shadow content should also become
    focused, using the tab order specified by the shadow content elements. It
    then generates a focus event on the text field inside the file control.
    As this event flows across shadow scopes, it is retargeted to be a focus
    event on the file control itself.</p>

   <p>Focus events should also be stopped if the bound element is already
    focused. For example, if the user has already focused the text field
    within an HTML file upload control, then the file upload control is now
    also focused. If the user then focuses the button inside the file upload
    control, the focus event generated for the button is stopped before it
    reaches the file control, since the file control is already focused.</p>
  </div>

  <p>Because content in multiple shadow scopes can be focused, the CSS
   <code>:focus</code> pseudo-element is hierarchical in the presence of XBL,
   with up to one element in each shadow scope matching the pseudo-class.
   Style rules can be written with the assumption that they will match (in
   the above example) both the file control and the element focused inside
   the file control. In other words, an arbitrary chain of elements can be in
   the <code class="css">:focus</code> state at the same time. (Further
   specifications may describe this in more detail.)

  <h3 id="mouseover"><span class="secno">7.10. </span>Mouseover and Mouseout
   Events</h3>

  <p>Mouseover and mouseout events must be retargeted if the pointing device
   genuinely moves onto (enters) or is moved away (exits) the bound element
   (in addition to entering or exiting some shadow content). If, however, the
   user has simply moved the pointing device from one element in the shadow
   tree to another element in the same shadow tree, without entering or
   exiting the bound element itself, then the event must be stopped.

  <div class="example">
   <p>For example, if the user enters the HTML file upload control from the
    left, a mouseover event is generated for the shadow text field. Because
    this event also constitutes a mouseover of the file control itself, the
    event is retargeted when it flows across shadow scopes. If the user then
    moves the mouse from the text field to the button, a mouseout is
    generated for the text field, followed by a mouseover of the button.</p>

   <p>Since neither of these events constitutes a mouseover or mouseout of
    the file control itself, the events are not allowed to flow to the file
    control. If the user continues moving to the right and leaves the button,
    then the mouseout generated will be retargeted, since the file control
    will also have been exited.</p>
  </div>

  <h2 id="dom-interfaces"><span class="secno">8. </span><dfn
   id="dom-interfaces1">DOM Interfaces</dfn></h2>

  <p>XBL introduces a few XBL-specific interfaces.

  <h3 id="the-documentxbl"><span class="secno">8.1. </span>The <code><a
   href="#documentxbl">DocumentXBL</a></code> Interface</h3>

  <p>The <code><a href="#documentxbl">DocumentXBL</a></code> interface
   contains methods for loading and obtaining binding documents. The
   interface is implemented by DOM documents that support having their
   elements bound by XBL.

  <p class="big-issue">If the binding is not in the same domain, we should
   not distinguish between failure and success.

  <dl>

   <dt>IDL Definition

   <dd>
    <pre class="idl">interface <dfn id="documentxbl">DocumentXBL</dfn> {
  readonly attribute NamedNodeMap <span><a href="#bindingdocuments">bindingDocuments</a></span>;
  Document <span><a href="#loadbindingdocument">loadBindingDocument</a></span>(in DOMString documentURI);
};</pre>

   <dt>Attributes

   <dd>

    <dl>
     <dt><dfn id="bindingdocuments"><code
      class="attribute-name">bindingDocuments</code></dfn> of type <code
      class="dom">NamedNodeMap</code>, readonly

     <dd>The <code><a href="#bindingdocuments">bindingDocuments</a></code>
      attribute must return a <code>NamedNodeMap</code> of all the binding
      documents loaded by the document. Documents are referenced using their
      URIs as the keys. The <code>NamedNodeMap</code> must be live.
    </dl>

   <dt>Methods

   <dd>
    <dl>
     <dt><dfn id="loadbindingdocument"><code
      class="method-name">loadBindingDocument</code></dfn>

     <dd> The <code><a
      href="#loadbindingdocument">loadBindingDocument</a></code> method must
      synchronously load the specified binding document (unless it has <span
      title="loading external resources"><a href="#loading5">already been
      loaded</a></span>), and any bindings defined by that document must be
      applied to matching elements in the document that corresponds to this
      <code><a href="#documentxbl">DocumentXBL</a></code> object. The method
      must then return the binding document's <code>Document</code> object.
      (See: <span><a href="#binding12">binding attachment and
      detachment</a></span>.) If the load succeeded, it is also added to the
      <code><a href="#bindingdocuments">bindingDocuments</a></code>

      attribute. If the load fails, this method must return null.
      <dl>
       <dt>Parameters

       <dd>
        <dl>
         <dt><code class="parameter-name">documentURI</code> of type <code
          class="dom">DOMString</code>

         <dd>The URI of a binding document.
        </dl>

       <dt>Return Value

       <dd>
        <dl>
         <dt><code>Document</code>

         <dd>The return value of <code><a
          href="#loadbindingdocument">loadBindingDocument()</a></code> is the
          <code>Document</code> object of the binding document that was
          loaded, or <code>null</code> if the load failed.
        </dl>

       <dt>No Exceptions
      </dl>
    </dl>
  </dl>

  <h3 id="the-nodexbl"><span class="secno">8.2. </span>The <dfn
   id="nodexbl0">NodeXBL</dfn> Interface</h3>

  <p>The <code><a href="#nodexbl1">NodeXBL</a></code> interface contains
   methods for accessing shadow content and for obtaining shadow parents in
   the altered model. The interface is implemented by DOM nodes (regardless
   of whether they are currently involved with any XBL processing) and may be
   obtained using binding-specific casting methods on a Node interface.

  <p>All nodes except <code>Notation</code> and <code>Attr</code> nodes must
   implement NodeXBL, not just element nodes.

  <dl>
   <dt>IDL Definition

   <dd>
    <pre class="idl">interface <dfn id="nodexbl1">NodeXBL</dfn> {
  readonly attribute Element       <span><a href="#xblboundelement">xblBoundElement</a></span>;
  readonly attribute NodeList      <span><a href="#xblbindings">xblBindings</a></span>;
  readonly attribute DOMObject     <span><a href="#xblimplementation0">xblImplementation</a></span>;

  XBLTemplateElement <span><a href="#xblgetshadowtemplate">xblGetShadowTemplate</a></span>(in DOMElement bindingElement);

  void <span><a href="#addbinding">addBinding</a></span>(in DOMString bindingURI);
  void <span><a href="#removebinding">removeBinding</a></span>(in DOMString bindingURI);
  boolean <span><a href="#hasbinding">hasBinding</a></span>(in DOMString bindingURI);
};</pre>

   <dt>Attributes

   <dd>
    <dl>
     <dt><dfn class="attribute-name"
      id="xblboundelement"><code>xblBoundElement</code></dfn> of type
      <code>Element</code>, readonly

     <dd>The <code><a href="#xblboundelement">xblBoundElement</a></code>

      attribute must return the bound element whose binding is responsible
      for the generation of the shadow tree that contains this node. This
      attribute enables an author to determine the shadow scope of any
      content node. For content that is not in a shadow tree, the attribute's
      value must be <code>null</code>.

     <dt><dfn class="attribute-name"
      id="xblbindings"><code>xblBindings</code></dfn> of type
      <code>NodeList</code>, readonly

     <dd>For bound elements, the node list returned must contain the <code><a
      href="#binding11">binding</a></code> element for the binding. If the
      binding chain contains multiple bindings, all the <code><a
      href="#binding11">binding</a></code> elements must be listed, with the
      most derived binding first and the base binding last.

     <dt><code><a href="#xblimplementation0">xblImplementation</a></code> of
      type <code>DOMObject</code>, readonly

     <dd>See <span><a href="#binding15">binding implementations</a></span>.
    </dl>

   <dt>Methods

   <dd>
    <dl>
     <dt><dfn id="xblgetshadowtemplate"><code
      class="method-name">xblGetShadowTemplate</code></dfn>

     <dd>The <a href="xblgetshadowtemplate">xblGetShadowTemplate</a>
      method returns the cloned shadow content for an attached binding.

      <dl>
       <dt>Parameters

       <dd>
        <dl>

         <dt><code class="parameter-name">bindingElement</code> of type
           <code>DOMElement</code>

         <dd>A <a href="#the-binding">binding element</a> for a binding
           attached to the node.
        </dl>
 
       <dt>Return Value of type <code><a
         href="#xbltemplateelement1">XBLTemplateElement</a></code>

       <dd>The cloned template element at the root of the shadow content.
         For bindings which have no content template, and for
         bindings that are not attached to the element, returns
         <code>null</code>.

       <dt>Exceptions</dt>

       <dd>

        <dl>
         <dt><code>HIERARCHY_REQUEST_ERR</code>

         <dd>This exception must be raised if the bindingElement
         is not a binding element.
        </dl>

      </dl>

     <dt><dfn id="addbinding"><code
      class="method-name">addBinding</code></dfn>

     <dd> The <code><a href="#addbinding">addBinding</a></code> method must
      attach the specified binding (and any bindings that the binding
      inherits from) to the element. This call is not necessarily
      synchronous. The binding may not be attached yet when the call
      completes.
      <dl>

       <dt>Parameters

       <dd>
        <dl>
         <dt><code class="parameter-name">bindingURI</code> of type
          <code>DOMString</code>

         <dd>A URI that specifies the location of a specific binding to
          attach.
        </dl>

       <dt>No Return Value

       <dt>Exceptions

       <dd>

        <dl>
         <dt><code>HIERARCHY_REQUEST_ERR</code>

         <dd>This exception must be raised if the node is not an element.
        </dl>
      </dl>

     <dt><dfn id="removebinding"><code
      class="method-name">removeBinding</code></dfn>

     <dd> The <code><a href="#removebinding">removeBinding</a></code> method
      must detach the specified binding (and any bindings that the binding
      inherits from explicitly using the <code class="xml">extends</code>

      attribute) from the element. This method can only detach bindings that
      were attached using <code><a href="#addbinding">addBinding</a></code>.
      If the binding in question is not attached to this element (or was
      attached through another attachment mechanism), or if the node is not
      an element, then the method must do nothing.
      <dl>
       <dt>Parameters

       <dd>
        <dl>
         <dt><code class="parameter-name">bindingURI</code> of type
          <code>DOMString</code>

         <dd>A URI that specifies the location of a specific binding to
          detach.
        </dl>

       <dt>No Return Value

       <dt>No Exceptions
      </dl>

     <dt><dfn id="hasbinding"><code
      class="method-name">hasBinding</code></dfn>

     <dd> The <code><a href="#hasbinding">hasBinding</a></code> method must
      walk up the bindings applied to the element and compares each binding's
      URI with the parameter passed. If any of the bindings matches the
      specified URI, then the method must return true, otherwise it must
      return false. This can be used to check if an element has been bound to
      a particular binding in in order to ensure that the expected methods
      and attributes are available. For example widgets may walk up their
      ancestors looking for an element that has been bound to a
      form-container binding in order to locate their scope (so that radio
      buttons may properly be mutually exclusive, or so that a submit button
      can properly submit a form).
      <dl>

       <dt>Parameters

       <dd>
        <dl>
         <dt><code class="parameter-name">bindingURI</code> of type
          <code>DOMString</code>

         <dd>A URI that specifies the location of a specific binding for
          which to look.
        </dl>

       <dt>Returns

       <dd>

        <dl>
         <dt><code>boolean</code>

         <dd><code>true</code> if any of the bindings match the parameter,
          <code>false</code> otherwise.
        </dl>

       <dt>No Exceptions
      </dl>

    </dl>
  </dl>

  <h4 id="scoping"><span class="secno">8.2.1. </span>Scoping and Access Using
   the DOM</h4>

  <p>In effect the shadow content exists in its own insulated pocket within
   the document, its <span><a href="#shadow9">shadow scope</a></span>. Bound
   elements have no knowledge of their shadow children in terms of DOM Core
   <a href="#refsDOM3CORE">[DOM3CORE]</a>. The shadow content is not
   accessible via the <code>childNodes</code> list for the bound element, nor
   is it accessible using <code>firstChild</code>/<code>nextSibling</code> to
   iterate over the children of the bound element.

  <p>The shadow scope of an element can be determined using the <code><a
   href="#xblboundelement">xblBoundElement</a></code> property on the
   <code><a href="#nodexbl1">NodeXBL</a></code> interface. This returns the
   bound element in the enclosing shadow scope that is responsible for the
   shadow node. If invoked on an element that is not in a shadow tree, it
   returns <code>null</code>.

  <p>DOM methods that can be invoked on elements (e.g.,
   <code>getElementsByTagName()</code>) will only see nodes that are in the
   same shadow scope. Methods invoked on the document (e.g., <code
   title="">getElementById</code>) only see nodes that are not in shadow
   trees.

  <p>On shadow content nodes, <code>ownerDocument</code> always points to the
   document from which the nodes were cloned.

  <p>Elements in different shadow scopes may have clashing IDs. IDs need only
   be unique within each shadow scope.

  <h4 id="dom-traversals"><span class="secno">8.2.2. </span><dfn
   id="dom-traversals1">DOM Traversals in the Presence of XBL</dfn></h4>

  <p>When the DOM is navigated using the normal DOM Core attributes, starting
   from the document, the UA must represent the original DOM, with no XBL
   nodes and shadow content, and with children of bound elements in their
   original order.

  <p>The <code><a
   href="#xblshadowtree">xblGetShadowTemplate</a></code> method on
   bound elements returns the element that was cloned from the XBL
   <code><a href="#template0">template</a></code>
   element. Manipulating the shadow content tree must directly affect
   the content under the bound element.  <code><a
   href="#content0">content</a></code> elements may be moved about or
   even removed altogether, <code>xbl:inherits</code> attributes may
   be attached and modified, etc, and all these changes must be
   immediately reflected in the DOM.

  <p>Because each bound element gets its own copy of the cloned template,
   changes to a bound element's shadow content only affect that bound
   element. Other bindings are unaffected.

  <p>If an element is added to the DOM dynamically, its shadow scope is that
   of its parent element. Adding an element as a child of a bound element
   causes that element to be assigned to an appropriate <code><a
   href="#content0">content</a></code> element (if there is one &mdash; if
   there is not, the element does not appear anywhere in the <span><a
   href="#final">final flattened tree</a></span>).

  <h4 id="example"><span class="secno">8.2.3. </span>Example of XBL DOM
   Traversals</h4>

  <div class="example">
   <p>Imagine the following document fragment:</p>

   <pre>...
 &lt;A&gt;
  &lt;B&gt;
   &lt;C/&gt;

   &lt;D/&gt;
  &lt;/B&gt;
 &lt;/A&gt;
...</pre>

   <p>...is bound to the following XBL:</p>

   <pre>&lt;xbl:xbl xmlns:xbl="http://www.mozilla.org/xbl2"&gt;

 &lt;xbl:binding element="B"&gt;
  &lt;xbl:template&gt;
   &lt;xbl:element&gt;
    &lt;P&gt;
     &lt;Q&gt;
      &lt;xbl:content includes="C"&gt;
       &lt;R/&gt;

      &lt;/xbl:content&gt;
     &lt;/Q&gt;
     &lt;xbl:content includes="D"&gt;
      &lt;S/&gt;
     &lt;/xbl:content&gt;
    &lt;/P&gt;
   &lt;/xbl:element&gt;
  &lt;/xbl:template&gt;
 &lt;/xbl:binding&gt;
 &lt;xbl:binding element="Q"&gt;
  &lt;xbl:template&gt;
   &lt;xbl:element&gt;
    &lt;X&gt;
     &lt;Y&gt;
      &lt;xbl:content&gt;
       &lt;Z1/&gt;
      &lt;/xbl:content&gt;
      &lt;xbl:content&gt;
       &lt;Z2/&gt;
      &lt;/xbl:content&gt;
     &lt;/Y&gt;
    &lt;/X&gt;
   &lt;/xbl:element&gt;
  &lt;/xbl:template&gt;
 &lt;/xbl:binding&gt;
&lt;/xbl:xbl&gt;</pre>

   <p>The resulting DOM would look like the following. To read these
    diagrams, use the following key:</p>

   <pre>
      |    Solid/dashed lines represent normal DOM traversal attribute
   ---+--- relationships using childNodes, parentNode, nextSibling,
      |    previousSibling, firstChild, lastChild, etc.

      :    Dotted lines represent the final flattened tree

      )    xblShadowTree

   <p>White-space nodes have, for sanity, been left out of these diagrams.</p>

   <p>DOM view:</p>

   <pre>
   |
   +-- A
       |
       +-- B
           |
           +-- C
           |
           +-- D
</pre>

   <p>Clone of the shadow tree for B elements:</p>

   <pre>
   template
    |
    +-- P
        |
        +-- Q
        |   |
        |   +-- content
        |       |
        |       +-- R
        |
        +-- content
            |
            +-- S
</pre>

   <p>Clone of the shadow tree for Q elements (Q.xblShadowTree):</p>

   <pre>
   template
    |
    +-- X
        |
        +-- Y
            |
            +-- content
            |   |
            |   +-- Z1
            |
            +-- content
                |
                +-- Z2
</pre>

   <p>The xbl traversal for the whole thing:</p>

   <pre>
   :
   :.. A
       :
       :.. B
           :
           :.. P
               :
               :.. Q
               :   :
               :   :.. X
               :       :
               :       :.. Y
               :           :
               :           :.. C
               :           :
               :           :.. Z2
               :
               :.. D
</pre>

   <p>The combined view of the DOM and XBL traversals of the whole thing:</p>

   <pre id="pretty-diagram">
   :|___
   :....A    template
        :|___ )   |
        :... B    |
            :|    |
            :|... P    template
             |   :|____ )    |
             |   :|... Q     |
             |   :|   :|     |
             |   :|   :|.... X
             |   :|    |     :\_______
             |   :|    |     :....... Y __
             |   :|    |              :   \
             |   :|    +-- content*   :    |
             |   :|         |         :    |
             |   :|         +-- R     :    +-- content*
             |   :|                   :    |    |
             +---:|--------- C* ......:    |    `-- Z1
             |   :|                   :    |
             |   :|                   :    `-- content
             |   :|                   :         |___
             |   :|                   :............ Z2
             |   :`-- content#
             |   :     |
             |   :     `-- S
             |___:____
                 :... D# 
</pre>

   </div>

  <h3 id="the-xblcontentelement"><span class="secno">8.3. </span>The <dfn
   id="xblcontentelement0">XBLContentElement</dfn> Interface</h3>

  <p>The <code><a href="#xblcontentelement1">XBLContentElement</a></code>
   interface is implemented by <code><a href="#content0">content</a></code>
   elements that are inside shadow template trees. It can be obtained using
   binding-specific casting methods on the <code>Element</code> interface.

  <p class="issue">Do we want a way to get the nodes currently assigned to a
   <code><a href="#content0">content</a></code> element? <a
   href="http://www.w3.org/mid/D2FA0043-380B-11D9-A577-000393D124C4@fuchsia-design.com">ISSUE</a>

  <dl>
   <dt>IDL Definition

   <dd>
    <pre
     class="idl">interface <dfn id="xblcontentelement1">XBLContentElement</dfn> {
  void <span><a href="#xblsetinsertionpoint">xblSetInsertionPoint</a></span>(in Node child);
};</pre>

   <dt>Attributes

   <dd> None.

   <dt>Methods

   <dd>

    <dl>
     <dt><dfn class="method-name"
      id="xblsetinsertionpoint"><code>xblSetInsertionPoint</code></dfn>

     <dd>
      <p>The <code><a
       href="#xblsetinsertionpoint">xblSetInsertionPoint</a></code> method
       must check that the given element is a child of the same bound element
       as the shadow tree is itself associated with, and, if it is, must
       check that the element matches this <code><a
       href="#content0">content</a></code> element, and, if it does, must
       assign the element to this <code><a
       href="#content0">content</a></code> element instead of whatever
       previous <code><a href="#content0">content</a></code> element it was
       assigned to.</p>

      <p>The order of elements assigned to a <code><a
       href="#content0">content</a></code> element must always be the same as
       the relative order of those elements in the original core DOM.</p>

      <dl>
       <dt>Parameters

       <dd>
        <dl>
         <dt><code class="parameter-name">child</code> of type
          <code>Node</code>

         <dd>The child of the bound element to assign to this <code><a
          href="#content0">content</a></code> element.
        </dl>

       <dt>No Return Value

       <dt>No Exceptions
      </dl>
    </dl>
  </dl>

  <h3 id="the-eventxbl"><span class="secno">8.4. </span>The <code><a
   href="#eventxbl">EventXBL</a></code> Interface</h3>

  <p>Objects that implement the <code>Event</code> interface must also
   implement the <code><a href="#eventxbl">EventXBL</a></code> interface:

  <dl>

   <dt>IDL Definition

   <dd>
    <pre class="idl">interface <dfn id="eventxbl">EventXBL</dfn> {
  readonly attribute Event <span><a href="#originalevent">originalEvent</a></span>;
  readonly attribute boolean <span><a href="#trusted0">trusted</a></span>;
};</pre>
  </dl>

  <p>The <dfn id="originalevent"><code>originalEvent</code></dfn> attribute
   must point to the event that was cloned the last time the event was
   retargeted, if any, and must be null if the event was never retargeted.
   (See: <span><a href="#event11">event flow and targeting across shadow
   scopes</a></span>.)

  <p>If an event is retargeted several times, a chain is formed using this
   attribute, from which script can access each clone of the event, finding
   the original target at each step, if the bindings are from the same
   document. (Trying to access the targets of events that are in shadow trees
   of bindings from external binding documents would <a
   href="#scripting">cause an exception to be raised</a>.)

  <p>The <dfn id="trusted0"><code>trusted</code></dfn> attribute must return
   true if the user agent dispatched the event (e.g. in response to user
   action), and false otherwise (e.g. if an author script dispatched a
   synthetic event).

  <h3 id="the-xbltemplateelement"><span class="secno">8.5. </span>The <dfn
   id="xbltemplateelement0">XBLTemplateElement</dfn> Interface</h3>

  <p>The <code><a href="#xbltemplateelement1">XBLTemplateElement</a></code>
   interface is implemented by <code><a href="#template0">template</a></code>
   elements that are in the XBL namespace.

  <dl>
   <dt>IDL Definition

   <dd>
    <pre class="idl">

interface <dfn id="xbltemplateelement1">XBLTemplateElement</dfn> : Element {
  Element <span><a href="#getelementbyid">getElementById</a></span>(in DOMString elementId);
};
</pre>

   <dt>Attributes

   <dd> None.

   <dt>Methods

   <dd>
    <dl>
     <dt><dfn class="method-name"
      id="getelementbyid"><code>getElementById</code></dfn>

     <dd>
      <p class="note">This method is modelled after the method of the same
       name defined by <a href="#refsDOM3CORE">[DOM3CORE]</a> on the
       <code>Document</code> interface.</p>

      <p>This method must returns an <code>Element</code> that has an ID
       attribute with the given value, and that is a descendant of the
       <code><a href="#template0">template</a></code> element on which it is
       invoked. If more than one such element exists, which one is returned
       is undefined. If no such element exists, this returns the
       <code>null</code>.</p>

      <p class="note">Attributes with the name "ID" or "id" are not of type
       ID unless so defined. For example, attributes with the name "id" on
       elements that are from the XHTML, MathML and XBL namespaces are
       defined to be of type ID by their respective specifications.</p>

      <dl>
       <dt>Parameters

       <dd>
        <dl>
         <dt><code class="parameter-name">elementId</code> of type
          <code>DOMString</code>

         <dd>The unique <code>id</code> value for an element.
        </dl>

       <dt>Returns

       <dd>
        <dl>
         <dt><code>Element</code>

         <dd> The matching element or null if there is none.
        </dl>

       <dt>No Exceptions
      </dl>
    </dl>
  </dl>

  <h3 id="the-xblpresentation"><span class="secno">8.6. </span>The <dfn
   id="xblpresentation0">XBLPresentation</dfn> Interface</h3>

  <p>The <code><a href="#xblpresentation0">XBLPresentation</a></code>
   interface defines the <a href="#scripting">script execution scope</a> for
   binding documents.

  <dl>
   <dt>IDL Definition

   <dd>
    <pre class="idl">

interface <dfn id="xblpresentation0">XBLPresentation</dfn> {

  readonly attribute Document document;

  readonly attribute Document boundDocument;
  readonly attribute AbstractView window;
};
</pre>

   <dt>Attributes

   <dd>
    <dl>
     <dt><dfn class="attribute-name"
      id="pres-document"><code>document</code></dfn> of type
      <code>Document</code>, readonly

     <dd>The binding document.

     <dt><dfn class="attribute-name" id="boundDocument"><code>boundDocument</code></dfn> of type Document, readonly

     <dd>The document for which the binding has been loaded

     <dt><dfn class="attribute-name" id="pres-window"><code>window</code></dfn> of type AbstractView, readonly

     <dd>The abstract view of the bound document.
    </dl>

   <dt>Methods

   <dd>None

  </dl>

  <h2 id="widget"><span class="secno">9. </span>Widget Bindings</h2>

  <p class="big-issue">(to be completed)

  <p>A <dfn id="widget0">widget binding</dfn> is a binding that extends
   either the <span class="css">widget</span> base binding or any of the
   other <dfn id="predefined">predefined base bindings</dfn> for widgets
   listed below.

  <h3 id="base-bindings"><span class="secno">9.1. </span>Predefined Base
   Bindings</h3>

  <p>The following bindings have predefined meaning.

  <dl>
   <dt>widget

   <dd>Implements the <code>value</code> property.

   <dt>native-checkbox

   <dd>...

   <dt>simple-checkbox

   <dd>...

   <dt>widget-scope

   <dd>Implements the <code>submit</code> and <code>reset</code> methods.
  </dl>

  <h2 id="examples"><span class="secno">10. </span>Examples</h2>

  <p>In order to explain how this specification comes together with HTML5 and
   CSS, a future version of this specification will include a few explained
   examples.

  <p class="big-issue">The examples at the moment are very incomplete.

  <h3 id="making"><span class="secno">10.1. </span>Making a Popup Menu Widget</h3>

  <p>At the web page level, the markup for such a widget would look very
   simple:

  <pre>
   &lt;select name="toppings"&gt;

     &lt;option&gt;Cheese&lt;/option&gt;
     &lt;option&gt;Mushrooms&lt;/option&gt;
     &lt;option&gt;Anchovies&lt;/option&gt;
   &lt;/select&gt;

</pre>

  <p>However, behind the simplicity of this markup is a great deal of
   complexity.

  <ol>
   <li>The main widget has a distinct look. <img alt=""
    src="http://developer.apple.com/techpubs/mac/HIGOS8Guide/graphics/HIG_CG-081.gif">

   <li>The widget has a popup state which appears when clicking on the
    widget.
    <p><img alt=""
     src="http://developer.apple.com/techpubs/mac/HIGOS8Guide/graphics/HIG_CG-080.gif">

   <li>The popup's width should be equal to the main widget's width.

   <li>The main widget's width should be such that the widest item can fit.

   <li>When the popup menu appears, the selected item should exactly overlap
    the main widget.
  </ol>

  <p>The main widget look is achieved by binding the
   <code>&lt;select&gt;</code> element to some more complex markup which
   describes the borders, etc. For selects, this specification defines a
   pre-prepared binding:

  <pre>
  select { binding: selects; }
 </pre>

  <p>Each user agent supports a set of <span><a href="#predefined">predefined
   base bindings</a></span>. Alternatively, a specific binding can be used:

  <pre>
  select { binding: url(widgets.xml#select); }
 </pre>

  <p>Here <code>widgets.xml</code> would be a file containing a binding which
   describes the look and feel (also called the style and behaviour) of the
   widget.</p>
  <!-- XXX need MANY more examples -->

  <h2 class="no-num" id="acknowledgments">Acknowledgments</h2>

  <p>David Hyatt developed XBL 1.0 and provided guidance for the development
   of XBL 2.0.

  <p>XBL 2.0 was primarily edited by Ian Hickson.

  <p>The editor would like to thank Alex Danilo, Anne van Kesteren, Axel
   Hecht, Antoine Quint, Bjoern Hoehrmann, Boris Zbarsky, Brendan Eich,
   Cameron McCormack, Chris Lilley, Christophe Jolif, Darryl Fuller, Dean
   Jackson, Jon Ferraiolo, Jonas Sicking, L. David Baron, Lachlan Hunt, Micah
   Dubinko, Peter Sorotokin, Robin Berjon, Ruud Steltenpool, and Tim Rowley
   for their contributions to this specification.

  <h2 class="no-num" id="references">References</h2>

  <dl>
   <dt id="refsCSS3UI">[CSS3UI]

   <dd><cite><a href="http://www.w3.org/TR/2004/CR-css3-ui-20040511/">CSS3
    Basic User Interface Module</a></cite>, T. &Ccedil;elik. W3C, May 2004.
    The latest version of the CSS3 UI module is available at <a
    href="http://www.w3.org/TR/css3-ui">http://www.w3.org/TR/css3-ui</a>

   <dt id="refsDOM3CORE">[DOM3CORE]

   <dd><cite><a
    href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/">Document
    Object Model (DOM) Level 3 Core Specification</a></cite>, A. Le Hors, P.
    Le H&eacute;garet, L. Wood, G. Nicol, J. Robie, M. Champion, S. Byrne.
    W3C, November 2003. The latest version of the DOM Level 3 Core
    specification is available at <a
    href="http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/</a>

   <dt id="refsDOM3EVENTS">[DOM3EVENTS]

   <dd><cite><a
    href="http://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107/">Document
    Object Model (DOM) Level 3 Events Specification</a></cite>, P. Le
    H&eacute;garet, T. Pixley. W3C, November 2003. (Note: Despite its
    non-normative status on the W3C Recommendation track, this specification
    should be considered normative for the purposes of conformance.) The
    latest version of the DOM Level 3 Events specification is available at <a
    href="http://www.w3.org/TR/DOM-Level-3-Events/">http://www.w3.org/TR/DOM-Level-3-Events/</a>

   <dt id="refsECMA262">[ECMA262]

   <dd><cite><a
    href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript
    Language Specification</a></cite>, Third Edition. ECMA, December 1999.
    This version of the ECMAScript Language is available at
    http://www.ecma-international.org/publications/standards/Ecma-262.htm

   <dt id="refsHTC">[HTC]

   <dd>(Informative) <cite><a
    href="http://www.w3.org/TR/1998/NOTE-HTMLComponents-19981023">HTML
    Components</a></cite>, C. Wilson. Microsoft, September 1998. The HTML
    Components submission is available at
    http://www.w3.org/TR/1998/NOTE-HTMLComponents-19981023

   <dt id="refsHTML5">[HTML5]

   <dd><cite><a href="http://whatwg.org/specs/web-apps/current-work/">Web
    Applications 1.0</a></cite>, I. Hickson. WHATWG, work in progress. The
    latest version of the HTML5 proposal is at
    http://whatwg.org/specs/web-apps/current-work/

   <dt id="refsMQ">[MQ]

   <dd><cite><a
    href="http://www.w3.org/TR/2002/CR-css3-mediaqueries-20020708">Media
    Queries</a></cite>, H. Lie, T. &Ccedil;elik, D Glazman. W3C, July 2002.
    The latest version of Media Queries is available at <a
    href="http://www.w3.org/TR/css3-mediaqueries">http://www.w3.org/TR/css3-mediaqueries</a>

   <dt id="refsRFC2119">[RFC2119]

   <dd><cite><a href="http://www.ietf.org/rfc/rfc2119">Key words for use in
    RFCs to Indicate Requirement Levels</a></cite>, S. Bradner. IETF, March
    1997. RFC 2119 is available at http://www.ietf.org/rfc/rfc2119

   <dt id="refsSELECTORS">[SELECTORS]

   <dd><cite><a href="">Selectors</a></cite>, D. Glazman, T. &Ccedil;elik, I.
    Hickson. W3C, November 2001. The latest version of the Selectors
    specification is available at <a
    href="http://www.w3.org/TR/css3-selectors/">http://www.w3.org/TR/css3-selectors/</a>

   <dt id="refsXBL10">[XBL10]</dt>
   <!--   <dd>(Informative) <cite><a href="http://www.w3.org/TR/2001/NOTE-xbl-20010223/">XML Binding Language</a></cite>, D. Hyatt. Mozilla, February 2001. The XBL submission is available at http://www.w3.org/TR/2001/NOTE-xbl-20010223/</dd>-->

   <dd>(Informative) <cite><a
    href="http://www.mozilla.org/projects/xbl/xbl.html">XML Binding
    Language</a></cite>, David Hyatt. Mozilla, November 2000 (and
    subsequently edited by other contributors). The XBL 1.0 specification is
    available at http://www.mozilla.org/projects/xbl/xbl.html

   <dt id="refsXFORMS">[XFORMS]

   <dd>(Informative) <cite><a
    href="http://www.w3.org/TR/2003/REC-xforms-20031014/">XForms
    1.0</a></cite>, M. Dubinko, L. Klotz, R. Merrick, T. Raman. W3C, October
    2003. The latest version of the XForms specification is available at <a
    href="http://www.w3.org/TR/xforms">http://www.w3.org/TR/xforms</a>

   <dt id="refsXML">[XML]

   <dd><cite><a href="http://www.w3.org/TR/2004/REC-xml-20040204/">Extensible
    Markup Language (XML) 1.0 (Third Edition)</a></cite>, T. Bray, J. Paoli,
    C. Sperberg-McQueen, E. Maler, F. Yergeau. W3C, Feburary 2004. The latest
    version of the XML specification is available at <a
    href="http://www.w3.org/TR/REC-xml/">http://www.w3.org/TR/REC-xml/</a>

   <dt id="refsXMLBASE">[XMLBASE]

   <dd><cite><a href="http://www.w3.org/TR/2001/REC-xmlbase-20010627/">XML
    Base</a></cite>, J. Marsh. W3C, June 2001. The latest version of the XML
    Base specification is available at <a
    href="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a>

   <dt id="refsXMLEVENTS">[XMLEVENTS]

   <dd><cite><a href="http://www.w3.org/TR/2003/REC-xml-events-20031014">XML
    Events</a></cite>, S. McCarron, S. Pemberton, T. Raman. W3C, October
    2003. The latest version of the XML Events specification is available at
    <a
    href="http://www.w3.org/TR/xml-events">http://www.w3.org/TR/xml-events</a>

   <dt id="refsXMLNS">[XMLNS]

   <dd><cite><a
    href="http://www.w3.org/TR/1999/REC-xml-names-19990114">Namespaces in
    XML</a></cite>, T. Bray, D. Hollander, A. Layman. W3C, January 1999. The
    latest version of the Namespaces in XML specification is available at <a
    href="http://www.w3.org/TR/REC-xml-names">http://www.w3.org/TR/REC-xml-names</a>

   <dt id="refsXMLSSPI">[XMLSSPI]

   <dd><cite><a
    href="http://www.w3.org/1999/06/REC-xml-stylesheet-19990629/">Associating
    Style Sheets with XML documents</a></cite>, J. Clark. W3C, June 1999. The
    latest version of the Associating Style Sheets with XML documents
    specification is available at <a
    href="http://www.w3.org/TR/xml-stylesheet/">http://www.w3.org/TR/xml-stylesheet/</a>
  </dl>
</html>
<!--XXX WANTED:

some way of initialising internal fields as pointing to the DOM Nodes
of anon content, so that the constructor doesn't have to walk content,
e.g. to set mInputElement in a <textbox> binding containing an <input
type="text">.

A node is inserted into the first insertion point that it matches. If it is
moved (using changeInsertionPoint), then it remains in the new insertion point
while it matches it. If it stops matching that new insertion point, it gets
placed into the first insertion point that it matches. (If it doesn't match any,
then the entire shadow content is removed.) In other words, changes to the
insertion point are "sticky".

If an element is inserted into an insertion point with an empty filter
("includes" list) then it will always match it while that insertion point
exists, and will therefore never move to another insertion point unless the
insertion point is dynamically removed.

 <implementation>
   constructor: function() { this.a = 3; this.b = 4; },
   destructor: function() { ... },
   myFunction1: function(a, b, c) { alert(this.a); },
   myProperty1: get { ... } set { ... }
 </implementation>

<brendan> hyatt: var o = {get p() {return ++this.x;}, set p(y) {return this.x=y;}, x:42};

<stuart> in python you'd need to do def getp(cls): ... setp(): ... p = property(getp,setp)


      <li>Methods and properties with getters/setters are no longer accessible from the binding,
      although fields remain.</li> !- XXX is that last bit true? -

-->
