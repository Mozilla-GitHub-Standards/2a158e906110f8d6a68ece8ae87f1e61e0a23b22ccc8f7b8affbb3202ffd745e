<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="top" title="Home" href="http://www.mozilla.org/">
<link rel="stylesheet" type="text/css" href="../../../css/print.css"  media="print">
<link rel="stylesheet" type="text/css" href="../../../css/base/content.css"  media="all">
<link rel="stylesheet" type="text/css" href="../../../css/cavendish/content.css" title="Cavendish" media="screen">
<link rel="stylesheet" type="text/css" href="../../../css/base/template.css"  media="screen">
<link rel="stylesheet" type="text/css" href="../../../css/cavendish/template.css" title="Cavendish" media="screen">
<link rel="icon" href="../../../images/mozilla-16.png" type="image/png">

		<TITLE>nsCOMPtr FAQ</TITLE>
    <!-- LINK REL=StyleSheet HREF="Standard.css" TYPE="text/css" -->
    <LINK REL=StyleSheet HREF="http://www.mozilla.org/projects/xpcom/Standard.css" TYPE="text/css">
	<script src="../../../__utm.js" type="text/javascript"></script>
</head>
<body id="www-mozilla-org" class="deepLevel">
<div id="container">
<p class="important">You are currently viewing a snapshot of www.mozilla.org taken on April 21, 2008. Most of this content is
highly out of date (some pages haven't been updated since the project began in 1998) and exists for historical purposes only.  If
there are any pages on this archive site that you think should be added back to www.mozilla.org, please <a
href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Websites&component=www.mozilla.org">file a bug</a>.</p>
<p class="skipLink"><a href="#mainContent" accesskey="2">Skip to main content</a></p>
<div id="header">
<h1><a href="/" title="Return to home page" accesskey="1">Mozilla</a></h1>
<ul>
<li id="menu_aboutus"><a href="../../../about/" title="Getting the most out of your online experience">About</a></li>
<li id="menu_developers"><a href="../../../developer/" title="Using Mozilla's products for your own applications">Developers</a></li>
<li id="menu_store"><a href="http://store.mozilla.org/?r=mozorg1" title="Shop for Mozilla products on CD and other merchandise">Store</a></li>
<li id="menu_support"><a href="../../../support/" title="Installation, trouble-shooting, and the knowledge base">Support</a></li>
<li id="menu_products"><a href="../../../products/" title="All software Mozilla currently offers">Products</a></li>
</ul>
<form id="searchbox_002443141534113389537:ysdmevkkknw" action="http://www.google.com/cse" title="mozilla.org Search">
<div>
<label for="q" title="Search mozilla.org's sites">search mozilla:</label>
<input type="hidden" name="cx" value="002443141534113389537:ysdmevkkknw">
<input type="hidden" name="cof" value="FORID:0">
<input type="text" id="q" name="q" accesskey="s" size="30">
<input type="submit" id="submit" value="Go">
</div>
</form>
</div>
<hr class="hide">
<div id="mBody">
<div id="side">

<ul id="nav">
<li><a title="Roadmap" href="../../../roadmap.html"><strong> Roadmap</strong></a></li>
<li><a title="Projects" href="../../../projects/"><strong> Projects</strong></a></li>
<li><a title="For developers" href="../../../developer/"><strong> Coding</strong></a>
<ul>
<li><a title="Module Owners" href="../../../owners.html"> Module Owners</a></li>
<li><a title="Hacking" href="../../../hacking/"> Hacking</a></li>
<li><a title="Get the Source" href="http://developer.mozilla.org/en/docs/Download_Mozilla_Source_Code"> Get the Source</a></li>
<li><a title="Building Mozilla" href="http://developer.mozilla.org/en/docs/Build_Documentation"> Build It</a></li>
</ul>
</li>
<li><a title="Testing" href="../../../quality/"><strong> Testing</strong></a>
<ul>
<li><a title="Downloads of mozilla.org software releases" href="../../../download.html"> Releases</a></li>
<li><a title="Latest mozilla builds for testers" href="../../../developer/#builds"> Nightly Builds</a></li>
<li><a title="For testers to report bugs" href="https://bugzilla.mozilla.org/"> Report A Problem</a></li>
</ul>
</li>
<li><a title="Tools for mozilla developers" href="../../../tools.html"><strong> Tools</strong></a>
<ul>
<li><a title="Bug tracking system for mozilla testers." href="https://bugzilla.mozilla.org/"> Bugzilla</a></li>
<li><a title="Latest status of mozilla builds" href="http://tinderbox.mozilla.org/showbuilds.cgi?tree=Firefox"> Tinderbox</a></li>
<li><a title="Latest checkins" href="http://bonsai.mozilla.org/cvsqueryform.cgi"> Bonsai</a></li>
<li><a title="Source cross reference" href="http://lxr.mozilla.org/seamonkey/"> LXR</a></li>
</ul>
</li>
<li><a title="Frequently Asked Questions." href="../../../faq.html"><strong> FAQs</strong></a></li>
</ul>

</div>
<hr class="hide">
<div id="mainContent">



	

	
		<H1><code>nsCOMPtr</code> FAQ</H1>

<DIV class=author-note>
	<P>by <A HREF="http://www.meer.net/ScottCollins/">Scott Collins</A><!-- /P -->
	<P>last modified 25 October 1999</P>
</DIV>

<div class="document-label">
	<p>
		<strong>Document Status</strong>: <span class="warning"><strong>Retired</strong></span>.
		This document is now obsolete.
		It was never very complete,
			and now it is subsumed by the 
			<a href="http://www.mozilla.org/projects/xpcom/nsCOMPtr.html"><code>nsCOMPtr</code> User's Manual</a>.
		Please use that document as your reference.
	</p>
</div>

<DIV class="editor-note">
	<P>
		This document is very unfinished, but I'm checking it in anyway to facilitate comments.
		I'll be posting updates frequently until it reaches a more complete state.
		I hope that even in its current state, it is still of some help to you.
	</P>
</DIV>


<H2>Introduction</H2>


<H2>The Basics</H2>

<H3>How do I initialize an <code>nsCOMPtr</code>?</H3>

<H3>How do I <code>Release</code> an <code>nsCOMPtr</code> <EMPH>before</EMPH> its destruction?</H3>
<DIV class="source-code">
<PRE class="source-code">
nsCOMPtr&lt;nsIFoo&gt; fooP = ...;

  <SPAN class="comment">// ...</SPAN>

fooP = 0;
</PRE>
</DIV>

<H3>What do I do when I need a normal pointer?</H3>


<DIV class="faq-item">
<H3>What are all these funny modifiers:
	<code>do_QueryInterface</code>, <code>dont_QueryInterface</code>, <code>getter_AddRefs</code>, and <code>dont_AddRef</code>?</H3>
<!-- Well, <A href="msg2.html">this email message</A> describes them in detail. -->
<P>
When you assign a value into an <code>nsCOMPtr</code>, you can elicit special behavior by annotating the
	value with one of these modifiers.
The default behavior, what you are implicitly requesting when you assign an unadorned
	raw COM interface pointer into an <code>nsCOMPtr</code>,
	is equivalent to <code>dont_QueryInterface</code>.
The new value is <code>AddRef</code>ed; nothing else.
</P>

<H4><code>do_QueryInterface( nsISupports* );</code></H4>
<P>
The pointer is <code>QueryInterface</code>d for the COM correct interface,
	and it is <code>AddRef</code>ed (by <code>QueryInterface</code>) as part of the assignment.
Use this when the type you are assigning in is different than your <code>nsCOMPtr</code>, e.g.,
<!-- /P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// Using |do_QueryInterface|...</SPAN>

nsIBar* rawBarP;
nsCOMPtr&lt;nsIBar&gt; barP;
  <SPAN class="comment">// ...</SPAN>

  <SPAN class="comment">// ...|do_QueryInterface| works as well with an |nsCOMPtr| source as with a raw COM interface pointer</SPAN>
nsCOMPtr&lt;nsIFoo&gt; foo0P = <STRONG>do_QueryInterface(</STRONG>rawBarP<STRONG>)</STRONG>;
nsCOMPtr&lt;nsIFoo&gt; foo1P = <STRONG>do_QueryInterface(</STRONG>barP<STRONG>)</STRONG>;
</PRE>
</DIV>

<H4><code>do_QueryInterface( nsISupports*, nsresult* );</code></H4>
<P>
As above, but the error result of <code>QueryInterface</code> is available to you, e.g.,
<!-- /P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// Using |do_QueryInterface|...</SPAN>

nsIBar* rawBarPtr;
  <SPAN class="comment">// ...</SPAN>
nsresult status;
nsCOMPtr&lt;X&gt; x = <STRONG>do_QueryInterface(</STRONG>rawBarPtr, &amp;status<STRONG>)</STRONG>;
if ( NS_SUCCEEDED(status) )
  <SPAN class="comment">// ...</SPAN>
</PRE>
</DIV>

<H4><code>dont_QueryInterface( nsIFoo* );</code></H4>
<P>
The almost minimal action: the source pointer is exactly the right type,
	I <STRONG>promise</STRONG>.
So just assign it in.
The pointer will be <code>AddRef</code>ed.
Note, this is not appropriate when the source pointer is not exactly the right type,
	e.g., in the case of inheritance.
<!-- /P -->
<code>
<PRE class="source-code">
<SPAN class="comment">// Using |dont_QueryInterface|...</code>


</PRE>
</DIV>

<H4><code>getter_AddRefs( X* );</code></H4>
<P>
The minimal action: the source pointer is exactly the right type,
	I <STRONG>promise</STRONG>.
So just assign it in.
And by the way, the thing that made the source pointer
	already <code>AddRef</code>ed it for you.
E.g.,
<!-- P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// Using |getter_AddRefs|...</SPAN>

nsIFoo* CreateFoo();

nsCOMPtr&lt;nsIFoo&gt; fooP = <STRONG>getter_AddRefs(</STRONG>CreateFoo()<STRONG>)</STRONG>;
</PRE>
</DIV>

<H4><code>dont_AddRef( X* );</code></H4>
<P>
A synonym for <code>getter_AddRefs</code>, but it reads better for non-function arguments, e.g.,
<!-- /P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// Using |dont_AddRef|...</SPAN>

nsIFoo* temp;
nsresult status = GetFoo(&amp;temp);
nsCOMPtr&lt;nsIFoo&gt; fooP = <STRONG>dont_AddRef(</STRONG>temp<STRONG>)</STRONG>;
</PRE>
</DIV>

<P>
The following table summarizes the calls.
</P>
<TABLE>
<TD>
</TD>
<TD>
</TD>
<TD>
</TD>
</TABLE>

</DIV>

<H2>Calling and Writing Setters</H2>


<DIV class="faq-item">
<H3>Should I write my setter to take an <code>nsCOMPtr</code> parameter?</H3>

<P>
Probably not.
It is prohibited entirely if your setter is part of a COM interface.
Otherwise, it seems tempting, however, consider this.
If your setter takes a raw COM interface pointer,
	it can be called easily by both callers with an <code>nsCOMPtr</code> and
	by callers with only a raw COM interface pointer.
If your setter takes an <code>nsCOMPtr</code>, it can only be called by one, and not the other.
Additionally, you typically don't need to hold an owning reference to parameters merely for
	the life of the function, as they are guaranteed to live longer than the call.
</P>
</DIV>

<DIV class="faq-item">
<H3>How do I call a setter that takes a raw COM interface pointer?</H3>

<P>
An <code>nsCOMPtr</code> automatically provides a raw COM interface pointer when needed.
See the item "What do I do when I need a normal pointer?".
So just call the setter and use your <code>nsCOMPtr</code> as the parameter.
<!-- /P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// Calling a setter...</SPAN>

nsresult SetFoo( nsIFoo* );  <SPAN class="comment">// ...the setter for this example.</SPAN>

nsCOMPtr&lt;nsIFoo&gt; fooP;
  <SPAN class="comment">// ...</SPAN>
SetFoo(fooP);  <SPAN class="comment">// Just call it.  The |nsCOMPtr| automatically provides a raw COM interface pointer</SPAN>
</PRE>
</DIV>
</DIV>

<H2>Calling and Writing Getters</H2>

<P>
In traditional parlance, the term `getter' usually means a member function that accesses an attribute.
A getter is an accessor, in opposition to a `setter' which is a mutator.
For our purposes, the attributes we care about are COM interface pointers.
We expand the definition to contain global as well as member functions.
So, in the discussions that follow, a getter is any function whose purpose is to return
	a COM interface pointer.
The result might be in the form of a raw COM interface pointer, or an <code>nsCOMPtr</code>.
It might returned as the function result,
	or through a pointer or reference parameter.
<code>QueryInterface</code> is, perhaps, the most famous COM getter.
</P>

<P>
COM has two key rules that impact the design and use of getters.
First, a getter must always <code>AddRef</code> its result.
Second, a getter must always initialize its result to <code>0</code> in case of error.
</P>


<DIV class="faq-item">
<H3>How do I call a getter that returns an <code>nsIFoo*</code> function result?</H3>
<P>
Wrap the getter in <code>getter_AddRefs</code>
	and construct or assign into your <code>nsCOMPtr</code> from that.
Note that it's cheaper to construct an <code>nsCOMPtr</code> with the right value,
	than it is to construct it and then separately assign in the value.
<!-- P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// Calling a getter that returns an |nsIFoo*| function result...</SPAN>

nsIFoo* CreateFoo(); <SPAN class="comment">// ...the getter for this example.</SPAN>

  <SPAN class="comment">// Prefer construction (as these two samples show) to construction followed by assignment.</SPAN>
  <SPAN class="comment">//  Both forms of construction are equivalent...</SPAN>
nsCOMPtr&lt;nsIFoo&gt; foo0P( <STRONG>getter_AddRefs(</STRONG>CreateFoo()<STRONG>)</STRONG> ); <SPAN class="comment">// ...function form</SPAN>
nsCOMPtr&lt;nsIFoo&gt; foo1P = <STRONG>getter_AddRefs(</STRONG>CreateFoo()<STRONG>)</STRONG>;  <SPAN class="comment">// ...assignment form</SPAN>

  <SPAN class="comment">// Construction followed by assignment.</SPAN>
  <SPAN class="comment">//  It's slightly more expensive than the construction-only samples above.</SPAN>
nsCOMPtr&lt;nsIFoo&gt; foo2P;
foo2P = <STRONG>getter_AddRefs(</STRONG>CreateFoo()<STRONG>)</STRONG>;
</PRE>
</DIV>

<P>
<code>dont_AddRef</code> is a synonym for this use of <code>getter_AddRefs</code>.
It's useful when, for some reason, you have a pointer that has already been <code>AddRef</code>ed,
	and so, no `getter' is involved directly in the assignment.
Here's an example taken from the item "What's the most efficient way to assign into an <code>nsCOMPtr</code>?"
<!-- /P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// An optimization pattern that transforms |nsCOMPtr| assignments into constructions...</SPAN>
<SPAN class="comment">//  Here, showing how |dont_AddRef| is related to |getter_AddRefs|.</SPAN>

nsresult GetFoo( nsIFoo** ); <SPAN class="comment">// ...the getter for this example.</SPAN>

  <SPAN class="comment">// Instead of saying this...</SPAN>
nsCOMPtr&lt;nsIFoo&gt; foo0P;
nsresult status = GetFoo( getter_AddRefs(foo0P) );

  <SPAN class="comment">// ...you can say this.</SPAN>
nsIFoo* temp;
status = GetFoo(&amp;temp);
nsCOMPtr&lt;nsIFoo&gt; foo1P = <STRONG>dont_AddRef(</STRONG>temp<STRONG>)</STRONG>;
</PRE>
</DIV>
</DIV>


<DIV class="faq-item">
<H3>How do I call a getter that fills in an <code>nsIFoo**</code> parameter?</H3>
<P>
If you wrap an <code>nsCOMPtr</code> with <code>getter_AddRefs</code>, you can use it as an argument to getters in this form.
This is a different use (but with the same end goal) of <code>getter_AddRefs</code> than what we saw in the previous item.
<!-- P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// Calling a getter that fills in an |nsIFoo**| parameter...</SPAN>

nsresult GetFoo( nsIFoo** ); <SPAN class="comment">// ...the getter for this example.</SPAN>

nsCOMPtr&lt;nsIFoo&gt; fooP;
nsresult status = GetFoo( <STRONG>getter_AddRefs(</STRONG>fooP<STRONG>)</STRONG> );
</PRE>
</DIV>
</DIV>


<DIV class="faq-item">
<H3>How do I call a getter that fills in an <code>nsIFoo*&</code> parameter?</H3>
<P>
You should probably report it as a bug.
Reference parameters should be avoided for getters,
	as they make the fact that a parameter will modified
	invisible at the call site.
You can still use such a getter, however,
	by wrapping your <code>nsCOMPtr</code> with <code>getter_AddRefs</code>, as in the previous item,
	and dereferencing the result.
E.g.,
<!-- /P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// Calling a getter that flls in an |nsIFoo*&amp;| parameter...</SPAN>

nsresult GetFoo( nsIFoo*&amp; ); <SPAN class="comment">// ...the getter for this example.</SPAN>

nsCOMPtr&lt;nsIFoo&gt; fooP;
nsresult status = GetFoo( <STRONG>*getter_AddRefs(</STRONG>fooP<STRONG>)</STRONG> );
</PRE>
</DIV>
</DIV>


<DIV class="faq-item">
<H3>What do I do if the getter doesn't <code>AddRef</code> its result?</H3>
<P>
You should probably report it as a bug.
However, if the getter has some legitimate reason for not <code>AddRef</code>ing its result,
	you can still use it with your <code>nsCOMPtr</code>s
	with an intermediate step.
<!-- /P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// Assigning into an |nsCOMPtr| from a getter that _doesn't_ |AddRef| its result...</SPAN>

nsIFoo* CreateFooWithoutAddRef();
nsresult GetFooWithoutAddRef( nsIFoo** );

nsCOMPtr&lt;nsIFoo&gt; foo0P = CreateFooWithoutAddRef();

nsIFoo* temp;
nsresult status = GetFooWithoutAddRef(&amp;temp);
nsCOMPtr&lt;nsIFoo&gt; foo1P = temp;
</PRE>
</DIV>
<P>
Naturally, you won't be able to use <code>getter_AddRefs</code>, as this getter <STRONG>doesn't</STRONG> <code>AddRef</code>.
</P>
</DIV>


<DIV class="faq-item">
<H3>Should I write my getter to return an <code>nsCOMPtr</code>?</H3>
<P>
Probably not.
It is prohibited entirely if your getter is part of a COM interface.
If your getter is <STRONG>not</STRONG> part of a COM interface,
	you might be tempted to write the following.
<!-- /P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// One (less than satisfactory) way of writing a getter that isn't part of a COM interface...</SPAN>

nsresult
Bar::GetFoo( nsCOMPtr&lt;nsIFoo&gt;* aResult ) const
  {
    NS_PRECONDITION(aResult, "null parameter");

    (*aResult) = mFooP;
    return NS_OK;
  }
</PRE>
</DIV>
<P>
But this implies that an <code>nsCOMPtr</code> cannot be constructed from a call to your getter;
	only assigned into.
And construction is preferred over assignment.
To facility construction, we'll want to return our pointer as the function result.
This leaves two possibilities.
We can return an <code>nsCOMPtr</code>, or we can return a raw COM interface pointer.
</P>
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// Another (less than satisfactory) way of writing a getter...</SPAN>

nsCOMPtr&lt;nsIFoo&gt;
Bar::GetFoo() const
  {
    return nsCOMPtr&lt;nsIFoo&gt;(mFooP);
  }
<SPAN class="comment">// Watch out for |nsIFoo* fooP = barP-&gt;GetFoo();| which compiles, but leaves |fooP| un-|AddRef|ed.</SPAN>
</PRE>
</DIV>
<P>
Returning an <code>nsCOMPtr</code> will almost certainly create a temporary;
	and it encourages a particularly evil error, as noted.
Returning a raw COM interface pointer
	facilitates <code>nsCOMPtr</code> construction,
	works with non-<code>nsCOMPtr</code> callers, and
	is likely to be more efficient than returning an <code>nsCOMPtr</code> directly. 
<!-- /P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// How to write a getter...</SPAN>

  <SPAN class="comment">// Note: both these patterns hold whether |mFooP| is an |nsCOMPtr| or a raw COM interface pointer.</SPAN>

  <SPAN class="comment">// The preferred form of a getter that is _not_ part of a COM interface...</SPAN>
nsIFoo*
Bar::GetFoo() const
  {
    nsIFoo* result = mFooP;
    NS_IF_ADDREF(result);
    return result;
  }

  <SPAN class="comment">// The preferred form of a getter that is part of a COM interface...</SPAN>
nsresult
Bar::GetFoo( nsIFoo** aResult )
  {
    NS_PRECONDITION(aResult, "null parameter");

    (*aResult) = mFooP;
    NS_IF_ADDREF(*aResult);
    return NS_OK;
  }
</PRE>
</DIV>
<P>
Reference parameters should be avoided for getters.
</P>
</DIV>






<H2>Calling and Writing <code>QueryInterface</code></H2>


<H2>Trouble Shooting</H2>

<DIV class="faq-item">
</DIV>



<H2>Efficiency</H2>


<DIV class="faq-item">
<H3>What's the most efficient way to assign into an <code>nsCOMPtr</code>?</H3>

<P>
The most efficient way, in both time and space, to get a value into an <code>nsCOMPtr</code> is at construction time.
Prefer construction over assignment whenever reasonable.
Initialize member <code>nsCOMPtr</code>s in the member initialization clause of your constructor.
<!-- /P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// Initialize member |nsCOMPtr|s in the member initialization clause of your constructor...</SPAN>

class Bar
  {
    public:
      Bar( nsIFoo* initial_fooP );
      <SPAN class="comment">// ...</SPAN>
    private:
      nsCOMPtr&lt;nsIFoo&gt; mFooP;
  };

Bar::Bar( nsIFoo* initial_fooP )
    : <STRONG>mFooP(initial_fooP)</STRONG> <SPAN class="comment">// initialize it _here_</SPAN>
  {
    <SPAN class="comment">// not here</SPAN>
  }
</PRE>
</DIV>
<P>
Additionally, there is an optimization pattern using a temporary that converts assignment form
	to construction form.
<!-- /P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// An optimization pattern that transforms |nsCOMPtr| assignments into constructions...</SPAN>

nsresult GetFoo( nsIFoo** ); <SPAN class="comment">// ...the getter for this example.</SPAN>

  <SPAN class="comment">// Instead of saying this...</SPAN>
nsCOMPtr&lt;nsIFoo&gt; foo0P;
nsresult status = GetFoo( getter_AddRefs(foo0P) );

  <SPAN class="comment">// ...you can say this.</SPAN>
nsIFoo* temp;
status = GetFoo(&amp;temp);
nsCOMPtr&lt;nsIFoo&gt; foo1P = dont_AddRef(temp);
</PRE>
</DIV>
</DIV>





<H2>Esoterica</H2>


<DIV class="faq-item">
<H3>Why is <code>getter_AddRefs</code> used in two such different contexts?</H3>
<P>
	Originally, <code>getter_AddRefs</code> was only used in the parameter form,
		e.g., for assigning into <code>nsCOMPtr</code>s from getters like <code>nsresult GetFoo( nsIFoo** )</code>, et al.
	It worked in a team with (the now obsolete) <code>getter_doesnt_AddRef</code>.
	<code>dont_AddRef</code> was the only choice for non-parameter situations like
		<code>nsIFoo* CreateFoo()</code>.
	Several factors led to the change.
	First, <code>getter_doesnt_AddRef</code> had unacceptable efficiency problems;
		and since getters that don't <code>AddRef</code> their result are against the rules of COM,
		<code>getter_doesnt_AddRef</code> was removed.
	Second, people kept using <code>getter_AddRefs</code> around functions where they were supposed to
		call <code>dont_AddRef</code>.
	This happened enough that it was reasonable to question the interface.
	At that point, I made a second form of <code>getter_AddRefs</code> that was simply a synonym
		for <code>dont_AddRef</code>.
	Now it behaved as people seemed to expect.
<!-- /P -->
<DIV class="source-code">
<PRE class="source-code">
<SPAN class="comment">// |getter_AddRefs| is used in two very different contexts...</SPAN>

nsCOMPtr&lt;nsIFoo&gt; foo0P = <STRONG>getter_AddRefs(</STRONG>CreateFoo()<STRONG>)</STRONG>;
  <SPAN class="comment">// either to wrap a getter function that returns a pointer before assigning it into an |nsCOMPtr|</SPAN>

nsresult status = GetFoo( <STRONG>getter_AddRefs(</STRONG>fooP<STRONG>)</STRONG> ); 
  <SPAN class="comment">// or to wrap an |nsCOMPtr| parameter that will be filled in by a getter</SPAN>
</PRE>
</DIV>
</DIV>


<H2>Bibliography and Related Reading</H2>

<DIV class="bibliography-entry">
<A href="">Effective COM</A>
50 Ways to Improve your COM and MTS-based Applications
by Don Box, et al.
</DIV>


<DIV class="author-note">
	<HR>
		<!-- A HREF="http://validator.w3.org/">
			<IMG BORDER=0 align=left SRC="http://validator.w3.org/images/vh40.gif" ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88>
		</A>
		<A HREF="http://www.w3.org/Style/CSS/Buttons">
			<IMG BORDER=0 align=left SRC="http://www.w3.org/Style/CSS/Buttons/cssos" ALT="CSS" HEIGHT=31 WIDTH=88>
		</A -->
		Copyright&copy; 1999 by Netscape; use is subject to the <A HREF="http://www.mozilla.org/NPL/">NPL</A>.
</DIV>
	


<hr class="hide">
</div>
</div>
<div id="footer">
<ul>
<li><a href="../../../sitemap.html">Site Map</a></li>
<li><a href="../../../security/">Security Updates</a></li>
<li><a href="../../../contact/">Contact Us</a></li>
<li><a href="../../../foundation/donate.html">Donate</a></li>
</ul>
<p class="copyright">
Portions of this content are &copy; 1998&#8211;2009 by individual mozilla.org
contributors; content available under a Creative Commons license | <a
href="http://www.mozilla.org/foundation/licensing/website-content.html">Details</a>.</p>
<p>
<span>Last modified May  8,  2003</span>
<span><a href="http://bonsai-www.mozilla.org/cvslog.cgi?file=mozilla-org/html/projects/xpcom/nsCOMPtr/nsCOMPtrFAQ.html&amp;rev=&amp;root=/www/">Document History</a></span>
</p>
</div>
</div>
</body>
</html>
