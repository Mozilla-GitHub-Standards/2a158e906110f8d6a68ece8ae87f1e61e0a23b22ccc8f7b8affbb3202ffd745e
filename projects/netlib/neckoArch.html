<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="top" title="Home" href="http://www.mozilla.org/">
<link rel="stylesheet" type="text/css" href="../../css/print.css"  media="print">
<link rel="stylesheet" type="text/css" href="../../css/base/content.css"  media="all">
<link rel="stylesheet" type="text/css" href="../../css/cavendish/content.css" title="Cavendish" media="screen">
<link rel="stylesheet" type="text/css" href="../../css/base/template.css"  media="screen">
<link rel="stylesheet" type="text/css" href="../../css/cavendish/template.css" title="Cavendish" media="screen">
<link rel="icon" href="../../images/mozilla-16.png" type="image/png">
<script src="../../__utm.js" type="text/javascript"></script>
</head>
<body id="www-mozilla-org" class="deepLevel">
<div id="container">
<p class="important">You are currently viewing a snapshot of www.mozilla.org taken on April 21, 2008. Most of this content is
highly out of date (some pages haven't been updated since the project began in 1998) and exists for historical purposes only.  If
there are any pages on this archive site that you think should be added back to www.mozilla.org, please <a
href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Websites&component=www.mozilla.org">file a bug</a>.</p>
<p class="skipLink"><a href="#mainContent" accesskey="2">Skip to main content</a></p>
<div id="header">
<h1><a href="/" title="Return to home page" accesskey="1">Mozilla</a></h1>
<ul>
<li id="menu_aboutus"><a href="../../about/" title="Getting the most out of your online experience">About</a></li>
<li id="menu_developers"><a href="../../developer/" title="Using Mozilla's products for your own applications">Developers</a></li>
<li id="menu_store"><a href="http://store.mozilla.org/?r=mozorg1" title="Shop for Mozilla products on CD and other merchandise">Store</a></li>
<li id="menu_support"><a href="../../support/" title="Installation, trouble-shooting, and the knowledge base">Support</a></li>
<li id="menu_products"><a href="../../products/" title="All software Mozilla currently offers">Products</a></li>
</ul>
<form id="searchbox_002443141534113389537:ysdmevkkknw" action="http://www.google.com/cse" title="mozilla.org Search">
<div>
<label for="q" title="Search mozilla.org's sites">search mozilla:</label>
<input type="hidden" name="cx" value="002443141534113389537:ysdmevkkknw">
<input type="hidden" name="cof" value="FORID:0">
<input type="text" id="q" name="q" accesskey="s" size="30">
<input type="submit" id="submit" value="Go">
</div>
</form>
</div>
<hr class="hide">
<div id="mBody">
<div id="side">

<ul id="nav">
<li><a title="Roadmap" href="../../roadmap.html"><strong> Roadmap</strong></a></li>
<li><a title="Projects" href="../../projects/"><strong> Projects</strong></a></li>
<li><a title="For developers" href="../../developer/"><strong> Coding</strong></a>
<ul>
<li><a title="Module Owners" href="../../owners.html"> Module Owners</a></li>
<li><a title="Hacking" href="../../hacking/"> Hacking</a></li>
<li><a title="Get the Source" href="http://developer.mozilla.org/en/docs/Download_Mozilla_Source_Code"> Get the Source</a></li>
<li><a title="Building Mozilla" href="http://developer.mozilla.org/en/docs/Build_Documentation"> Build It</a></li>
</ul>
</li>
<li><a title="Testing" href="../../quality/"><strong> Testing</strong></a>
<ul>
<li><a title="Downloads of mozilla.org software releases" href="../../download.html"> Releases</a></li>
<li><a title="Latest mozilla builds for testers" href="../../developer/#builds"> Nightly Builds</a></li>
<li><a title="For testers to report bugs" href="https://bugzilla.mozilla.org/"> Report A Problem</a></li>
</ul>
</li>
<li><a title="Tools for mozilla developers" href="../../tools.html"><strong> Tools</strong></a>
<ul>
<li><a title="Bug tracking system for mozilla testers." href="https://bugzilla.mozilla.org/"> Bugzilla</a></li>
<li><a title="Latest status of mozilla builds" href="http://tinderbox.mozilla.org/showbuilds.cgi?tree=Firefox"> Tinderbox</a></li>
<li><a title="Latest checkins" href="http://bonsai.mozilla.org/cvsqueryform.cgi"> Bonsai</a></li>
<li><a title="Source cross reference" href="http://lxr.mozilla.org/seamonkey/"> LXR</a></li>
</ul>
</li>
<li><a title="Frequently Asked Questions." href="../../faq.html"><strong> FAQs</strong></a></li>
</ul>

</div>
<hr class="hide">
<div id="mainContent">




<center>
<h1>
<img SRC="neckoCandy.jpg" height=61 width=200></h1></center>

<center>
<h1>
necko</h1></center>

<div type="_moz">Last updated: 11/08/99</div>

<div type="_moz">Author: Jud Valeski</div>
<p>

<div type="_moz">Necko is a modular networking library designed using the
mozilla open source medium. Necko has been designed to accomodate pluggable
protocols so developers can contribute their own protocol libraries that
can be dynamically loaded and used by applications utilizing necko.</div>

<div type="_moz">Necko provides the following libraries.</div>
<p>

<div type="_moz">necko - core networking functionality.</div>

<div type="_moz">mimetype - MIME &lt;-> file extension mapping</div>

<div type="_moz">nkabout - about: protocol</div>

<div type="_moz">nkdata - data: protocol</div>

<div type="_moz">nkfile - file: protocol</div>

<div type="_moz">nkftp - ftp: protocol</div>

<div type="_moz">nkkeyword - keyword: protocol</div>

<div type="_moz">nkresrc - resource: protocol</div>

<div type="_moz">cnvts - stream converters</div>

<div type="_moz">stremcnv - stream converter service</div>

<div type="_moz">These libraries will change with time (a consolodation
strategy is underway) and illustrate the modularity of necko.</div>

<p>
<h3>
<div type="_moz">Architecture:</div></h3>

<div type="_moz">After a few iterations of our original design, the current
necko architecture looks something like this:</div>

<p><br><img SRC="arch.jpg" height=503 width=464>
<br>&nbsp;
<h3>
URLs</h3>

<div type="_moz">Necko's primary responsibility is moving data from one
location, to another location. These locations are represented in the form
we have all grown to know and love as a URIs. A URL implements the URI
interface. The URI interface does resource generic things like getting/setting
the scheme, or getting/setting the spec (everything beyond the first colon
':'). URLs provide getting/setting of paths, hosts, ports, filenames, etc.
URLs are the most commonly used form of a URI. Because of their importance,
necko provides its own standard implimentation of URLs (who's class id
is NS_STANDARDURL_CID) which does all of the standard parsing necessary
for most URLs. Necko also provides a simple URI implementation for convenience.
URI's (recall that a URL is just one implementation of a URI) can be created
as individual components independently of necko, or they can be retrieved
via the nsIIOService interface.</div>

<div type="_moz">If you want to provide your own resource implementation
for foo URLs, you simply need to implement the nsIURI interface.</div>

<div type="_moz">nsIIOService acts as the central point of access to URLs
and channels (nsIChannel) in necko. Given a string representation of a
URL, you can ask the nsIIOService for a URL instance representing that
string. Once you have a URL interface in hand (nsIURL), you have a completely
parsed representation of the original URL string, and you can query for
the various parts of the URL.</div>

<h3>
Handlers &amp; Channels</h3>

<div type="_moz">nsIChannel provides a data access interface which allows
you to read or write data from or to a URI. There is a 1-to-1 relationship
between URIs and channels (if you go so far as to create a channel from
a URI, which is not required if all you need is a parsed representation
of a URI string). For every URI you want to transact with, there is exactly
one channel. In order to get a channel from a URI an intermediary layer
was introduced. Because a URI has no self knowledge about what "protocol"
it represents, another component is responsible for deciding which channel
implementation will be responsible for "loading" the URI. This layer is
the protocol handler layer. A protocol handler's primary responsibility
is to create channels for the scheme it has registered to handle. For example,
the HTTP protocol handler registers itself as the protocol handler for
"http." The HTTP protocol handler creates HTTP channels for HTTP URLs.
Once you have a channel you can read or write data from or to your URI.</div>

<h4>
nsIIOService</h4>

<div type="_moz">The nsIIOService does the protocol handler lookup for
you. However, you can certainly ask the nsIIOService for the protocol handler
for the URI you have, then ask the protocol handler for a channel on that
URI. In fact, most of what the nsIIOService does can be done independently
of the nsIIOService, by hand. The nsIIOService acts as a convenience interface,
consolodating several steps for the user.</div>

<div type="_moz">To summarize... The nsIIOService creates URL instances.
It does this by looking up the protocol handler for the scheme of the URL,
then asking the protocol handler to create the URL. The nsIIOService can
also create channels. It does this by looking up the protocol handler and
asking it to create the channel.</div>

<div type="_moz">The primary responsibility of protocol handlers is to
create channel instances that know how to interpret the protocol that the
handler registered for. However, a protocol handler implementation also
might "cache" the underlying transports so channels it creates can reuse
them later. The channel does the true work of protocol interpretation and
data movement (if any). Although the protocol handler creates channels,
protocol interpretation doesn't begin until the user initiates the transaction
using the nsIChannel api.</div>

<h3>
Receiving Data &amp; nsIStreamListener</h3>

<div type="_moz">You can read or write, from or to a channel using either
the sychronous api, or the asynchronous api. If you want to move data asynchronously
you need to be able to receive callbacks using an implementation of nsIStreamListener.
An nsIStreamListener is told when the URI transaction has "started," when
data is available (in the case of reading data), and when it has "stopped."
It is up to the nsIStreamListener implementation to decide what to do with
these various notifications. The OnDataAvailable() notification provides
a chance for the nsIStreamListener to actually retrieve data that the channel
has acquired. One of the arguments to the OnDataAvailable() notification
is an nsIInputStream (which can be considered the underlying data).</div>

<h3>
Streams</h3>

<div type="_moz">Necko represents data in the form of streams (nsIBaseStream
is the root interface. nsIInputStream is read from. nsIOutputStream is
written to). Streams provide a generic interface to the data and allow
for many underlying implementations that permit multiple data sources to
be used. As a user, you don't care where the data came from, or where it
"is," as long as you get the data. The data may be in memory, it may be
on disk, or it may be located somewhere else. The point is that streams
provide a loose interface for data access.</div>

<div type="_moz">If you initiate a synchronous transfer on a channel, you
are handed back a stream that you can read or write from or to. If you
initiate an asynchronous transfer, you receive callbacks that notify you
when things are happening. In the case of an asynchronous read... when
you receive the OnDataAvailable() callback, you are handed an nsIInputSteam
which you can read the data from (you will more than likely need to be
able to handle multiple OnDataAvailable() callbacks, buffering the data
you receive as necessary). The transaction is not complete until you receive
an "stopped" notification.</div>

<h3>
Transports</h3>

<div type="_moz">Underlying I/O functionality has been consolodated into
"transports." There is a transport for each type of I/O. Necko implements
a file transport and a socket transport that the protocol implementations
(channels) use to actually move bytes to and fro.</div>

<div type="_moz">"How do I add my own protocol handler?"</div>

<div type="_moz">Adding your own protocol handler is a straightforward
process in necko. There are a minimum of two interfaces you need to implement
in order to fit into the necko architecture: nsIProtocolHandler, and nsIChannel.</div>

<div type="_moz">Recall, that the IOService will lookup your protocol handler
and ask it for a channel. After registering your protocol handler</div>

<div type="_moz">necko will use it to create channels for any URIs it encounters
that have the scheme your protocol handler registered for. Please use existing
protocol handler's for reference (the DATA protocol handler is the simplest
handler necko provides, HTTP is a fairly complex (uses many classes) implementation
utilizing asynchronous I/O, and FTP provides an example of a protocol implementation
that creates an extra thread which uses synchronous I/O).</div>

<h3>
Dependencies</h3>

<div type="_moz">Necko requires the following libraries for linking:</div>

<div type="_moz">nspr</div>

<div type="_moz">xpcom</div>


<hr class="hide">
</div>
</div>
<div id="footer">
<ul>
<li><a href="../../sitemap.html">Site Map</a></li>
<li><a href="../../security/">Security Updates</a></li>
<li><a href="../../contact/">Contact Us</a></li>
<li><a href="../../foundation/donate.html">Donate</a></li>
</ul>
<p class="copyright">
Portions of this content are &copy; 1998&#8211;2009 by individual mozilla.org
contributors; content available under a Creative Commons license | <a
href="http://www.mozilla.org/foundation/licensing/website-content.html">Details</a>.</p>
<p>
<span>Last modified April 27,  2000</span>
<span><a href="http://bonsai-www.mozilla.org/cvslog.cgi?file=mozilla-org/html/projects/netlib/neckoArch.html&amp;rev=&amp;root=/www/">Document History</a></span>
</p>
</div>
</div>
</body>
</html>
