<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<link rel="top" title="Home" href="http://www.mozilla.org/">
<link rel="stylesheet" type="text/css" href="../css/print.css"  media="print">
<link rel="stylesheet" type="text/css" href="../css/base/content.css"  media="all">
<link rel="stylesheet" type="text/css" href="../css/cavendish/content.css" title="Cavendish" media="screen">
<link rel="stylesheet" type="text/css" href="../css/base/template.css"  media="screen">
<link rel="stylesheet" type="text/css" href="../css/cavendish/template.css" title="Cavendish" media="screen">
<link rel="icon" href="../images/mozilla-16.png" type="image/png">


<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">

<meta name="DC.author" content="Simon Fraser">
<meta name="DC.subject" content="Measuring Mac Performance">
<meta name="DC.title" content="Measuring Mac Performance">
<meta name="DC.description" content="List of tools and resources for improving Mac performance">
<meta name="DC.date.created" content="2000-07-28T14:28:03+11:00" scheme="W3CDTF">
<meta name="DC.date.modified" content="2005-06-07T09:54:03+11:00" scheme="W3CDTF">
	<title>Mac Performance</title>
<script src="../__utm.js" type="text/javascript"></script>
</head>
<body id="www-mozilla-org" class="deepLevel">
<div id="container">
<p class="important">You are currently viewing a snapshot of www.mozilla.org taken on April 21, 2008. Most of this content is
highly out of date (some pages haven't been updated since the project began in 1998) and exists for historical purposes only.  If
there are any pages on this archive site that you think should be added back to www.mozilla.org, please <a
href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Websites&component=www.mozilla.org">file a bug</a>.</p>
<p class="skipLink"><a href="#mainContent" accesskey="2">Skip to main content</a></p>
<div id="header">
<h1><a href="/" title="Return to home page" accesskey="1">Mozilla</a></h1>
<ul>
<li id="menu_aboutus"><a href="../about/" title="Getting the most out of your online experience">About</a></li>
<li id="menu_developers"><a href="../developer/" title="Using Mozilla's products for your own applications">Developers</a></li>
<li id="menu_store"><a href="http://store.mozilla.org/?r=mozorg1" title="Shop for Mozilla products on CD and other merchandise">Store</a></li>
<li id="menu_support"><a href="../support/" title="Installation, trouble-shooting, and the knowledge base">Support</a></li>
<li id="menu_products"><a href="../products/" title="All software Mozilla currently offers">Products</a></li>
</ul>
<form id="searchbox_002443141534113389537:ysdmevkkknw" action="http://www.google.com/cse" title="mozilla.org Search">
<div>
<label for="q" title="Search mozilla.org's sites">search mozilla:</label>
<input type="hidden" name="cx" value="002443141534113389537:ysdmevkkknw">
<input type="hidden" name="cof" value="FORID:0">
<input type="text" id="q" name="q" accesskey="s" size="30">
<input type="submit" id="submit" value="Go">
</div>
</form>
</div>
<hr class="hide">
<div id="mBody">
<div id="side">

<ul id="nav">
<li><a title="Roadmap" href="../roadmap.html"><strong> Roadmap</strong></a></li>
<li><a title="Projects" href="../projects/"><strong> Projects</strong></a></li>
<li><a title="For developers" href="../developer/"><strong> Coding</strong></a>
<ul>
<li><a title="Module Owners" href="../owners.html"> Module Owners</a></li>
<li><a title="Hacking" href="../hacking/"> Hacking</a></li>
<li><a title="Get the Source" href="http://developer.mozilla.org/en/docs/Download_Mozilla_Source_Code"> Get the Source</a></li>
<li><a title="Building Mozilla" href="http://developer.mozilla.org/en/docs/Build_Documentation"> Build It</a></li>
</ul>
</li>
<li><a title="Testing" href="../quality/"><strong> Testing</strong></a>
<ul>
<li><a title="Downloads of mozilla.org software releases" href="../download.html"> Releases</a></li>
<li><a title="Latest mozilla builds for testers" href="../developer/#builds"> Nightly Builds</a></li>
<li><a title="For testers to report bugs" href="https://bugzilla.mozilla.org/"> Report A Problem</a></li>
</ul>
</li>
<li><a title="Tools for mozilla developers" href="../tools.html"><strong> Tools</strong></a>
<ul>
<li><a title="Bug tracking system for mozilla testers." href="https://bugzilla.mozilla.org/"> Bugzilla</a></li>
<li><a title="Latest status of mozilla builds" href="http://tinderbox.mozilla.org/showbuilds.cgi?tree=Firefox"> Tinderbox</a></li>
<li><a title="Latest checkins" href="http://bonsai.mozilla.org/cvsqueryform.cgi"> Bonsai</a></li>
<li><a title="Source cross reference" href="http://lxr.mozilla.org/seamonkey/"> LXR</a></li>
</ul>
</li>
<li><a title="Frequently Asked Questions." href="../faq.html"><strong> FAQs</strong></a></li>
</ul>

</div>
<hr class="hide">
<div id="mainContent">








<h2><a id="Measuring_Mac_Performance"  name="Measuring_Mac_Performance">Measuring Mac Performance</a></h2>

<!--index-->
<ul>
	<li><a href="#Introduction">Introduction</a></li>
	<li><a href="#What_are_all_these_Mac_builds">What are all these Mac builds?</a>
	<ul>
		<li><a href="#Mac_OS_8_9_Classic">Mac OS 8, 9 "Classic"</a></li>
		<li><a href="#Mac_OS_X_CFM">Mac OS X "CFM" (sometimes "Fizzilla", "Carbon")</a></li>
		<li><a href="#Mac_OS_X_Mach-O">Mac OS X "Mach-O"</a></li>
		<li><a href="#Mac_OS_X_Cocoa">Mac OS X Cocoa</a></li>
	</ul>
	</li>
	<li><a href="#Deciding_what_to_profile">Deciding what to profile</a></li>
	<li><a href="#Should_I_profile_a_debug_or_an_optimized_build">Should I profile a debug or an optimized build?</a></li>
	<li><a href="#Get_to_know_the_code">Get to know the code</a>
	<ul>
		<li><a href="#Understand_gross_program_behaviour">Understand gross program behaviour</a></li>
		<li><a href="#Understand_unavoidable_time_sinks">Understand unavoidable time sinks</a></li>
	</ul>
	</li>
	<li><a href="#Preparing_to_profile">Preparing to profile</a>
	<ul>
		<li><a href="#Maintain_a_consistent_machine_state">Maintain a consistent machine state</a></li>
		<li><a href="#Maintain_a_consistent_build_state">Maintain a consistent build state</a></li>
		<li><a href="#Caveats">Caveats</a></li>
	</ul>
	</li>
	<li><a href="#Performance_Tools">Performance Tools</a>
	<ul>
		<li><a href="#User-level_performance">User-level performance</a></li>
		<li><a href="#Simple_code_investigation">Simple code investigation</a></li>
		<li><a href="#move_to_dedicated_profiling_tools">If necessary, move to dedicated profiling tools</a></li>
	</ul>
	</li>
	<li><a href="#Mac_Tools">Mac Classic Tools</a>
	<ul>
		<li><a href="#Metrowerks_Profiler">Metrowerks Profiler</a></li>
		<li><a href="#Instrumentation_SDK">Instrumentation SDK</a></li>
		<li><a href="#Chronoscope">Chronoscope</a></li>
		<li><a href="#Memory_Leaks">Memory Leaks</a></li>
		<li><a href="#Refcount_balancer_on_Mac">Refcount balancer on Mac</a></li>
		<li><a href="#Other_resources">Other Mac OS 9 resources</a></li>
	</ul>
	</li>
	<li><a href="#Mac_OS_X_Tools">Mac OS X Tools</a></li>
	<li><a href="#Available_tools_on_Mac_OS_X">Available tools on Mac OS X</a>
	<ul>
		<li><a href="#Sampler">Sampler</a></li>
		<li><a href="#MallocDebug">MallocDebug</a></li>
		<li><a href="#ObjectAlloc">ObjectAlloc</a></li>
		<li><a href="#QuartzDebug">QuartzDebug</a></li>
		<li><a href="#Command-line_tools">Command-line tools</a></li>
	</ul>
	</li>
	<li><a href="#Resources">Resources</a>
	<ul>
		<li><a href="#Technotes">Technotes</a></li>
		<li><a href="#Mac_OS_9">Mac OS 9</a></li>
		<li><a href="#Mac_OS_X">Mac OS X</a></li>
		<li><a href="#Downloads">Downloads</a></li>
	</ul>
	</li>
</ul>
<!--/index-->

<hr>

<h2><a id="Introduction"  name="Introduction">Introduction</a></h2>
<p>
The Mac Mozilla product has some significant performance problems in various areas,
often because of platform performance idiosyncracies (e.g. a relatively slow
filesystem), poor platform-specific code, or code that is just slow everywhere.
Some areas in which we know Mac Mozilla to be slow are:
</p>
<ul>
    <li>Startup (library loading, file I/O)</li>
    <li>Text measurement (getting text width during layout reflow)</li>
    <li>File I/O (e.g. disk cache)</li>
</ul>
<p>
You can find a list of all bugs filed on Mac performance by doing a
<a href="http://bugzilla.mozilla.org/buglist.cgi?bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;rep_platform=Macintosh&amp;keywords=perf&amp;cmdtype=doit">Bugzilla Query</a>.
</p>
<p>
We can always use help with performance tuning on Mac. This document describes
some of the tools available for performance work. More information on performance work on Mac applications
is available in an <a href="http://developer.apple.com/technotes/tn/tn1174.html">Apple technote</a>.
</p>

<h2><a id="What_are_all_these_Mac_builds" name="What_are_all_these_Mac_builds">What are all these Mac builds?</a></h2>

<p>
We have a number of different Mac builds currently. They are somewhat confusingly named. <em>Carbon</em>
a set of APIs which are implemented on both Mac OS 9 (via CarbonLib) and Mac OS X. <em>CFM</em> (short for
the Code Fragment Manager) is the Mac OS library loader, and again is present on both Mac OS 9 and X.
CFM loads libraries which use the PEF (Preferred Executable Format), a format whose use is discouraged
on Mac OS X. Mach-O is the native library format on X, and has performance and footprint advantages.
</p>

<h3><a id="Mac_OS_8_9_Classic" name="Mac_OS_8_9_Classic">Mac OS 8, 9 "Classic"</a></h3>

<ul>
	<li>Library format: PEF (<i>Preferred Executable Format</i>) aka CFM (<i>Code Fragment Manager</i>)</li>
	<li>Mac widget, Mac GFX. Event handling uses <code>WaitNextEvent()</code></li>
	<li>Built via CodeWarrior projects and the Mac build scripts</li>
</ul>

<h3><a id="Mac_OS_X_CFM" name="Mac_OS_X_CFM">Mac OS X "CFM" (sometimes "Fizzilla", "Carbon")</a></h3>
<ul>
	<li>Library format: PEF (<i>Preferred Executable Format</i>) aka CFM (<i>Code Fragment Manager</i>)
	<li>Mac widget, Mac GFX built with <code>#if TARGET_CARBON</code>
	<li>Event handling uses <code>WaitNextEvent()</code>, some Carbon Events
	<li>Built via CodeWarrior projects and the Mac build scripts
</ul>

<h3><a id="Mac_OS_X_Mach-O" name="Mac_OS_X_Mach-O">Mac OS X "Mach-O"</a></h3>
<ul>
	<li>Library format: Mach-O
	<li>Hybrid of Unix and Mac builds; mainly Mac Widget and GFX, Unix NSPR. Still uses much of the Carbon API.
	<li>Built via Unix makefiles. <code>XP_MACOSX</code> is defined.
</ul>

<h3><a id="Mac_OS_X_Cocoa" name="Mac_OS_X_Cocoa">Mac OS X Cocoa</a></h3>
<ul>
	<li>Essentially a new port; will use Cocoa for widget, Quartz for GFX. Closer to Mac OS X "native".
	<li>Library format: Mach-O
	<li>Hybrid of Unix and Mac builds, built via makefiles.
</ul>


<h2><a id="Deciding_what_to_profile" name="Deciding_what_to_profile">Deciding what to profile</a></h2>
<p>
What should you profile? What is "too slow"? This is a hard question, and often the stumbling
block of profiling efforts. There are various approaches here which are useful:
</p>
<ul>
    <li>Comparison to other applications on the same platform.</li>
    <li>Comparison to Mozilla on Windows</li>
    <li>Operation is too slow from a user perspective</li>
    <li>Code inspection reveals possible poor performance area</li>
    <li>"Hunch" that some code might be a bottleneck</li>    
</ul>
<p>
Often performance work is a combination of data collection, debugging, and iterative code
changes. Of course the goal is to find the minimum set of changes for the maximum speed
win, but that's not easy.
</p>
<p>
Performance work can also be a big time suck, and something that is never finished. To do
it in a manageable way requires some objective measurement of results; this often has to
be simply time to do some user-oriented task.
</p>

<h2><a id="Should_I_profile_a_debug_or_an_optimized_build" name="Should_I_profile_a_debug_or_an_optimized_build">Should I profile a debug or an optimized build?</a></h2>
<p>
Ideally, you should collect profiling data on an optimized build. A debug build is
compiled without optimizations, and often has debug code which can strongly skew performance
results, including data-verification code, and <code>printf</code>s. Gecko is known to
have some debug-only calls that are slow.
</p>
<p>
That said, I often collect profile data using the Instrumentation SDK because I like
to be able to easily debug in the same build that I profile with, and debugging is
much easier when building without optimizations. I also believe that if you can get
a debug build to be fast enough on your super-duper developer machine, end users
are going to experience better performance on lower-end machines.
</p>

<h2><a id="Get_to_know_the_code" name="Get_to_know_the_code">Get to know the code</a></h2>

<p>
To be effective when profiling, you have to understand the various runtime environments
that your code (and often the profiler's code) may be running in:
</p>

<ul>
	<li>NSPR threading is cooperative on Mac, using a hand-rolled threading implementation
	that uses <code>setjmp</code>/<code>longjmp</code></li>
	<li>Some bits of code run at interrupt time:
	<ul>
		<li>Async file I/O callback (NSPR)</li>
		<li>Timer task (NSPR)</li>
		<li>Open Transport notifiers (NSPR and necko)</li>
		<li>Watch cursor VBL task (in gfx)</li>
	</ul>
	so you can't profile these with some tools (your machine will crash).
	</li>
</ul>
<p>
On Mac OS X, the "interrupt time" code above actually runs in separate MPTasks (layered over
pthreads). There is a difference in behaviour on Mac OS X in that these tasks don't necessarily
run to completion; i.e. they may be preempted by the main thread, or another task. They can also
run concurrently on multi-CPU machines.
</p>

<h3><a id="Understand_gross_program_behaviour" name="Understand_gross_program_behaviour">Understand gross program behaviour</a></h3>
<p>
Mozilla is a big application, and very complex. Depending on what kind of code you are profiling,
you may have to work to understand parts of the Mozilla architecture that are not immediately
obvious from reading the code. Examples are:
</p>
<ul>
	<li>Threading (socket and file transport threads, PLEvents in necko, XPCOM)</li>
	<li>Chrome building (brutal sharing, fastload etc in XUL code).</li>
	<li>Layout (paint suppression, reflow batching etc in <code>PresShell</code>).</li>
	<li>Drawing (double-buffering in the View Manager)</li>
</ul>
<p>
For example, most of our window building code (for the first window) is asynchronous; we fire off
a <code>chrome://</code> URL for the window's chrome, and then do the actual work of building the
window content in the handlers for PLEvents, which have been proxied over to the main thread from
necko's file transport threads. Don't expect to be able to turn profiling on for a section of code
that just builds the main window; because this is asynchronous, you'll end up profiling code that
does event handling and other stuff.
</p>
<p>
Another implication of this type of design is that performance problems are not always caused
simply by code that takes too long to run; they can also be caused by problems like resource
contention between threads (i.e. threads spend too long waiting), or by latency problems (e.g.
too long a delay between necko posting a PLEvent, and it being processed on the main thread).
</p>

<h3><a id="Understand_unavoidable_time_sinks" name="Understand_unavoidable_time_sinks">Understand unavoidable time sinks</a></h3>
<p>
When profiling, you're going to quickly notice that we spend a lot of time in certain routines:
</p>
<ul>
	<li>Event handling: <code>WaitNextEvent()</code> in <code>nsMacMessagePump::GetEvent()</code>
	<li>Spin loop: <code>WaitNextEvent()</code> in <code>_MD_PauseCPU</code> in NSPR
	<li>Library loading: various <code>PR_LoadLibrary</code> calls from XPCOM, security, AIM.
	<li>Reading from disk
</ul>
<p>
In part, it is inevitable that time will be spent in these parts of the code. But there may be 
important performance gains to be had by minimizing that time (read less from disk, improve locality
of reference in libraries etc.).
</p>

<h2><a id="Preparing_to_profile" name="Preparing_to_profile">Preparing to profile</a></h2>

<p>When profiling, it's important to work on a machine, and a build that's in a known
state, otherwise you'll be unable to compare different sets of results.
</p>

<h3><a id="Maintain_a_consistent_machine_state" name="Maintain_a_consistent_machine_state">Maintain a consistent machine state</a></h3>
<ul>
	<li>Virtual Memory on to 1Mb &gt; physical memory (Memory control panel)</li>
	<li>Virus software disabled</li>
	<li>Plenty of disk space</li>
	<li>No other applications running, no audio CDs playing etc</li>
</ul>

<h3><a id="Maintain_a_consistent_build_state" name="Maintain_a_consistent_build_state">Maintain a consistent build state</a></h3>
<ul>
	<li>Optimized build</li>
	<li>Resolve aliases in Components and Essential Files folders<br>
	(<a href="http://www.stuffit.com/expander/download.html">DropStuff</a> then expand them)</li>
	<li>Modern skin, clean profile</li>
</ul>

<h3><a id="Caveats" name="Caveats">Caveats</a></h3>
<p>
Beware of program behaviours that make the first and subsequent actions behave differently:
</p>

<ol>
	<li>First run of a build is different (XPCOM autoregistration, chrome registration)</li>
	<li>First run of a build in a profile is different (Fastload for the first of each window type)</li>
	<li>First instance of a window type in a run is slower than subsequent (XUL cache/brutal sharing)</li>
	<li>First and second run are different (OS disk and library caching)</li>
	<li>First and subsequent loads of a page may be different (disk/memory cache)</li>
	<li>Different behaviour on different machines</li>
</ol>

<h2><a id="Performance_Tools" name="Performance_Tools">Performance Tools</a></h2>

<p>
Performance testing does not have to involve diving into low-level performance tools. There are a number of
high- and mid- level tools and tecniques that you can use:
</p>
<h3><a id="User-level_performance" name="User-level_performance">User-level performance</a></h3>
<ul>
	<li>Supplied tests (page-load, startup, new window)</li>
</ul>

<h3><a id="Simple_code_investigation" name="Simple_code_investigation">Simple code investigation</a></h3>
<ul>
	<li>Use high- or low-level debugger to see how often code is called, and understand call patterns (<code>tvb</code> in MacsBug)</li>
	<li>Use <code>printf</code> to see when things are called. Hack in timing data with <code>PR_Interval</code>. Hack in the
	stack walking code from <code>nsTranceRefcnt</code>.</li>
	<li>Write temporary code -- accounting, instrumenting QI etc.</li>
	<li>Change the code -- comment code out, see how fast it runs.</li>
	<li>Change the input data -- minimal XUL, reduced CSS etc.</li>
	<li>Use built-in tools
		<ul>
			<li><code>MOZ_TIMELINE</code>
			<li>Paint/update flashing (<code>nsWindow.cpp</code> on Mac)
			<li>Trace-malloc etc.
		</ul></li>
</ul>

<h3><a id="move_to_dedicated_profiling_tools" name="move_to_dedicated_profiling_tools">If necessary, move to dedicated profiling tools</a></h3>
<ul>
	<li>Mac OS 9: MW Profiler, Instrumentation SDK, Chronoscope</li>
	<li>Mac OS X: Sampler, QuartzDebug, fs_usage, top etc.</li>
</ul>

<h2><a id="Mac_Tools" name="Mac_Tools">Mac Classic Tools</a></h2>
<p>
There are two main tools available for Mac performance measurement. They work in
quite different ways, and give different types of data (though there is some overlap).
As a result, you may find yourself using both to investigate performance problems.
</p>

<h3><a id="Metrowerks_Profiler" name="Metrowerks_Profiler">Metrowerks Profiler</a></h3>
<p>
The <a href="http://www.metrowerks.com/">Metrowerks</a> Profiler is a code-instrumenting profiling
tool which requires that you rebuild the sources with the profiling turned on. The compiler then
inserts calls to <code>__PROFILE_ENTRY()</code> at the start of each function, and to
<code>__PROFILE_EXIT()</code> at exit points.
</p>
<p class="note">
<em>Note</em>: You could hijack <code>__PROFILE_ENTRY()</code> and <code>__PROFILE_EXIT()</code>
by implementing them yourself if you wanted to roll your own profiling or code coverage tools.
</p>
<p>
To build with profiling turned on, do one of the following:
</p>
<ul>
    <li>
    <p>In <code><a href="http://lxr.mozilla.org/seamonkey/source/build/mac/IDE_Options.h">mozilla/build/mac/IDE_options.h</a></code>,
    change
<pre>
  #pragma profile off
</pre>
to
<pre>
  #pragma profile on
</pre>
    <p>
    <code>IDE_options.h</code> is included in every source file in the project via the prefix files specified in
    project preferences. So changing this will turn on profiling for the entire application. You don't want
    to actually collect data for the whole app (trust me), so if you do this, you should
    sandwich the code your are interested in with <code>ProfilerSetStatus()</code> calls.
    </p>
    <p>
    You should also set the <code>$PROFILE</code> flag in the perl scripts BuildNGLayoutDebug.pl/BuildNGLayout.pl:
    </p>
<pre>
$PROFILE       = 1;
</pre>
    <p>
    When this flag is on, the scripts make an alias to <code>ProfilerLib</code> in <code>Essential Files</code>, and build a
    profiling target of NSRuntime.mcp, which exports the profiler functions.    
    </p>
    <p class="note">
    <em>Note</em>: Profiling was set up to work in a debug build. If you want to profile an optimized
    build, you'll have to make an optimized target in NSRuntime.mcp which exports profiler symbols.
    </p>
    </li>
    
    <li>
    <p>
    Put <code>#pragma profile on</code> in the prefix file for the project(s) you want to profile, after the
    <code>#include</code> of whatever file indirectly includes <code>IDE_options.h</code>. You can't just
    use the project preference checkbox, because this is overridden by the <code>#pragma</code>.
    </p>
    <p>
    Note that if you use this method, functions called in other libraries won't get profiled; you'll
    see time attributed to functions in this library, but you won't be able to attribute that to
    calls out to other modules.
    </p>
    </li>
</ul>

<p>
The second thing you need to do is to start and stop the profiler system. You
can do this via the calls in
<a href="http://lxr.mozilla.org/seamonkey/source/lib/mac/NSRuntime/src/ProfilerUtils.c">ProfilerUtils.c</a>,
which are already hooked up to the
<a href="http://lxr.mozilla.org/seamonkey/source/widget/src/mac/nsMacMessagePump.cpp">nsMacMessagePump</a>
and keyed off Caps Lock. Or you can call <code>ProfilerInit()</code>, <code>ProfilerDump()</code>
and <code>ProfilerTerm()</code> (from <code>&lt;Profiler.h&gt;</code>) yourself.
</p>

<p>
Having built with profiling on, and found the ideal spots for <code>ProfilerSetStatus()</code> calls,
run the app and collect some data. Hopefully, you'll end up with a data file that's not too large;
the Profiler viewer application tends to choke on data files more than about 4Mb in size.
</p>
<p>
This is the kind of view you get with the Metrowerks Profiler:
</p>

<p><img src="images/mwprofiler.gif" width="578" height="249" alt=""></p>

<p>
The data show the function name, number of times it was called (Count), the time spent
in just this routine (Only and %), the time spent in this routine and funtions that it
calls (+Children and %), and the Average, Minimum and Maximum time spent in this routine.
</p>
<p>
You can view the data in Summary format (just a flat list of functions), in Detailed format
(which shows call stacks, but which can thus list a function in more than one place), and
as time spent per Object (for C++ code). You'll switch mainly between the first two modes
to get a good feel for the data, and sort by % (only) or % (+Children) to get the most
time-consuming calls to the top.
</p>
<p>
Note that since this is an intrusive profiling method, the data collected are somewhat biased.
This profiler seems to give weight to small functions that are called frequently, so these will
show up high in the list; be aware of this before you jump in and starting trying to optimize
such functions.
</p>

<p>
The MW Profiler has its limitations. It gets confused by threading, so you might find that
the total time does not add up to 100%. It's uphappy with a lot of data, so it useless for
'big' performance problems (e.g startup time). It's intrusive, so it can bias the results
by weighing frequently call small functions.
Finally, you only get a fairly restricted view on your data; flat, call-chain or by object.
It's hard to view all callers of a function, for example.
</p>

<h3><a id="Instrumentation_SDK" name="Instrumentation_SDK">Instrumentation SDK</a></h3>

<p>
Apple's <a href="ftp://ftp.apple.com/developer/Development_Kits/Instrumentation_SDK.hqx">Instrumentation SDK</a>
is a different kind of profiling tool. To use it you have to put instrumentation points
in the code (or instrument the imports or exports of a CFM library, which is more advanced),
and, after running and collecting data, you can see a real-time graph of where the time is spent.
You can also collect a variety of other types of data using this SDK, such as histrogram,
growth and tally statistics.
</p>
<p>
To get instrumentation going in your build, follow these steps:
</p>
<ol>
    <li><a href="ftp://ftp.apple.com/developer/Development_Kits/Instrumentation_SDK.hqx">Download the SDK</a> from Apple</li>
    <li>Install the bits of the SDK as directed:
        <ul>
            <li>"InstrumentationLib" into your Extensions folder</li>
            <li>"Instrumentation <i>f</i>" to the root of your boot volume.<br>
            I usually color-code
            the spoolers with labels to make it clear what is what. We'll be using
            these: StatSpooler, TraceSpooler, ClassSpooler.</li>
            <li>
            Copy "Interfaces &amp; Libraries" to your Metrowerks Codewarrior "MacOS Support" folder.
            </li>
        </ul>
    </li>
</ol>

<p>
To instrument C++ code, we can use some helpers in
<a href="http://lxr.mozilla.org/seamonkey/source/lib/mac/Instrumentation/InstrumentationHelpers.h"><code>InstrumentationHelpers.h</code></a>.
This file provides the macros <code>INST_TRACE</code>, <code>INST_TRACE_MIDDLE</code>
and <code>INST_TRACE_DATA</code> that instantiate a stack-based class, whose ctor logs
the start event, and dtor logs the end event. In C code, you'll have to call use the macros
in <code>&lt;InstrumentationMacros.h&gt;</code>, which require you to put calls at both function entry
and exit points.
</p>
<p>
To get the <code>mozilla/lib/mac/Instrumentation</code> folder in CVS, you need to check it out explicitly
(since it's not in the SeaMonkey module). In MacCVS, use the "Checkout module to", and enter that path.
</p>
<p>
Now it's time to instrument some code. Let's say we want to instrument method <code>Foobar()</code>.
New lines are in <span style="color: red;">red</span>:
</p>
<pre>
<span style="color: red;">#include "InstrumentationHelpers.h"</span>
...
void nsSomeClass::Foobar()
{
    <span style="color: red;">INST_TRACE("Foobar call");</span>
    ...
}
</pre>
<p>
Note that INST_TRACE() takes a string, which is used to identify traces from
this location in the viewer. You can use a colon-delimited string here
to get a hierarchy in the viewer, but b<i>e careful not to copy-paste
method names with double colons</i> (<code>"nsSomeClass::Foobar"</code>). The backend gets
unhappy with what it sees as empty category names.
</p>
<p>
Once you've added calls to the Instrumentation system, you need to link that shared library
with the <code>InstrumentationLib</code> stub library. So find <code>InstrumentationLib</code> in
the Instrumentation headers and libraries that you copied into CodeWarrior's "MacOS Support folder",
and add that library to the project. At runtime, the library will dynamically link
with the "InstrumentationLib" library in the Extensions folder.
</p>
<p>
Deciding where to put instrumentation points can be tricky, and it really depends on the
kind of problem you are looking at. One general approach is to go top-down; start with
the root call of a time-consuming subtree, then work your way down, collecting data
all the while, and sprinking instrumentation points around where they can give you the
best feel for where time is being spent. Ideally, you'll end up with a smallish number
of instrumentation points that you can use to say where almost all the time is going.
</p>
<p>
Once you're built with instrumentation points, collect data like this:
</p>
<ol>
    <li>Fire up the data spoolers StatSpooler, TraceSpooler, ClassSpooler. These
    will spool data from the instrumentation backend to disk files as you run.</li>
    <li>Run Mozilla, and exercise the code you instrumented</li>
    <li>Quit Mozilla</li>
    <li>Use the "Quit Spoolers" AppleScript to quit the spoolers</li>
    <li>Run the SpoolPackager to package the separate data files into one data file.<br>
    <em>Note</em>: this clobbers any existing files called "Instrumentation Data" in this folder.</li>
    <li>Open the Instrumenation Viewer, and use it to look at the new data<br>
    <em>Note</em>: the viewer remembers the last data file that you viewed, and opens that
    with the view file by default. You often have to explicitly open your new data file.</li>
</ol>

<p>
The Instrumentation Viewer is best learned by reading the documentation that comes
with the SDK. You'll be using Time Line views a lot, and possibly trace histograms
to see time summaries (use text histograms).
</p>
<p>
This image shows a sample view for Mozilla startup, using a Time Line viewer.
</p>

<p> <img src="images/instrumentation.gif" width="546" height="377" alt=""></p>

<p>
Performance evaluation with the Instrumentation SDK is a much more investigative process
than with the Metrowerks profiler, because you have to go in an instrument the code
by hand. You'll also find the debugger a useful companion, to find out where various
routines are being called. As long as you don't instrument a frequently called routine,
this profiler has low overhead, and gives accurate results. It's excellent for understanding
timing related issues, such as synchronization between threads, or event latency issues.
</p>

<h3><a id="Chronoscope" name="Chronoscope">Chronoscope</a></h3>
<p>
Chronoscope is another instrumenting profiler, which, for now, only works on Mac OS 9.
Like the MW Profiler, it uses the <code>__PROFILE_ENTRY()</code> and
<code>__PROFILE_EXIT()</code> hooks generated when the compiler is generating profile information.
As long as you use the Chronoscope API calls to instrument NSPR thread creation and deletion,
and context switching (see <a href="http://bugzilla.mozilla.org/show_bug.cgi?id=111024">this bug</a>
for a patch), then Chronoscope is thread-savvy, and will allow
you to see function timing for each thread independently. Chronoscope will also show
when interrupt-time code is running (e.g. async file I/O callbacks).
</p>

<p>
To obtain a copy of Chronoscope, go to the <a href="http://chronoscope.sourceforge.net">Chronoscope home page</a>
and look for the download link,	or go directly to the <a href="http://sourceforge.net/projects/chronoscope/">Chronoscope page</a> on
<a href="http://www.sourceforge.net">SourceForge</a>. Building from source will get you the most up-to-date
version of the tool. Because this tool is still in progress, you should have MacsBug installed
when using it.
</p>

<p>
To start profiling with Chronoscope, do a build with profiling turned on, as described in the
<a href="#Metrowerks_Profiler">MW Profiler section</a> above. Edit
<a href="http://lxr.mozilla.org/seamonkey/source/lib/mac/NSRuntime/ProfilerExport.exp">ProfilerExport.exp</a>,
replacing the function names under "<code>#utils</code>" with
</p>
<pre>
ChronoInit
ChronoGetStatus
ChronoSetStatus
ChronoTerm
ChronoTask
ChronoEnterInterrupt
ChronoLeaveInterrupt
ChronoCreateThread
ChronoDeleteThread
ChronoEnterThread
</pre>
<p>
and add the "ChronoscopeStubs" library to the project, removing the ProfilerLib library.
</p>
<p>
To initialize the profiler, add a call to <code>ChronoInit()</code> somewhere, like the beginning of main():
</p>
<pre>
#if __profile__
  OSErr err = ::ChronoInit( PR_GetCurrentThread(),   /* main thread */
                            NULL,                    /* output file; NULL uses default */
                            16000,                   /* number of unique functions */
                            100,                     /* max stack depth */
                            10000000,                /* max accumulated samples */
                            kChronoOverheadIgnore    /* profiling overhead accounting (ignored) */
                            );
  if (err != noErr)
    DebugStr("\pChronoscope failed to init");
#endif
</pre>
<p>
Chronoscope needs to spool data to disk; add calls to <code>ChronoTask()</code> in places
that will get hit between large chunks of profiled code (e.g. in the event loop). When you're
done, call <code>ChronoTerm()</code> to have Chronoscope finish writing data to disk.
See patches in <a href="http://bugzilla.mozilla.org/show_bug.cgi?id=111024">bug 111024</a>
for changes that do this already.
</p>

<p>
Once you have your build set up, use <code>ChronoSetStatus()</code> to turn profiling on
for the code that you care about, and run the app. If Chronoscope complains about running
out of data collection space, increase the 'max accumulated samples' parameter to
<code>ChronoInit()</code>, and/or sprinkle more <code>ChronoTask()</code> calls around in the code.
</p>

<p>
Hopefully, you'll get a big data file (they can easily grow to several hundred megabytes). Drag
this onto the ChronoViewer application, and it will load the file, and start showing traces:
</p>

<p><img src="images/chronoscope_trace_window.gif" alt="Chronoscope trace window" width="539" height="384"></p>

<p>
See the <a href="http://chronoscope.sourceforge.net">Chronoscope home page</a> for documentation that
explains how to interpret these traces.
</p>

<p>
Chronoscope's advantages are that it shows complete and correct information on the graph and
timing of function calls, including interrupt code (assuming that you're running it on the cooperatively
threaded Classic Mac OS), and fairly accurately adjusts the output for its own profiling overhead. It does,
however, have a high runtime overhead, and is not quite beefy enough to deal with a data file for a full
Mozilla run.
</p>

<h2><a id="Memory_Leaks" name="Memory_Leaks">Memory Leaks</a></h2>

<p>
Contrary to popular opinion, you can usefully do
<a href="http://lxr.mozilla.org/mozilla/source/xpcom/doc/MemoryTools.html">memory leak work</a> on Mac OS 9.
The <a href="refcnt-balancer.html">refcount balancer</a> works well, and, in addition, you have a number of
options for memory allocators and heap-inspection tools.
</p>

<h3><a id="Refcount_balancer_on_Mac" name="Refcount_balancer_on_Mac">Refcount balancer on Mac</a></h3>
<p>
As described on the <a href="refcnt-balancer.html">refcount balancer</a> page, to set
the necessary environment variables on Mac, make a text file called "environment" in the
Mozilla folder, and put in the variables. To run the various perl scripts, get the
<a href="http://www.perl.com/CPAN-local/ports/mac/">MPW Perl</a> tool, and use MPW
as your scripting environment. After setting the current
folder to that contining the script and data files, all the perl commands listed
on that page should work just fine.
</p>


<h3><a id="Other_resources" name="Other_resources">Other Mac OS 9 resources</a></h3>
<p>
Mac builds also allow you to inspect and fiddle with aspects of memory management that
make bug hunting and leak tracking a little easier.
</p>
<p>
Metrowerks <a href="http://www.metrowerks.com/tools/software/zoneranger/">ZoneRanger</a> allows you
to inspect the application heap, and memory blocks that are allocated in temporary memory (since
each of these is a heap zone). Note that you can't see down to the level of individual malloc'ed blocks,
since we have our own
<a href="http://lxr.mozilla.org/seamonkey/source/lib/mac/MacMemoryAllocator/src/">malloc implementation</a>.
If you want to have ZoneRanger show you every block that is allocated, you can rebuild 
the "MemAllocatorNewPtr.o" target of the
<a href="http://lxr.mozilla.org/seamonkey/source/lib/mac/MacMemoryAllocator/MemAllocator.mcp">MemAllocator.mcp</a>
project (you'll have to fix up some linkage issues if you try this right now). This version of
the allocators does a NewPtr for every malloc, which is very slow, and for which you'll have to
give Mozilla a much larger partition. But it does let you track individual blocks, and use things
like <code>hs</code> in MacsBug to check for heap corruption.
</p>


<h2><a id="Mac_OS_X_Tools" name="Mac_OS_X_Tools">Mac OS X Tools</a></h2>
<p>
Mac OS X comes with a number of developer tools for performance evaluation and testing, some of
which are sufficient to replace some of the home-grown mozilla tools. The
<a href="http://developer.apple.com/techpubs/macosx/Essentials/Performance/index.html">Mac OS X performance document</a>
talks about most of them.
</p>

<h3><a id="Available_tools_on_Mac_OS_X" name="Available_tools_on_Mac_OS_X">Available tools on Mac OS X</a></h3>
<ul>
	<li>Interactive tools
		<ul>
			<li>Sampler -- sampling profiler, can also show heap allocations and file system calls</li>
			<li>MallocDebug -- for tracking allocations and leaks</li>
			<li>ObjectAlloc -- for tracking allocations</li>
			<li>QuartzDebug -- for examining screen drawing and window usage</li>
		</ul>
	</li>
	
	<li>Command-line tools
		<ul>
			<li><code>fs_usage</code> -- logs file system calls (like <code>strace</code>)</li>
			<li><code>fc_usage</code> -- system call stastics</li>
			<li><code>top</code> -- CPU usage, memory footprint, events</li>
			<li><code>vmmap</code> -- shows virtual memory regions used</li>
			<li><code>gprof</code> -- instrumenting profiler uses gcc hooks; generation of order files.</li>
			<li><code>heap</code>, <code>leaks</code>, <code>pagestuff</code> etc.</li>
		</ul>
	</li>
</ul>


<h3><a id="Sampler" name="Sampler">Sampler</a></h3>

<p>
Sampler is a sampling profiler that shows which functions are on the stack when sampling took place; it
thus gives a statistical picture of where the app spends time. There is a command-line version called <code>sample</code>.
</p>
<p>
Sampler can also track
</p>
<ul>
	<li>Memory allocations (bloat attributed to a call stack)</li>
	<li>File system calls</li>
	<li>User-specified routines</li>
</ul>

<p>
Sampler is easy to run, and is a good way of getting a first impression of where the app is spending time
(especially good for infinite loop bugs). It works for CFM and Mach-O builds, and supposedly detects leaked cycles and structures.
</p>

<p> 
However, it can be unstable (finding memory leaks, and tracking user routines always crashes for me). It
also suffers from sampling errors typical of sampling profilers; it can miss small functions,
while placing undue emphasis on functions during which preemption occurs. It also has a fairly
low sampling resolution (~10ms). For leak tracking, its memory tracking doesn't understand Carbon Handles,
so will miss some leaks.
</p>

<h3><a id="MallocDebug" name="MallocDebug">MallocDebug</a></h3>
<p>
MallocDebug is a goo tool for investigation of memory use, leaks, block trashing. MallocDebug can show:
</p>
<ul>
	<li>Extant memory with allocation stack (does <i>not</i> show freed memory)
	<li>Memory allocated since a given point in time
	<li>Leaks. Uses a conservative GC to find unreferenced blocks of memory.
	<ul>
		<li>Definite leaks--no references to any address in a block
		<li>Possible leaks--no refs to the start of the block, but refs exist to the middle of the block.
		<li>All leaks--union of definite and possible leaks.
	</ul>
</ul>
<p>
It optionally overwrites freed memory with <code>0x55</code>, and puts markers before and after each allocated buffer
to detect buffer over- and underflows; it will write to the console to notify you of smashed blocks.
To find out more about where your program is trashing memory, you can run under <code>gdb</code> with the
MallocDebug library. MallocDebug works for CFM and Mach-O builds.
</p>
<p>
Since MallocDebug uses a conservative GC for leak tracking, it does miss some leaks: cycles of leaked objects,
and any non-root objects in a leaked object tree. Other disadvantages are that it can give partial stack traces
because it seems to fail to get symbols for many routines, and it can be unstable.
</p>

<h3><a id="ObjectAlloc" name="ObjectAlloc">ObjectAlloc</a></h3>
<p>
ObjectAlloc is a program that tracks all allocations your program makes over time, and can show,
for any time point, a list of total, and extant allocations, with call stacks and block sizes.
It seems to work pretty well, though again does suffer from failed symbol lookups, and its
results can contain noise (for CFM builds) from the CFM launcher.
</p>

<h3><a id="QuartzDebug" name="QuartzDebug">QuartzDebug</a></h3>
<p>
This program is mainly useful for showing when applications draw on screen, and can be used
to discover over-drawing problems. It is also capable of displaying a list of all the windows
in use, and their memory overhead (mainly backing store size).
</p>


<h3><a id="Command-line_tools" name="Command-line_tools">Command-line tools</a></h3>
<p>
There are several command-line tools that either duplicate functionality in the tools described
above, or show other kinds of performance data.
</p>

<dl>
	<dt><code>top</code></dt>
		<dd>Shows CPU usage, various measure of resource usage.<ul>
				<li>Show process size (<code>-w</code> for extras)</li>
				<li>Show event handling (<code>-e</code> or <code>-d</code> for deltas)</li>
			</ul>
		</dd>
	<dt><code>fs_usage</code></dt>
	    <dd>
	        Shows file system usage. Have to run as root. Use <code>fs_usage <i>pid</i> -w > <i>outfile</i></code>
	    </dd>
	<dt><code>sc_usage</code></dt>
	    <dd>
	        <code>top</code>-like utility that shows cumulative counts of system calls and page faults.
	    </dd>
	<dt><code>vmmap</code></dt>
	    <dd>
	        Shows virtual memory regions associated with the process, including code and data, stack, malloc heap, the
	        access permissions of those memory regions etc.
	    </dd>
	<dt><code>heap</code></dt>
	    <dd>
	    Shows allocated blocks, like MallocDebug
	    </dd>
	<dt><code>leaks</code></dt>
	    <dd>
	        Show leaked blocks (unreferenced), optionally showing stack traces for each allocation, if the environment
	        variable <code>MallocStackLogging</code> is set. Similar to Sampler's leak tracking.
	    </dd>
	<dt><code>malloc_history</code></dt>
        <dd>
            Shows stack traces for each allocation if <code>MallocStackLogging</code> is set.
        </dd>
	<dt><code>pagestuff</code></dt>
	    <dd>    
	        Tool for analysing a compiled binary, showing what symbols are present in each logical page of the file,
	        or every section of the file. Useful to check the outcome of code ordering, or to look for linker issues.
	    </dd>
</dl>

<h2><a id="Resources" name="Resources">Resources</a></h2>
<p>
</p>

<h3><a id="Technotes" name="Technotes">Technotes</a></h3>
<h4><a id="Mac_OS_9" name="Mac_OS_9">Mac OS 9</a></h4>
<ul>
	<li><a href="http://developer.apple.com/technotes/fl/fl_16.html">FL 16: File Manager Performance and Caching</a></li>
	<li><a href="http://developer.apple.com/technotes/tn/tn1059.html">TN 1059: On Improving Open Transport Server Performance</a>
	<li><a href="http://developer.apple.com/technotes/tn/tn1174.html">TN 1174: Optimization strategies for Mac OS</a></li>
	<li><a href="http://developer.apple.com/technotes/tn/tn2028.html">TN 2028: Threading Architectures</a></li>
</ul>

<h4><a id="Mac_OS_X" name="Mac_OS_X">Mac OS X</a></h4>
<ul>
	<li><a href="http://developer.apple.com/techpubs/macosx/Essentials/Performance/index.html">Mac OS X Performance</a></li>
	<li><a href="http://developer.apple.com/techpubs/macosx/ReleaseNotes/PerformanceTools.html">Mac OS X performance tools release notes</a></li>
</ul>

<h4><a id="Downloads" name="Downloads">Downloads</a></h4>
<ul>
	<li><a href="ftp://ftp.apple.com/developer/Development_Kits/Instrumentation_SDK.hqx">Instrumentation SDK</a></li>
	<li><a href="http://chronoscope.sourceforge.net">Chronoscope</a></li>
	<li><a href="ftp://ftp.stairways.com/">Interarchy</a> (traffic watching)</li>
	<li><a href="http://www.clarkwoodsoftware.com/peekaboo/">Peek-a-Boo</a> (CPU usage on Mac OS 9)</li>
</ul>


<hr>
<address>Simon Fraser <code><a href="mailto:sfraser@netscape.com">&lt;sfraser@netscape.com&gt;</a></code></address>


<hr class="hide">
</div>
</div>
<div id="footer">
<ul>
<li><a href="../sitemap.html">Site Map</a></li>
<li><a href="../security/">Security Updates</a></li>
<li><a href="../contact/">Contact Us</a></li>
<li><a href="../foundation/donate.html">Donate</a></li>
</ul>
<p class="copyright">
Portions of this content are &copy; 1998&#8211;2009 by individual mozilla.org
contributors; content available under a Creative Commons license | <a
href="http://www.mozilla.org/foundation/licensing/website-content.html">Details</a>.</p>
<p>
<span>Last modified June  7,  2005</span>
<span><a href="http://bonsai-www.mozilla.org/cvslog.cgi?file=mozilla-org/html/performance/mac-performance.html&amp;rev=&amp;root=/www/">Document History</a></span>
</p>
</div>
</div>
</body>
</html>
