<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<link rel="top" title="Home" href="http://www.mozilla.org/">
<link rel="stylesheet" type="text/css" href="../../../css/print.css"  media="print">
<link rel="stylesheet" type="text/css" href="../../../css/base/content.css"  media="all">
<link rel="stylesheet" type="text/css" href="../../../css/cavendish/content.css" title="Cavendish" media="screen">
<link rel="stylesheet" type="text/css" href="../../../css/base/template.css"  media="screen">
<link rel="stylesheet" type="text/css" href="../../../css/cavendish/template.css" title="Cavendish" media="screen">
<link rel="icon" href="../../../images/mozilla-16.png" type="image/png">


  <title>The Mozilla DOM Hacking Guide</title>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">

<meta name="DC.author" content="Fabian Guisset">
<meta name="DC.creator" content="Fabian Guisset">
<meta name="DC.title" content="The Mozilla DOM Hacking Guide">
<meta name="DC.subject" content="The Mozilla DOM Hacking Guide">
<meta name="DC.date.created" content="2001-05-18T06:29:03+11:00" scheme="W3CDTF">
<meta name="DC.date.modified" content="2006-08-27T09:54:03+11:00" scheme="W3CDTF">
  
<script src="../../../__utm.js" type="text/javascript"></script>
</head>
<body id="www-mozilla-org" class="deepLevel">
<div id="container">
<p class="important">You are currently viewing a snapshot of www.mozilla.org taken on April 21, 2008. Most of this content is
highly out of date (some pages haven't been updated since the project began in 1998) and exists for historical purposes only.  If
there are any pages on this archive site that you think should be added back to www.mozilla.org, please <a
href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Websites&component=www.mozilla.org">file a bug</a>.</p>
<p class="skipLink"><a href="#mainContent" accesskey="2">Skip to main content</a></p>
<div id="header">
<h1><a href="/" title="Return to home page" accesskey="1">Mozilla</a></h1>
<ul>
<li id="menu_aboutus"><a href="../../../about/" title="Getting the most out of your online experience">About</a></li>
<li id="menu_developers"><a href="../../../developer/" title="Using Mozilla's products for your own applications">Developers</a></li>
<li id="menu_store"><a href="http://store.mozilla.org/?r=mozorg1" title="Shop for Mozilla products on CD and other merchandise">Store</a></li>
<li id="menu_support"><a href="../../../support/" title="Installation, trouble-shooting, and the knowledge base">Support</a></li>
<li id="menu_products"><a href="../../../products/" title="All software Mozilla currently offers">Products</a></li>
</ul>
<form id="searchbox_002443141534113389537:ysdmevkkknw" action="http://www.google.com/cse" title="mozilla.org Search">
<div>
<label for="q" title="Search mozilla.org's sites">search mozilla:</label>
<input type="hidden" name="cx" value="002443141534113389537:ysdmevkkknw">
<input type="hidden" name="cof" value="FORID:0">
<input type="text" id="q" name="q" accesskey="s" size="30">
<input type="submit" id="submit" value="Go">
</div>
</form>
</div>
<hr class="hide">
<div id="mBody">
<div id="side">

<ul id="nav">
<li><a title="Roadmap" href="../../../roadmap.html"><strong> Roadmap</strong></a></li>
<li><a title="Projects" href="../../../projects/"><strong> Projects</strong></a></li>
<li><a title="For developers" href="../../../developer/"><strong> Coding</strong></a>
<ul>
<li><a title="Module Owners" href="../../../owners.html"> Module Owners</a></li>
<li><a title="Hacking" href="../../../hacking/"> Hacking</a></li>
<li><a title="Get the Source" href="http://developer.mozilla.org/en/docs/Download_Mozilla_Source_Code"> Get the Source</a></li>
<li><a title="Building Mozilla" href="http://developer.mozilla.org/en/docs/Build_Documentation"> Build It</a></li>
</ul>
</li>
<li><a title="Testing" href="../../../quality/"><strong> Testing</strong></a>
<ul>
<li><a title="Downloads of mozilla.org software releases" href="../../../download.html"> Releases</a></li>
<li><a title="Latest mozilla builds for testers" href="../../../developer/#builds"> Nightly Builds</a></li>
<li><a title="For testers to report bugs" href="https://bugzilla.mozilla.org/"> Report A Problem</a></li>
</ul>
</li>
<li><a title="Tools for mozilla developers" href="../../../tools.html"><strong> Tools</strong></a>
<ul>
<li><a title="Bug tracking system for mozilla testers." href="https://bugzilla.mozilla.org/"> Bugzilla</a></li>
<li><a title="Latest status of mozilla builds" href="http://tinderbox.mozilla.org/showbuilds.cgi?tree=Firefox"> Tinderbox</a></li>
<li><a title="Latest checkins" href="http://bonsai.mozilla.org/cvsqueryform.cgi"> Bonsai</a></li>
<li><a title="Source cross reference" href="http://lxr.mozilla.org/seamonkey/"> LXR</a></li>
</ul>
</li>
<li><a title="Frequently Asked Questions." href="../../../faq.html"><strong> FAQs</strong></a></li>
</ul>

</div>
<hr class="hide">
<div id="mainContent">








<table cellspacing="0" cellpadding="4">
  <tbody>
    <tr style="background-color: #F5F5DC;">
      <td><a href="../index.html">DOM</a></td>
      <td>&gt;</td>
      <td><a href="index.html">Mozilla</a></td>
      <td>&gt;</td>
      <td>Hacking</td>
    </tr>
  </tbody>
</table>

<h1>The Mozilla DOM Hacking Guide</h1>
<p class="author">Fabian Guisset &lt;<a href="mailto:fguisset@softhome.net">fguisset@softhome.net</a>&gt;</p>

<div id="warning" class="important">
Warning: this document has not yet been reviewed by the DOM gurus, it might 
contain some errors. It is also perhaps outdated in parts, because of recent
changes in the DOMClassInfo code. If anyone wants to help, please let me know.
</div>

<div id="introduction">
<p>

  Mozilla gives you the opportunity not only to 
  <span style="font-weight: bold;">use</span> a very powerful and complete DOM 
  support, but also to <span style="font-weight: bold;">work</span> on a 
  world-class implementation of one of the greatest Internet technology ever 
  created.

</p>
<p>

  Mozilla's DOM is coded almost entirely in C++. Seriously hacking on it 
  requires excellent knownledge of C++ and XPCOM, Mozilla's own component model. 
  In this document I will try to outline the main aspects of the implementation,
  begining with the Class Info mechanism, which lies at the heart of the DOM,
  then with the description of various interfaces and classes. Since I am myself 
  still learning how it works, don't expect this to be a complete reference 
  quite yet. If you can contribute any time or knowledge to this document, it is 
  greatly appreciated!

</p>
<p>

  Target audience: People interested in learning how the DOM is implemented.
  Prior knowledge of C++ and XPCOM is assumed. If you don't know XPCOM yet,
  and would like to be able to read this document quickly, you can read the 
  <a href="http://developer.mozilla.org/en/docs/Introduction_to_XPCOM_for_the_DOM">introduction
  to XPCOM for the DOM</a>. Otherwise,
  for more detailed XPCOM documentation, please see the
  <a href="../../../projects/xpcom/">XPCOM project page</a>.

</p>
<ul>
  <li>Chapter 1. The Class Info mechanism.
  <ul>
    <li>
      <a href="#onea">1.A. Introduction to Class Info</a></li>
    <li>
      <a href="#oneb">1.B. Interface flattening</a></li>
    <li>
      <a href="#onec">1.C. Helper Classes</a></li>
    <li>
      <a href="#oned">1.D. The nsDOMClassInfo class</a></li>
    <li>
      <a href="#onee">1.E. nsDOMClassInfo::Init()</a></li>
    <li>
      <a href="#onef">1.F. nsDOMClassInfo::GetClassInfoInstance()</a></li>
    <li>
      <a href="#oneg">1.G. nsWindowSH::GlobalResolve()</a></li>
    <li>
      <a href="#oneh">1.H. User's Guide to Class Info</a></li>
    <li>
      <a href="#onei">1.I. Scriptable Helper flags</a></li>
    <li>
      <a href="#onej">1.J. Security features implementation</a></li>
  </ul>
  </li>
</ul>
    
</div>

<div id="chapterone">
<h1>Chapter One: Class Info and Helper Classes</h1>
</div>

<div id="chapteronea">
  <h2>
  <a name="onea">1.A. Introduction to Class Info</a>
  </h2>
<p>

  Class Info is what gives the DOM classes their correct behavior when used
  through XPConnect. It lies at the heart of the famous "XPCDOM landing" that
  happened in May. We will talk alot about XPConnect in this document, since
  it is so important for the DOM. By "correct behavior", I mean "the
  intended behavior with respect to the specification or de facto standard".
  We will see that Class Info is mainly used to implement the DOM Level 0.
  The W3C DOM is mainly implemented in IDL. The goals of Class Info are
  twofolds: Interface flattening, and implementing behaviors that are not 
  possible with IDL alone.

</p>
<p>

  A brief introduction to JavaScript and XPConnect.

</p>
<p>

  Before we begin the explanation of Class Info, I'd like to introduce quickly
  the JavaScript engine and XPConnect. In JavaScript, there is no knowledge
  of types, like there is in C++. A function for example can be represented
  by a JSFunction, a JSObject, a jsval, ... This means that when we use the
  DOM from JavaScript, we pass arguments that have no type.
  However, since the DOM is coded in C++, we expect to receive an argument
  of the correct type for our function. This is one of the jobs of XPConnect.
  XPConnect will "wrap" the argument in a wrapper that will be of the type
  expected by our C++ function. Similarly, then return type of the C++
  function will be wrapped by XPConnect so that JavaScript can use it safely.

</p>
<p>

  When, in JavaScript, a client tries to access a DOM object or a DOM method
  on a DOM object, the JS engine asks XPConnect to search for the relevant
  C++ method to call. For example, when we ask for 
  |document.getElementById("myID");|, XPConnect will find that |document| is a
  property of the window object, so it will look on the interface nsIDOMWindow,
  and it will find the GetDocument() method. The return value of GetDocument()
  is a nsIDOMDocument. So XPConnect will then try to find a method named
  GetElementById() on the nsIDOMDocument interface. And indeed it will find it,
  and thus call it.

</p>
<p>

  This is the schema used most of the time when using W3C DOM objects and
  methods. It is however different for some DOM Level 0 objects and
  methods. I'll take two very different examples. The first one is the
  window.location object (the same holds true for document.location, actually).
  We can change the URL of the current window by assigning window.location.
  In IDL, location is declared to be a readonly attribute. This is because,
  if we had a SetLocation() method, it would take an nsIDOMLocation parameter,
  and not a URL string. Instead, in the helper class for the window object
  (nsWindowSH, see the next Section), we define the GetProperty() member
  function. GetProperty() is a function used by XPConnect when we are setting
  an unknown property on the object (window, in our case). In GetProperty(),
  we check if the property being set is "location". If that is the case,
  we call nsIDOMLocation::SetHref(). In fact, when setting window.location,
  we really set window.location.href. This is all possible thanks to the
  magic of the interaction between XPConnect and the DOM.

</p>
<p>

  The second example is the history object. Other browsers allow the history
  object to be used like an array, e.g. history[1]. The behavior "act as an
  array" cannot be reflected in the IDL itself. Fortunately, XPConnect
  provides us with a way to make our class available as an array in JavaScript.
  I'm talking about the "scriptable flags". The nsIXPCScriptable interface,
  implemented by the nsDOMClassInfo class (see Section) defines several flags,
  one of which is the WANT_GETPROPERTY flag. When set, it allows us to define
  a GetProperty() function on nsHistorySH (the helper class for the history
  object), which will handle the array behavior. Indeed, it will forward the
  call history[1] to history.item(1), which is defined in the IDL and easily
  coded. The relevant code is at
  <a href="http://lxr.mozilla.org/seamonkey/source/dom/src/base/nsDOMClassInfo.cpp#4520">
  http://lxr.mozilla.org/seamonkey/source/dom/src/base/nsDOMClassInfo.cpp</a>,
  around line 4520.

</p>
<p>

  These two examples demonstrate the power of the DOM combined with XPConnect
  and the JavaScript engine. The possibilities are endless. "What do you want
  to code today?" ;-)

</p>
<p>

  <a name="domclasses">All the DOM classes</a> are listed in an enum defined in
  <a href="http://lxr.mozilla.org/seamonkey/source/dom/public/nsIDOMClassInfo.h">nsIDOMClassInfo.h</a>,
  nsDOMClassInfoID. There are classes for the DOM0, Core DOM, HTML, XML, XUL, 
  XBL, range, css, events, etc...

</p>
<p>

  The array sClassInfoData, defined in
  <a href="http://lxr.mozilla.org/seamonkey/source/dom/src/base/nsDOMClassInfo.cpp">nsDOMClassInfo.cpp</a>,
  maps each DOM class to its helper class and to the interfaces that are exposed to JavaScript.
  It is an array of type nsDOMClassInfoData, which is a structure defined in 
  <a href="http://lxr.mozilla.org/seamonkey/source/dom/public/nsIDOMClassInfo.h">nsIDOMClassInfo.h</a>.
  The array uses two macros to define its items:
  <code>NS_DEFINE_CLASSINFO_DATA</code> and <code>NS_DEFINE_CLASSINFO_DATA_WITH_NAME</code>.
  The first one calls the second one. The first argument passed to 
  <code>NS_DEFINE_CLASSINFO_DATA_WITH_NAME</code>, _class, is used for debug purposes.
  The second argument, _name, is the name that should appear in JavaScript.
  The third argument, _helper, is the name of the helper class for this DOM
  class. Helper classes are detailed in Section 1.C. The fourth and last
  argument, _flags, is a bitvector of nsIXPCScriptable flags. The macros for
  those flags are defined <a href="http://lxr.mozilla.org/seamonkey/source/dom/src/base/nsDOMClassInfo.cpp">nsDOMClassInfo.cpp</a>.
  The flags give special behavior through XPConnect. See also Section 1.I.

</p>
<p>

  The nsDOMClassInfoData objects are created in the sClassInfoData array by 
  explicitly initializing it. Here is the description of the structure:

</p>
<ul>
  <li><code>const char *mName</code>: C-style string that is passed as second
  argument to the macro. It is the name of the JavaScript object that will be
  available in the browser through the DOM.</li>
  <li>
<pre class="code">
union {
  nsDOMClassInfoConstructorFnc mConstructorFptr;
  nsDOMClassInfoExternalConstructorFnc mExternalConstructorFptr;
} u;
</pre>
  This union is a pointer to a function typedef'ed:<br>
  <code>typedef nsIClassInfo* (*nsDOMClassInfoConstructorFnc)(nsDOMClassInfoID aID);</code>
  <br> or <br>
  <code>typedef nsIClassInfo* (*nsDOMClassInfoExternalConstructorFnc) (const char* aName);</code>
  It is initialized with the doCreate member function of the helper class passed
  as third argument to the macro.</li>
  <li><code>nsIClassInfo *mCachedClassInfo</code>: mCachedClassInfo holds an
  nsIClassInfo pointer to an instance of the relevant helper class.</li> 
  <li><code>const nsIID *mProtoChainInterface</code>: Pointer to the IID of the 
  first interface available to JavaScript clients. This is used in global
  resolve functions, when XPConnect has to find the member function to call.</li>
  <li><code>const nsIID **mInterfaces</code>: Pointer to the first element of an
  array of pointers to all the interfaces available through JS for this class.</li>
  <li><code>PRUInt32 mScriptableFlags: 31;</code> : The fourth argument passed
  to NS_DEFINE_CLASSINFO_DATA_WITH_NAME.</li>
  <li><code>PRBool mHasClassInterface: 1;</code> : Help me?</li>
</ul>

<p>

  mName and mConstructorFptr, mScriptableFlags and mHasInterface are initialized
  by NS_DEFINE_CLASSINFO_DATA_WITH_NAME. mCachedClassInfo, mProtoChainInterface
  and mInterfaces, however, are initialized in nsDOMClassInfo::Init(), described
  in Section 1.E.

</p>
</div>

<div id="chapteroneb">
  <h2>
  <a name="oneb">1.B. Interface flattening</a>
  </h2>

<p>

  One of the nicest -- and most important -- features of the XPConnect'ed DOM
  is the interface flattening. "Interface flattening is the ability to call
  methods on an object regardless of the interface it was defined on."
  For example, when we have the document object in JavaScript, we can
  call indistinctly document.getElementById(), or document.addEventListener(),
  although they are defined on two different interfaces
  (<a href="http://lxr.mozilla.org/seamonkey/source/dom/public/idl/core/nsIDOMDocument.idl">
  DOMDocument</a> and
  <a href="http://lxr.mozilla.org/seamonkey/source/dom/public/idl/events/nsIDOMEventTarget.idl">
  DOMEventTarget</a>. Needless to say this is critical for the use of the DOM
  in real-world content.

</p>
<p>

  In Mozilla interface flattening is obtained through the use of the
  nsIClassInfo interface. nsIClassInfo stores the interfaces available for an
  object and later on XPConnect uses those interfaces to lookup the right
  method to call.

</p>
<p>

  The great thing is that one can easily see the interfaces available from
  JS through interface flattening by looking at the code. The interesting part
  is in 
  <a href="http://lxr.mozilla.org/seamonkey/source/dom/src/base/nsDOMClassInfo.cpp">
  nsDOMClassInfo::Init()</a>. There we have a long list of macros.
  There is one set of macros per <a href="#domclasses">DOM class</a>. There
  you can see, for each object, what interfaces are part of the "flattened"
  set. As an example, on the window object, we can call all the methods defined
  on the following interfaces: nsIDOMWindow, nsIDOMWindowInternal,
  nsIDOMJSWindow, nsIDOMEventReciever, nsIDOMEventTarget, nsIDOMViewCSS, and
  nsIDOMAbstractView. Again, without caring on what interface the method is 
  defined. See Section 1.E for more information about the Init() method.

</p>
<p>

  For the W3C DOM (Level 1, 2, 3) objects, for each object there is one
  "standards-compliant" interface, which is exactly the same as the W3C one,
  named nsIDOM&lt;ObjectName&gt;.idl, and a mozilla-specific extension interface,
  named nsIDOMNS&lt;ObjectName&gt;.idl, for compatibility with DOM Level 0.
  For example, the HTML "area" element has the following interfaces in its
  flattened set: nsIDOMHTMLAreaElement and nsIDOMNSHTMLAreaElement.

</p>
</div>

<div id="chapteronec">
  <h2>
  <a name="onec">1.C. Helper Classes</a>
  </h2>

<p>

  nsDOMClassInfo.h defines several new classes. They all end in "SH", for
  "Scriptable Helper" e.g. nsWindowSH, nsElementSH, ... . We call these
  classes the "Helper Classes". <em>All</em> the helper classes inherit
  from the nsDOMClassInfo class. To demonstrate this, look in
  <a href="http://lxr.mozilla.org/seamonkey/source/dom/src/base/nsDOMClassInfo.h">nsDOMClassInfo.h</a>.
  We can see that the nsEventRecieverSH helper class inherits from
  nsDOMGenericSH:

</p>
<p>

  <code>class nsEventRecieverSH : public nsDOMGenericSH</code>.

</p>
<p>

  And nsDOMGenericSH is typedef'ed to nsDOMClassInfo:

</p>
<p>

  <code>typedef nsDOMClassInfo nsDOMGenericSH;</code>.

</p>
<p>

  Another example is nsWindowSH, which inherits from nsEventReceiverSH, thus
  inheriting from nsDOMClassInfo.

</p>
<p>

  Each DOM class is mapped to its helper class during the
  initialization of the sClassInfoData array. 

</p>
<p>

  Each helper class has a public doCreate member function that is called by 
  GetClassInfoInstance (see also Section 1.F) to create a new instance of the 
  class if needed. Remember that the doCreate member function is called through 
  a pointer to a function named mConstructorFptr, a member of the 
  nsDOMClassInfoData struct.
  An instance of a helper class is created the first time XPConnect needs 
  access to the flattened set of interfaces of an object. The instance is 
  then cached for further use.

</p>
<p>

  Most of the helper classes implement one or more nsIXPCScriptable methods.
  Those methods are used by XPConnect when we require something from JavaScript
  that was not defined in IDL. For example, GetProperty() is used when 
  retrieving an attribute that was not defined in IDL, and NewResolve() is used
  when resolving for the first time an attribute or method that was not
  previously resolved. Please see the 
  <a href="http://lxr.mozilla.org/seamonkey/source/js/src/xpconnect/idl/nsIXPCScriptable.idl">
  nsIXPCScriptable interface</a> for more information.

</p>
</div>
 
<div id="chapteroned">
  <h2>
  <a name="oned">1.D. The nsDOMClassInfo class</a>
  </h2>

<p>

  The heart of Class Info is the nsDOMClassInfo class, defined in
  <a href="http://lxr.mozilla.org/seamonkey/source/dom/src/base/nsDOMClassInfo.h">nsDOMClassInfo.h</a>.
  It implements two interfaces besides nsISupports: 
  <a href="http://lxr.mozilla.org/seamonkey/source/js/src/xpconnect/idl/nsIXPCScriptable.idl">nsIXPCScriptable</a> 
  and <a href="http://lxr.mozilla.org/seamonkey/source/xpcom/components/nsIClassInfo.idl">nsIClassInfo</a>.

</p>
<p>

  We already know what nsIXPCScriptable is used for (see the previous Section).

</p>
<p>

  nsIClassInfo is an XPCOM interface, very well described by Mike Shaver in 
  <a href="http://lxr.mozilla.org/seamonkey/source/xpcom/doc/nsIClassInfo-overview.html">this overview of nsIClassInfo</a>.
  Basically it contains convenient methods to find out about the interfaces
  an object promises to support. In our case, this list of interfaces will be 
  populated by "Class Info". See also Section 1.E on the Init() function and
  Section 1.B on interface flattening.

</p>
<p>

  We saw in Section 1.C that nsDOMClassInfo is the base class for all the
  helper classes. Let's see what it's made of. 
  Let's begin with the public interface.

</p>
<ul>
  <li>Constructor: It is called for each created helper class through the member
  initialization list. It simply initializes the mID data member with the aID
  argument.</li>
  <li>The nsIXPCScriptable, nsISupports, and nsIClassInfo member functions,
  declared with NS_DECL_X macros.</li>
  <li><code>static nsIClassInfo* GetClassInfoInstance(nsDOMClassInfoID aID)</code>:<br>
  this helper method returns a non-refcounted nsIClassInfo pointer to an
  instance of the helper class corresponding to the ID passed in. The
  implementation is detailed in Section 1.F.</li>
  <li><code>static nsIClassInfo* GetClassInfoInstance(nsDOMClassInfoData* aData);</code>:<br>
  this helper method returns a non-refcounted nsIClassInfo pointer to an
  instance of the helper class corresponding to the Data passed in. The
  implementation is detailed in Section 1.F.</li>
  <li><code>static void ShutDown()</code>:<br>
  Releases the interface pointers.</li>
  <li><code>static nsIClassInfo* doCreate(nsDOMClassInfoData* aData)</code>:<br>
  Inline function that returns a nsIClassInfo pointer to a new instance of the
  nsDOMClassInfo class.</li>
  <li><code>static nsresult WrapNative(...)</code>: 
  XPConnect fu, not our problem.</li>
  <li><code>static nsresult ThrowJSException(JSContext *cx, nsresult aResult);</code>:<br>
  help me!</li>
  <li><code>static nsresult InitDOMJSClass(JSContext *cx, JSObject *obj);</code>:<br>
  help me!</li>
  <li><code>static JSClass sDOMJSClass;</code>:<br>
  help me!</li>
</ul>
<p>

  Protected section:

</p>
<ul>
  <li><code>const nsDOMClassInfoData* mData;</code>: help me!</li>
  <li><code>static nsresult Init()</code>: Called only once, it is used to 
  initialize the remaining members of the nsDOMClassInfoData structure, as 
  mentioned above. Once called, Init() sets sIsInitialized to true, to remember 
  that the initialization has been performed. The implementation is described 
  in Section 1.E.</li>
  <li><code>static nsresult RegisterClassName(PRInt32 aDOMClassInfoID)</code>: 
  help me!</li>
  <li><code>static nsresult RegisterClassProtos(PRInt32 aDOMClassInfoID)</code>: 
  help me!</li>
  <li><code>static nsresult RegisterExternalClasses();</code>: help me!</li>
  <li><code>nsresult ResolveConstructor(JSContext *cx, JSObject *obj, JSObject **objp);</code>:
  help me!</li>
  <li><code>static PRInt32 GetArrayIndexFromId(JSContext *cx, jsval id, PRBool *aIsNumber =<br>
   nsnull)</code>:<br>
  If the JS value is an integer, then *aIsNumber is true, and the integer is
  returned. Else, *aIsNumber is false and -1 is returned.</li>
  <li><code>static inline PRBool IsReadonlyReplaceable(jsval id) { ... }</code>:
  help me!</li>
  <li><code>static inline PRBool IsWritableReplaceable(jsval id) { ... }</code>:
  help me!</li>
  <li><code>nsresult doCheckPropertyAccess(...)</code>:
  help me! (bug 90757)</li>
  <li><code>static JSClass sDOMConstructorProtoClass</code>: 
  XPConnect fu to expose the DOM objects constructors to JavaScript.</li>
  <li><code>static JSFunctionSpec sDOMJSClass_methods[];</code>:
  help me! (bug 91557)</li>
  <li><code>static nsIXPConnect *sXPConnect</code>: 
  Used to call nsIXPConnect methods that we need. Initialized in Init().</li>
  <li><code>static nsIScriptSecurityManager *sSecMan</code>: Used by the DOM 
  security engine. Initialized in Init().</li>
  <li><code>static nsresult DefineStaticJSVals(JSContext *cx);</code>:
  Used to define all the static JSString data members of nsDOMClassInfo.</li>
  <li><code>static PRBool sIsInitialized</code>:<br> Keeps track of wether Class 
  Info was already initialized, because Init() shouldn't be called twice.</li>
  <li><code>static jsval *sX_id</code>: strings used in the global resolve 
  methods for comparison with the passed in arguments. They represent special 
  words for the DOM. Initialized by DefineStaticJSVals().</li>
  <li><code>static const JSClass *sObjectClass</code>: help me!</li>
  <li><code>static PRBool sDoSecurityCheckInAddProperty;</code>: help me!</li>
</ul>

</div>

<div id="chapteronee">
  <h2>
  <a name="onee">1.E. nsDOMClassInfo::Init()</a>
  </h2>

<p>

  This method is to be called only once. Its purpose is, well, to initialize...
  It does a lot of different things: Fill the blanks in the sClassInfoData array,
  initialize the sXPConnect and sSecMan data members, create a new JavaScript
  Context, define the JSString data members, and register class names and class
  prototypes. Finally it sets sIsInitialized to true. The actions that concern
  the DOM are described below.

</p>
<p>

  First, the call to CallGetService() initializes sXPConnect. Then the Script
  Security Manager (sSecMan) is initialized. GetSafeJSContext() grabs us a cool
  JS context to run our JavaScript code in. The part about ComponentRegistrar is
  designed to allow external modules (in this case XPath) to be included in
  DOMClassInfo and as such benefit from the JavaScript benefits it provides.
  After that, we fill the blanks in the sClassInfoData array.

<p>

  If you remember the discussion in the introduction to Class Info, there is
  the main array, sClassInfoData, filled with objects of type 
  nsDOMClassInfoData. However when the array is created, three data members of
  the structure are left as null pointers: mCachedClassInfo,
  mProtoChainInterface, and mInterfaces. Init() uses a set of macros to fill the
  blanks: the DOM_CLASSINFO_MAP family. Each DOM class needs to use these macros,
  otherwise bad things <em>will</em> happen. I will use the example of the
  Window class to illustrate the use of the macros. Here is the relevant piece
  of code.

</p>

<pre class="code">
DOM_CLASSINFO_MAP_BEGIN(Window, nsIDOMWindow)
  DOM_CLASSINFO_MAP_ENTRY(nsIDOMWindow)
  ...
  DOM_CLASSINFO_MAP_ENTRY(nsIDOMAbstractView)
DOM_CLASSINFO_MAP_END
</pre>

<p>

  DOM_CLASSINFO_MAP_BEGIN(_class, _interface) maps to
  _DOM_CLASSINFO_MAP_BEGIN(_class, &amp;NS_GET_IID(_interface), PR_TRUE). NS_GET_IID is a
  macro that expands to the IID of the interface passed in. We pass the
  address of this nsIID object to the second macro.

</p>

<pre class="code">
#define _DOM_CLASSINFO_MAP_BEGIN(_class, _ifptr, _has_class_if)
{
  nsDOMClassInfoData &amp;d = sClassInfoData[eDOMClassInfo_##_class##_id];
  d.mProtoChainInterface = _ifptr;
  d.mHasClassInterface = _has_class_if;
  static const nsIID *interface_list[] = {
</pre>

<p>

  In this macro, |d| is a reference to the entry of the sClassInfoData array
  that corresponds to the class passed as an argument to the macro. The
  mProtoChainInterface member pointer is initialized to the address of the IID
  of the interface passed as an argument to DOM_CLASSINFO_MAP_BEGIN. 
  A static array of pointers to objects of type nsIID is then declared. It is
  initialized explicitly with the DOM_CLASSINFO_MAP_ENTRY macro (see below).

</p>
<p>

  There are two other similar macros :

</p>

<pre class="code">
#define DOM_CLASSINFO_MAP_BEGIN_NO_PRIMARY_INTERFACE(_class)
  _DOM_CLASSINFO_MAP_BEGIN(_class, nsnull, PR_TRUE)
</pre>

<p>

  This macro is used if the DOM class (for example XMLHTTPRequest)
  does not have any interface, yet you want the XMLHTTPRequest object
  to be available from JavaScript.

</p>

<pre class="code">
#define DOM_CLASSINFO_MAP_BEGIN_NO_CLASS_IF(_class, _interface)
  _DOM_CLASSINFO_MAP_BEGIN(_class, &amp;NS_GET_IID(_interface), PR_FALSE)
</pre>

<p>

  This macro should be used for DOM classes that have no "leaf" interface.
  For example, there is no HTMLSpanElement in the W3C DOM specification.
  Therefore, the first interface in the prototype chain for the span element
  is HTMLElement. However we do want to be able to access HTMLSpanElement
  to modify it. This macro allows you to do that. See
  <a href="http://bugzilla.mozilla.org/show_bug.cgi?id=92071">bug 92071</a>
  for more information. Let's now see how to specify the interfaces available
  from JavaScript for a particular DOM class.

</p>

<pre class="code">
#define DOM_CLASSINFO_MAP_ENTRY(_if)
    &amp;NS_GET_IID(_if),
</pre>

<p>

  The array of pointers interface_list is filled with the addresses of the IID's
  of all the interfaces passed as arguments to the macro. In our Window example,
  the interfaces are nsIDOMWindow, nsIDOMJSWindow, nsIDOMWindowInternal, 
  nsIDOMEventReciever, nsIDOMEventTarget, nsIDOMViewCSS, and nsIDOMAbstractView.
  Please see Section 1.B on interface flattening for an explanation of the use
  of these interfaces. The initialization for a class is finished by the
  DOM_CLASSINFO_MAP_END macro.

</p>

<pre class="code">
#define DOM_CLASSINFO_MAP_END
    nsnull
  };
  d.mInterfaces = interface_list;
}
</pre>

<p>

  The interface_list array is terminated by a null pointer. The line
  d.mInterfaces = interface_list assigns to mInterfaces the address of the first
  element of the interface_list array, which is itself a pointer. mInterfaces
  is thus correctly a pointer to a pointer to an object of type nsIID.

</p>
<p>

  To define the jsvals, Init() simply calls DefineStaticJSVals().
  To register the class names and class protos, Init() simply calls
  RegisterClassProtos and RegisterClassNames. This process might be
  described in a later document. Finally, sIsInitialized is set to
  true. Init() returns NS_OK if everything went fine.

</p>
</div>

<div id="chapteronef">
  <h2>
  <a name="onef">1.F. nsDOMClassInfo::GetClassInfoInstance()</a>
  </h2>

<p>

  There are two versions of this function. The first one takes an ID as
  argument, the second takes a Data struct as argument.
  This function is very important so let's take a closer look at it. Here
  is the function definition.

</p>

<pre class="code">
nsIClassInfo* nsDOMClassInfo::GetClassInfoInstance(nsDOMClassInfoID aID)
{
  if(!sIsInitialized) {
    nsresult rv = Init();
  }

  if(!sClassInfoData[aID].mCachedClassInfo) {
    nsDOMClassInfoData &amp;data = sClassInfoData[aID];
    data.mCachedClassInfo = data.u.mConstructorFptr(&amp;data);
    NS_ADDREF(data.mCachedClassInfo);
  }

  return sClassInfoData[aID].mCachedClassInfo;
}
</pre>

<p>

  Here is the short explanation:<br>
  This method returns the mCachedClassInfo member of the nsDOMClassInfoData
  structure that corresponds to aID in the sClassInfoData array, if it exists,
  i.e. if this method has been called before. If it is called for the first
  time however, mCachedClassInfo is still a null pointer, and the function
  will create a new instance of the relevant helper class, and cache it in the
  mCachedClassInfo pointer, then return it.

</p>
<p>

  And for those interested, here the longer explanation.

</p>
<p>

  The first time GetClassInfoInstance() is called, passing in an aID, 
  mCachedClassInfo for that class will still be null. 
  The body of the "if" clause is thus executed.
  We initialize "data" to be a reference to the nsDOMClassInfoData object that
  corresponds to the DOM class we want to "help".
  On the next line, there is a call to data.mConstructorFptr(aID), which, if
  you remember the introduction to Class Info, maps to the doCreate static 
  member function of the relevant helper class. doCreate creates a new instance
  of the helper class, and returns a pointer to the nsIClassInfo interface, 
  which is then assigned into mCachedClassInfo. mCachedClassInfo is AddRef'ed
  to keep it from being destroyed without our permission. Finally it is
  returned.
  

</p>
<p>

  On subsequent calls to this function with the same aID passed in,
  mCachedClassInfo will still be there, and thus the creation of a new helper
  class will not be necessary.

</p>
<p>

  "Where is GetClassInfoInstance used and why should I use it", would be an
  excellent question for now. The short answer is,
  "to implement the QueryInterface for nsIClassInfo. Indeed, a QueryInterface to
  nsIClassInfo cannot be implemented the same way as other interfaces. If you
  don't like macros, you can see the full QueryInterface implementation in 
  <a href="http://lxr.mozilla.org/seamonkey/source/content/xml/content/src/nsXMLElement.cpp">nsXMLElement.cpp</a>.
  Two other GetClassInfoInstance member functions are defined in Mozilla, as 
  member of class nsContentUtils and class nsDOMSOFactory. Both of these methods 
  end up calling nsDOMClassInfo::GetClassInfoInstance so there is no real point 
  in documenting them further. GetClassInfoInstance is used in the 
  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO macro, which is used to implement 
  QueryInterface for the nsIClassInfo interface in 
  <a href="http://lxr.mozilla.org/seamonkey/ident?i=NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO">most of the DOM classes</a>,
  and in the NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO macro, which is used to
  implement QueryInterface for the nsIClassInfo interface in most
  <a href="http://lxr.mozilla.org/seamonkey/ident?i=NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO">global object properties</a>.
  
</p>
<p>

  I think that's all there is to say about this function. If you think of
  something else don't hesitate to contact me, as usual.

</p>
</div>

<div id="chapteroneg">
  <h2>
  <a name="oneg">1.G. nsWindowSH::GlobalResolve()</a>
  </h2>

<p>

  This Section will describe in detail the absolutely horrific GlobalResolve()
  member function of the nsWindowSH helper, as an example of those functions.
  This is not for the faint of heart, and is not absolutely necessary, so you
  might want to skip this Section if you don't have too much time (and I suppose you don't).

</p>
</div>

<div id="chapteroneh">
  <h2>
  <a name="oneh">1.H. User's guide to Class Info</a>
  </h2>

<div class="important">
Warning: this document has not yet been reviewed by the DOM gurus, it might 
contain some errors. Specifically, due to some changes that happened around,
April 2002, some things that were not possible before are now possible. I will
try to update this guide as soon as possible. Please send any comment to <a
href="mailto:fguisset@softhome.net">Fabian Guisset</a>.
</div>

<div class="section">
<h2>When should DOMClassInfo be used</h2>
<ul>
  <li>To add a new interface to an existing DOM object</li>
  <li>To expose a new DOM object to JavaScript</li>
  <li>To add a new JS external constructor, like "new Image()"</li>
  <li>To bypass the default behavior of XPConnect</li>
  <li>To implement a "replaceable" property</li>
  <li>To mess with the prototypes of DOM objects</li>
</ul>
<p>

Example of functionality implemented using DOMClassInfo:

</p>
<ul>
  <li>Constructors of DOM objects in the global scope (e.g. Node)</li>
  <li>Setting up custom prototypes for those DOM objects</li>
  <li>new Image(), new Option()</li>
  <li>window.history[index]</li>
  <li>document.&lt;formName&gt;</li>
</ul>
</div>

<ol class="toc">
  <li><a href="#1">How to add a new interface to an existing DOM object</a></li>
  <li><a href="#2">How to expose a new DOM object to JavaScript</a></li>
  <li><a href="#3">How to override the default behavior of XPConnect on DOM
objects</a></li>
  <li><a href="#4">How to make a property "replaceable" (To be written)</a></li>
  <li><a href="#5">Examples (To be written)</a></li>
</ol>

<div class="section">
<h3><a name="1">1. How to add a new interface to an existing DOM object</a></h3>

<div class="example">
<p>
  For this Section, we will use the simple example of the DOMImplementation DOM
  object. This is a real-world case that was used to solve bug 33871 (the patch
  is not checked in yet, as of writing this document). The problem is the
  following: We have to add a new HTMLDOMImplementation interface to the
  DOMImplementation DOM object. The DOMImplementation object is used when one
  does, in JS, <code>document.implementation</code>. This object already
  implements the DOMImplementation interface, but DOM2 HTML says it should
  also implement the HTMLDOMImplementation interface, so here we go. The C++
  implementation is in <span class="filename">nsDocument.cpp</span>. The first
  step is of course to do the C++ implementation of the interface, which is
  described in the
  <a href="../xpcom-intro">intro to XPCOM</a> document.
</p>
<p>
  Let's assume nsDOMImplementation now implements the
nsIDOMHTMLDOMImplementation
  interface (look in bug 33871 if you want to know how to do that). We want to
  expose this interface to JavaScript (otherwise only XPCOM callers will be
  able to access this interface). To do that, we have to add it to the
  DOMClassInfo of the DOMImplementation DOM object.
</p>
</div>

<h4>Benefits</h4>
<ul>
  <li>The HTMLDOMImplementation interface will be available from
JavaScript.</li>
  <li>Methods defined on the HTMLDOMImplementation interface will be accessible
      on the <code>document.implementation</code> object (the main goal) using
      the automatic interface flattening brought to you by nsDOMClassInfo and
      XPConnect.</li>
  <li><code>document.implementation instanceof HTMLDOMImplementation</code>
      will work (returns true)</li>
  <li><code>HTMLDOMImplementation.prototype</code> will be accessible and
      modifyable</li>
  <li>Lots of other stuff you probably don't care about</li>
</ul>

<h4>What there is to do</h4>
<ol>
  <li>Include the new interface definition in nsDOMClassInfo.cpp:<br>
      <code>#include "nsIDOMHTMLDOMImplementation.h"</code>.<br>
      Put it where you think it fits the most.</li>
  <li>Find the code where all the interfaces implemented by the relevant DOM
      object are implemented. This is in the nsDOMClassInfo::Init() method.</li>
  <li>For DOMImplementation, this is around line 1220 (at the time of writing
      this document):<br>
      <code>1224 DOM_CLASSINFO_MAP_BEGIN(DOMImplementation,
      nsIDOMDOMImplementation)</code><br>
      The next line specifies that the DOMImplementation object implements the
     nsIDOMDOMImplementation interface.</li>
  <li>Add the new interface to the DOMClassInfo definition. For us, it is:<br>
      <code>1225
DOM_CLASSINFO_MAP_ENTRY(nsIDOMHTMLDOMImplementation)</code></li>
  <li>Add the new interface to the makefiles, manifests, etc.</li>
  <li>Recompile.</li>
  <li>Nuke components.reg if you build optimized.</li>
  <li>Wonder at the beauty of DOMClassInfo.</li>
</ol>

</div>

<div class="section">
<h3><a name="2">2. How to expose a new DOM object to JavaScript</a></h3>

<p>
  Let's now go a step further. Not only do we want to add a new interface to
  an object, but we also want to expose a completely new object to JavaScript.
  DOMClassInfo does almost everything for you, from prototypes to implementing
  a default ToString() method on your object.
</p>

<div class="example">
  We will again take the example of the DOMImplementation object. It is
  accessible using <code>document.implementation</code>. It is defined in the
  W3C DOM Level 1 Core spec. The requirements include that the global
  constructor <code>DOMImplementation</code> be accessible, that the ToString()
  method called on an instance of a DOMImplementation return
  "DOMImplementation", and that it implements the following methods:
  hasFeature() (DOM1), createDocumentType() and createDocument() (DOM2).
</div>

<h4>What there is to do</h4>
<ol>
  <li>Implement your object in C++. This is not in the scope of this document.
      The best thing you can do is probably to copy existing code. A DOM object
      is a simple XPCOM object with DOMClassInfo. In our example, the
      implementation class is nsDOMImplementation (in nsDocument.cpp). It
      implements the nsIDOMDOMImplementation interface (which contains the
      three methods mentionned above).</li>
  <li>Modify the QueryInterface implementation of your XPCOM object to include
      DOMClassInfo data. Add the following line at the end of the
QueryInterface       implementation:<br>
      <code>NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(dom_object_name)</code><br>
      For the DOMImplementation object, the line would be:<br>
     
<code>NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(DOMImplementation)</code><br>
      What does it do? It's the QueryInterface implementation for the
      nsIClassInfo interface, which is requested internally by XPConnect.
      Basically it will create an instance of the scriptable helper class for
      this DOM object. More on this subject in the rest of this document.</li>
  <li>Add the DOM object DOMClassInfo in the sClassInfoData array
      (nsDOMClassInfo.cpp):<br>
<pre class="code">
NS_DEFINE_CLASSINFO_DATA(dom_object_name, scriptable_helper_class,
                         scriptable_flags)
</pre>
      For the DOMImplementation object, the lines would be:<br>
<pre class="code">
NS_DEFINE_CLASSINFO_DATA(DOMImplementation, nsDOMGenericSH,
                         DOM_DEFAULT_SCRIPTABLE_FLAGS)
</pre>
      The place where you have to add the DOMClassInfo in that array should be
      obvious. If it is not, ask
      <a href="mailto:jst@netscape.com">Johnny Stenback</a>.</li>
  <li>Add the DOM object DOMClassInfo in the nsDOMClassInfo::Init() method    
       (nsDOMClassInfo.cpp):
<pre class="programlisting">
DOM_CLASSINFO_MAP_BEGIN(dom_object_name, dom_object_main_interface)
  DOM_CLASSINFO_MAP_ENTRY(interface1)
  DOM_CLASSINFO_MAP_ENTRY(interface2)
  ...
DOM_CLASSINFO_MAP_END
</pre>
      For the DOMImplementation object, the lines would be:<br>
<pre class="programlisting">
DOM_CLASSINFO_MAP_BEGIN(DOMImplementation, nsIDOMDOMImplementation)
  DOM_CLASSINFO_MAP_ENTRY(nsIDOMDOMImplementation)
DOM_CLASSINFO_MAP_END
</pre>
      The <code>interface1</code>, <code>interface2</code>, ... arguments are
      the name of the interfaces implemented by the DOM object AND exposed to
      JavaScript. The internal interfaces should NOT be a part of this
list.</li>
  <li>#include the relevant files to make it build, tweak the makefiles, etc.
      Make sure it builds on all platforms! :-P</li>
  <li>If you used an already existing scriptable helper class, then all you
      need to do is build, nuke components.reg (if you build optimized) and run.
      Everything should work well.</li>
  <li>If you want to use a new scriptable helper class, you will have to
      implement it as well.</li>
</ol>

</div>

<div class="section">
<h3><a name="3">3. How to override the default behavior of XPConnect on DOM objects</a></h3>

<p>
  XPConnect implements default behaviors for XPCOM objects in general, and for
  DOM objects in particular. DOMClassInfo allows the implementor to override
  this default behavior using the nsIXPCScriptable interface. Before we begin,
  please take a look at the nsIXPCScriptable.idl file. It defines a set of
  constants, called the "scriptable flags", and a set of functions, like
  NewResolve(), SetProperty(), ... Each flag corresponds to one function. For
  example, nsIXPCScriptable::WANT_NEWRESOLVE means that we want to implement
  the NewResolve() function. The important thing to grasp is that each function
  corresponds to an event in the life of the DOM object. For example, the
  SetProperty() function is called automatically by XPConnect when, in JS,
  the client tries to set a property on this DOM object. This is how we can
  override the default "set this property on this object" XPConnect behavior.
  For more information about each nsIXPCScriptable function, please see the
  nsIXPCScriptable documentation.
</p>

<div class="example">
  To illustrate the use of nsIXPCScriptable and scriptable helper functions, we
  will take the example of the "location" property of the window object.
  <code>window.location</code> is a DOM object of type "Location". However a
  common technique is to do <code>window.location = "http://mozilla.org"</code>
  instead of the correct
  <code>window.location.href = "http://mozilla.org"</code>. So, we have to
  override the default behavior of "setting the location property on the window
  object". The default behavior would be that XPConnect expects a nsIDOMLocation
  object. However it would be passed a JS string. A bad conversion exception
  would be thrown.
</div>

<div class="para">
  Before we start looking at the implementation of the nsIXPCScriptable
  interface, the implementor needs the following information:

<ul>
  <li>Which DOM object is concerned</li>
  <li>What action does he want to override</li>
  <li>What should happen</li>
</ul>

  For our example, it is the window object. The action is setting a property.
  What should happen is that setting .location should set .location.href.
  With that information in hand, we can start coding.
</div>

<h4>What there is to do</h4>
<ol>
  <li>Locate the DOM object ClassInfo data in the sClassInfoData array. In our
      example, it is the Window object. The three parameters passed to the
      macro, as described in the previous Section, are the DOM object name, the
      scriptable helper class, and the scriptable flags.</li>
  <li>The scriptable flags tell you which nsIXPCScriptable interfaces are
      implemented by this DOM object. If the flag you need is already there,
      then go on to the next step. Else, add it to the flag list.</li>
  <li>Remember the name of the scriptable helper class for this object. For
      most objects, it is the nsDOMGenericSH class, which is just a typedef
      for the nsDOMClassInfo class. If your DOM object does not require any
      special-casing, then the scriptable helper for your object should be
      nsDOMGenericSH. If you need special-casing, scroll to the
      implementation of the helper class.<br>
      In our example, it's the nsWindowSH class.</li>
  <li>If the helper class already implements the nsIXPCScriptable function you
      need, go on to the next step. Else, implement this new method, using the
      arguments described in the nsIXPCScriptable interface.</li>
  <li>Now comes the interesting part. It is unfortunately impossible to describe
      all the uses of the scriptable helpers, you will have to use your coding
      skills and/or copy existing code. We will however describe the
      implementation of our example, the window.location property.</li>
</ol>

<h4>The window.location implementation</h4>
<div class="para">
  Overriding the setter of a property requires two scriptable flags:
  WANT_NEWRESOLVE and WANT_SETPROPERTY. NewResolve() will define the property
  on the object using the JS API, the second one will map .location to
  .location.href. As of writing this document, the code in
  nsWindowSH::NewResolve() looks like this: (nsDOMClassInfo.cpp)

<pre class="programlisting">
3553     if (flags &amp; JSRESOLVE_ASSIGNING) {
// Only define the property if we are setting it.
3554       if (str == sLocation_id) {
// Setting the location property.
3555         nsCOMPtr&lt;nsIDOMWindowInternal&gt;
window(do_QueryInterface(native));
3556         NS_ENSURE_TRUE(window, NS_ERROR_UNEXPECTED);
3557 
3558         nsCOMPtr&lt;nsIDOMLocation&gt; location;
3559         rv = window-&gt;GetLocation(getter_AddRefs(location));
3560         NS_ENSURE_SUCCESS(rv, rv);
// Use the DOM to get the Location object of the window object.
3561 
3562         jsval v;
3563 
3564         rv = WrapNative(cx, obj, location, NS_GET_IID(nsIDOMLocation),
&amp;v);
// This XPConnect method creates a wrapper for the Location object on the //
Window object.
3565         NS_ENSURE_SUCCESS(rv, rv);
3566 
3567         if (!::JS_DefineUCProperty(cx, obj, ::JS_GetStringChars(str),
3568                                    ::JS_GetStringLength(str), v, nsnull,
3569                                    nsnull, 0)) {
3570           return NS_ERROR_FAILURE;
3571         }
// This JS API call defines the "location" property on the window object, its
// value being the XPConnect wrapper for the Location object.
3572
3573         *objp = obj;
3574 
3575         return NS_OK;
3576       }
</pre>

  This is the first step. It is required to have the getter for .location work
  as well, but that's another story. The second step is to map .location to
  .location.href in nsWindowSH::SetProperty()

<pre class="programlisting">
2894     if (str == sLocation_id) {
// Setting the location property
2895       JSString *val = ::JS_ValueToString(cx, *vp);
2896       NS_ENSURE_TRUE(val, NS_ERROR_UNEXPECTED);
// Convert the value assigned to location (i.e. the url) to a JSString.
2897 
2898       nsCOMPtr&lt;nsISupports&gt; native;
2899       wrapper-&gt;GetNative(getter_AddRefs(native));
// Get the pointer to the content object that was wrapped.
2900 
2901       nsCOMPtr&lt;nsIDOMWindowInternal&gt;
window(do_QueryInterface(native));
2902       NS_ENSURE_TRUE(window, NS_ERROR_UNEXPECTED);
// QueryInterface to have a nsIDOMWindowInternal pointer to call
// GetLocation() on it.
2903 
2904       nsCOMPtr&lt;nsIDOMLocation&gt; location;
2905       nsresult rv = window->GetLocation(getter_AddRefs(location));
2906       NS_ENSURE_SUCCESS(rv, rv);
// Get the Location object for this window.
2907 
2908       nsDependentString href(NS_REINTERPRET_CAST(PRUnichar *,
2909                                                  ::JS_GetStringChars(val)),
2910                              ::JS_GetStringLength(val));
// Convert the JSString to a string that can be passed to SetHref()
2911 
2912       rv = location->SetHref(href);
2913       NS_ENSURE_SUCCESS(rv, rv);
// After this, we effectively mapped .location to .location.href
2914 
2915       return WrapNative(cx, obj, location, NS_GET_IID(nsIDOMLocation), vp);
// Create a wrapper for the location object with vp (the url) as value.
2916     }
</pre>

It's that simple. And the possibilities are endless.
</div>
</div>

</div>

<div id="resources">
<p>
Resources of interest:
<br>
<a href="../../../scriptable/xpidl/">The XPIDL reference</a>
<br>
<a href="classes/">Mapping DOM Objects to their C++ class</a>
<br>
<a href="../../modunote.htm">Modularization techniques</a>
</p>
</div>

<div id="chapteronei">
  <h2>
  <a name="onei">1.I. Scriptable Helper flags</a>
  </h2>

<p>

  This chapter has not been written yet. If you want to help please
  contact me!

</p>
</div>

<div id="chapteronej">
  <h2>
  <a name="onej">1.J. Security features implementation</a>
  </h2>

<p>

  This chapter has not been written yet. If you want to help please
  contact me!

</p>
</div>




<hr class="hide">
</div>
</div>
<div id="footer">
<ul>
<li><a href="../../../sitemap.html">Site Map</a></li>
<li><a href="../../../security/">Security Updates</a></li>
<li><a href="../../../contact/">Contact Us</a></li>
<li><a href="../../../foundation/donate.html">Donate</a></li>
</ul>
<p class="copyright">
Portions of this content are &copy; 1998&#8211;2009 by individual mozilla.org
contributors; content available under a Creative Commons license | <a
href="http://www.mozilla.org/foundation/licensing/website-content.html">Details</a>.</p>
<p>
<span>Last modified September 27,  2007</span>
<span><a href="http://bonsai-www.mozilla.org/cvslog.cgi?file=mozilla-org/html/docs/dom/mozilla/hacking.html&amp;rev=&amp;root=/www/">Document History</a></span>
</p>
</div>
</div>
</body>
</html>
