<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<link rel="top" title="Home" href="http://www.mozilla.org/">
<link rel="stylesheet" type="text/css" href="../css/print.css"  media="print">
<link rel="stylesheet" type="text/css" href="../css/base/content.css"  media="all">
<link rel="stylesheet" type="text/css" href="../css/cavendish/content.css" title="Cavendish" media="screen">
<link rel="stylesheet" type="text/css" href="../css/base/template.css"  media="screen">
<link rel="stylesheet" type="text/css" href="../css/cavendish/template.css" title="Cavendish" media="screen">
<link rel="icon" href="../images/mozilla-16.png" type="image/png">


<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Language" content="en">
<meta http-equiv="Content-Style-Type" content="text/css">

	<title>How the Editor Works</title>

<link rel="up" href="./" title="Editor project page">

<script src="../__utm.js" type="text/javascript"></script>
</head>
<body id="www-mozilla-org" class="deepLevel">
<div id="container">
<p class="important">You are currently viewing a snapshot of www.mozilla.org taken on April 21, 2008. Most of this content is
highly out of date (some pages haven't been updated since the project began in 1998) and exists for historical purposes only.  If
there are any pages on this archive site that you think should be added back to www.mozilla.org, please <a
href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Websites&component=www.mozilla.org">file a bug</a>.</p>
<p class="skipLink"><a href="#mainContent" accesskey="2">Skip to main content</a></p>
<div id="header">
<h1><a href="/" title="Return to home page" accesskey="1">Mozilla</a></h1>
<ul>
<li id="menu_aboutus"><a href="../about/" title="Getting the most out of your online experience">About</a></li>
<li id="menu_developers"><a href="../developer/" title="Using Mozilla's products for your own applications">Developers</a></li>
<li id="menu_store"><a href="http://store.mozilla.org/?r=mozorg1" title="Shop for Mozilla products on CD and other merchandise">Store</a></li>
<li id="menu_support"><a href="../support/" title="Installation, trouble-shooting, and the knowledge base">Support</a></li>
<li id="menu_products"><a href="../products/" title="All software Mozilla currently offers">Products</a></li>
</ul>
<form id="searchbox_002443141534113389537:ysdmevkkknw" action="http://www.google.com/cse" title="mozilla.org Search">
<div>
<label for="q" title="Search mozilla.org's sites">search mozilla:</label>
<input type="hidden" name="cx" value="002443141534113389537:ysdmevkkknw">
<input type="hidden" name="cof" value="FORID:0">
<input type="text" id="q" name="q" accesskey="s" size="30">
<input type="submit" id="submit" value="Go">
</div>
</form>
</div>
<hr class="hide">
<div id="mBody">
<div id="side">

<ul id="nav">
<li><a title="Roadmap" href="../roadmap.html"><strong> Roadmap</strong></a></li>
<li><a title="Projects" href="../projects/"><strong> Projects</strong></a></li>
<li><a title="For developers" href="../developer/"><strong> Coding</strong></a>
<ul>
<li><a title="Module Owners" href="../owners.html"> Module Owners</a></li>
<li><a title="Hacking" href="../hacking/"> Hacking</a></li>
<li><a title="Get the Source" href="http://developer.mozilla.org/en/docs/Download_Mozilla_Source_Code"> Get the Source</a></li>
<li><a title="Building Mozilla" href="http://developer.mozilla.org/en/docs/Build_Documentation"> Build It</a></li>
</ul>
</li>
<li><a title="Testing" href="../quality/"><strong> Testing</strong></a>
<ul>
<li><a title="Downloads of mozilla.org software releases" href="../download.html"> Releases</a></li>
<li><a title="Latest mozilla builds for testers" href="../developer/#builds"> Nightly Builds</a></li>
<li><a title="For testers to report bugs" href="https://bugzilla.mozilla.org/"> Report A Problem</a></li>
</ul>
</li>
<li><a title="Tools for mozilla developers" href="../tools.html"><strong> Tools</strong></a>
<ul>
<li><a title="Bug tracking system for mozilla testers." href="https://bugzilla.mozilla.org/"> Bugzilla</a></li>
<li><a title="Latest status of mozilla builds" href="http://tinderbox.mozilla.org/showbuilds.cgi?tree=Firefox"> Tinderbox</a></li>
<li><a title="Latest checkins" href="http://bonsai.mozilla.org/cvsqueryform.cgi"> Bonsai</a></li>
<li><a title="Source cross reference" href="http://lxr.mozilla.org/seamonkey/"> LXR</a></li>
</ul>
</li>
<li><a title="Frequently Asked Questions." href="../faq.html"><strong> FAQs</strong></a></li>
</ul>

</div>
<hr class="hide">
<div id="mainContent">







<p class="crumbs"><em>You are here:</em> <a href="./">Editor project page</a> &gt; <strong>How the Editor Works</strong></p>

<h1><a name="How_the_Editor_Works">How the Editor Works</a></h1>

<h2>In this document</h2>

<ul class="toc">
	<li><a href="#The_high-level_picture">The high-level picture</a></li>
	<li><a href="#Editor_instantiation_in_a_XUL_window">Editor instantiation in a XUL window</a></li>
	<li><a href="#Editor_teardown">Editor teardown</a></li>
	<li><a href="#Editor_event_handling">Editor event handling</a>
	<ul>
	    <li><a href="#The_path_of_a_key_press">The path of a key press</a></li>
	</ul>
        </li>
</ul>

<h2><a name="Introduction">Introduction</a></h2>

<p>
This document describes how the editor is instantiated, and handles events, for
the Composer window. This is very similar to its use in the mail compose window,
and will relate to most embedding applications. For details on how the editor
is created for text widgets, see the <a href="editor-textwidgets.html">text widgets doc.</a>
</p>

<h2><a name="The_high-level_picture">The high-level picture</a></h2>

<p>
A high-level picture of some of the main parts of the editing system are shown in
Figure 1. This picture shows the interactions between the UI (written in XUL and JavaScript),
the nsEditorShell (which interfaces between the UI and the editor core), and the
editor proper, with typing rules which modify behavior. The editor then acts upon 
the document being edited. (Note that the figure leaves out some important details,
like the fact that all editing operations occur via undoable transactions.)
</p>

<p style="text-align: center;">
<img src="images/editor_arch.gif" width="380" height="118" alt=""><br>
<i>Figure 1: high-level relationships between editor components in the composer window.
Solid arrows indicate common interaction paths, open arrows less important paths.</i>
</p>

<p>
Some aspects of this picture deserve comment.
</p>

<ul>
    <li>First note that all the interaction between XUL/JS goes via the <code>nsEditorShell</code>.
    The lower-level editor interfaces are not (yet) exposed to JavaScript via IDL.
    </li>
    <li>
    Second, note that the editor core (<code>nsEditor</code>/<code>nsHTMLEditor</code>) knows nothing of the
    <code>nsEditorShell</code>. The editor is agnostic to who is driving it, and it's not tied
    to any specific front-end or environment.
    </li>
    <li>
    Third, note that the document being edited does not know that it is being
    edited. Editor acts on the document, but the document doesn't need to know
    anything about the editor.
    </li>
</ul>

<h2><a name="Editor_instantiation_in_a_XUL_window">Editor instantiation in a XUL window</a></h2>

<p>
The editor in XUL lives on top of a XUL <code>&lt;iframe&gt;</code> element; it observes
document loading in this <code>&lt;iframe&gt;</code>, and, when document loading is
complete, it instantiates an editor on the loaded document. The <code>&lt;iframe&gt;</code>
contents are then editable.
</p>

<p>
The job of observing doc loading in the <code>&lt;iframe&gt;</code> is performed
by <code>nsEditorShell</code>, a class which implements all of the communication between
the JavaScript and the editor core. <code>nsEditorShell</code> implements the
<code><a href="http://lxr.mozilla.org/seamonkey/source/editor/idl/nsIEditorShell.idl">nsIEditorShell</a></code>
interface, which is exposed to JavaScript via IDL.
The editor shell creates the editor when the time is right, holds the owning reference
to the editor object, and releases it when the XUL window is closed.
</p>

<p class="note">
<i>Note</i>: We are currently transitioning to a new tag specifically for editor, called, not surprisingly,
<code>&lt;editor&gt;</code>. This is really just an <code>&lt;iframe&gt;</code> which
takes over some of the task of creating the editor from JavaScript. As a result, some of the code
fragments here may be slightly different from what you see in the codebase.
</p>

<p>
So let's trace through the process of editor creation when bringing up the composer window.
You can find the relevant XUL parts in 
<a href="http://lxr.mozilla.org/seamonkey/source/editor/ui/composer/content/editor.xul">editor.xul</a>,
and the JavaScript parts in
<a href="http://lxr.mozilla.org/seamonkey/source/editor/ui/composer/content/editor.js"><code>editor.js</code></a>.
</p>

<ol>
    <li>
    <p>Something, somewhere, tells Mozilla to open the composer window. <code>editor.xul</code>
    is loaded. In <code>editor.xul</code>, the <code>&lt;window&gt;</code> tag has an onload 
    handler: <code>onload="EditorOnLoad()"</code>. That causes the <code>EditorOnLoad()</code>
    JavaScript function to get executed when the XUL is done loading.
    </p>
    <p>
    The XUL contains an <code>&lt;editor&gt;</code> or <code>&lt;iframe&gt;</code> tag. e.g.:
    </p>
<pre class="code">
    &lt;editor type="content-primary" id="content-frame" src="about:blank" flex="1"/&gt;
</pre>
    <p>
    The attribute <code>type="content-primary"</code> identifies this as the window content element, i.e.
    that which you get from <code>window._content</code>. Having an <code>id</code> attribute, <code>id="content-frame"</code>,
    allows us to find this element with <code>document.getElementById("content-frame")</code>, and to
    style it from CSS.
    </p>
    </li>

    <li>
    <p><code>EditorOnLoad()</code> is called. It does some getting of window.arguments
    (which is a way callers can pass parameters to new windows -- we use this to
    get the URL to be loaded), then it calls <code>EditorStartup()</code>, where the real work happens.
    It passes two parameters; the first indicates whether we want a plain text or HTML editor
    (pass <code>'text'</code> or <code>'html'</code> here), and the second is the <code>&lt;iframe&gt;</code>
    element on which we wish to create the editor. We could either pass <code>document.getElementById("content-frame")</code>
    or <code>window._content</code> here.
    </p>
    </li>

    <li>
    <p>The important stuff in <code>EditorStartup()</code> begins where we get or create an editorShell.
    Because of the <code>&lt;editor&gt;</code> transition, you'll see two patterns here:
    </p>

    <ol>
        <li><code>&lt;editor&gt;</code> version:<br>
        <p>
        The <code>&lt;editor&gt;</code> tag actually creates an
        <a href="http://lxr.mozilla.org/seamonkey/source/layout/xul/base/src/nsEditorBoxObject.cpp">nsEditorBoxObject</a>
        behind the scenes. The nsEditorBoxObject creates an nsEditorShell, and holds the owning reference to it.
        Through the magic of <a href="http://www.mozilla.org/xpfe/xptoolkit/xbl.html">XBL</a>, the
        <a href="http://lxr.mozilla.org/seamonkey/source/xpfe/global/resources/content/xulBindings.xml">XUL bindings</a>,
        and the
        <a href="http://lxr.mozilla.org/seamonkey/source/layout/xul/base/public/nsIEditorBoxObject.idl">nsIEditorBoxObject</a>
        interface, you can get a JS reference to the editorShell from the editor element with <code>element.editorShell</code>.
        We thus have an editorShell to play with.
        </p>
        </li>

        <li><code>&lt;iframe&gt;</code> version:<br>
        <p>
        In the absence of an <code>&lt;editor&gt;</code> tag, we have 
        to make the editorShell by  hand in the JS:
        </p>
<pre class="code">
var editorShell = Components.classes["component://netscape/editor/editorshell"].createInstance();
editorShell = editorShell.QueryInterface(Components.interfaces.nsIEditorShell);
</pre>
        <p>
        Again, now we have an editorShell to play with.
        </p>
        </li>
    </ol>
    </li>

    <li>
    <p>
    Now we set up the editorShell by calling its Init() method, telling it what type
    of editor we want (text or HTML), pointing it at the webShellWindow to use,
    and telling it the content node that it lives on:
    </p>
<pre class="code">
    editorShell.Init();
    editorShell.SetEditorType(editorType);
    editorShell.webShellWindow = window;
    editorShell.contentWindow = window._content;
</pre>
    <p>
    The <code>webShellWindow</code> (a settable attribute on nsIEditorShell) points to
    the top-level window element, from which the editorShell can get the XUL document
    in which it is living. It needs this to poke the UI (e.g. for command state maintenance,
    starting and stopping the throbber etc.).
    </p>
    <p>
    The <code>contentWindow</code> (another settable attribute on nsIEditorShell) points
    to the XUL element which is to become editable. [Note: since we already know this when
    we have an <code>&lt;editor&gt;</code> tag, we should remove the need to call this.]
    </p>
    </li>

    <li>
    <p>
    EditorStartup() does some other minor bits of setup before finally kicking off
    the URL load, which the most important part here.
    </p>
    <p>
    When the XUL was parsed, the <code>src</code> attribute on the content frame was
    set to <code>about:blank</code> (our default 'blank page' URL). We can't set that
    before XUL parsing, so we have to force a load of the page we now want to edit.
    We get the URL to load from the <code>args</code> element, then kick off the load:
    </p>
<pre class="code">
    var url = document.getElementById("args").getAttribute("value");
    editorShell.LoadUrl(url);
</pre>
    <p>
    Loading the document in the <code>&lt;iframe&gt;</code> of course happens
    asynchronously, so we need to know when we have a document that we can
    start editing.
    </p>
    <p>    
    nsEditorShell is able to observe the document load on the <code>&lt;iframe&gt;</code>,
    because it implements <code>nsIDocumentLoaderObserver</code>, and registered 
    itself as a doc loader when it was assigned the content window. It thus gets
    callbacks for the start, progress, and end of the document load.
    </p>
    <p class="note">
    these callbacks also fire for every subdocument that loads as
    a result of the parent document load, for example with frameset documents, or
    HTML documents with their own embedded <code>&lt;iframe&gt;</code>s. In this case, we need
    to be careful to instantiate the editor on the correct document. We are currently
    only able to have one editor per composer window; in future, relaxing this restriction
    would allow us to edit all the subdocuments in a frameset at the same time.
    </p>
    <p>
    We detect that the document we want to edit has loaded successfully in
    <code>nsEditorShell::OnEndDocumentLoad()</code>. After checking that we
    can actually edit this document, we go ahead and instantiate an editor
    on it (in <code>nsEditorShell::PrepareDocumentForEditing()</code>).
    As well as making the editor (which happens via <code>nsEditorShell::DoEditorMode()</code>)
    we also hook up various listeners and observers for UI updating and user
    interaction, and store a file specifier for the document we opened.
    </p>
    <p>
    The editor is now set up, and ready to go.
    </p>
    <p>
    One thing to note about editor initialization is that we pass into the editor's
    <code>Init()</code> method an <code>nsIContent*</code> that corresponds to the
    root of the content tree that the editor is allowed to work with. When initializing
    the editor from the nsEditorShell, we pass <code>NULL</code> here (which tells the editor that it can
    edit everything under the <code>&lt;body&gt;</code> of the document). This parameter
    is more important when the <a href="editor-textwidgets.html">editor is in a text widget</a>,
    where it points to the the subtree of the parent document that corresponds to widget content.
    </p>
</ol>

<h2><a name="Editor_teardown">Editor teardown</a></h2>
<p>
Window destruction, and hence editor teardown is initiated in two ways, listed
below. In both cases, the <code>EditorCanClose()</code> method is the JavaScript
is called, which causes the nsEditorShell to display a dialog asking the user
if they want to save the document, throw away their changes, or cancel. Note that
if they cancel, the close operation is aborted.
</p>

<ul>
        <li>
        The user clicks the Close widget in their OS/window manager. In this case,
        the <code>onclose</code> method on the <code>&lt;window&gt;</code> tag
is called.
        </li>
        <li>
        The user chooses 'Close' from the File menu, uses the key shortcut,
        or quits the application, causing all windows to be closed. Before each
        window is closed, JavaScript code in
        <a href="http://lxr.mozilla.org/seamonkey/source/xpfe/global/resources/content/globalOverlay.js">globalOverlay.js</a>
        tries to call a <code>tryToClose</code> method on each window. In <code>editor.js</code>,
        we set this to call <code>EditorCanClose()</code>.
        </li>
</ul>
<p>
If the user chooses to save the document, or throw away their changes,
then the window is closed. When the last reference to the
<code>nsEditorShell</code> goes away (either as a result of JavaScript garbage collection in the
<code>&lt;iframe&gt;</code> case, or the nsEditorBoxObject releasing its reference in the
<code>&lt;editor&gt;</code> case) it releases the owning reference on the editor.
</p>


<h2><a name="Editor_event_handling">Editor event handling</a></h2>

<p>
Editing operations happen in response to user events: mouse, key, drag and drop, and IME
(international text input) events. In order to receive these events, the editor registers
several event listeners on the document being edited. In addition, editor actions in the
user interface are propagated via the XUL and JavaScript, and call methods on the nsEditorShell.
This editor command dispatching is <a href="editor_commands.html">described separately</a>.
</p>
<p>
The following event listeners are registered:
</p>
<ul>
	<li>
	<p>In <code>nsHTMLEditor::InstallEventListeners()</code>, we install the following. These get installed for
	all types of editor (i.e. for text widgets and composer):</p>
	<ul>
	    <li><code>nsTextEditorKeyListener</code> (as a <code><a href="http://lxr.mozilla.org/seamonkey/ident?i=nsIDOMKeyListener">nsIDOMKeyListener</a></code>)</li>
	    <li><code>nsTextEditorMouseListener</code> (as a <code><a href="http://lxr.mozilla.org/seamonkey/ident?i=nsIDOMMouseListener">nsIDOMMouseListener</a></code>)</li>
	    <li><code>nsTextEditorFocusListener</code> (as a <code><a href="http://lxr.mozilla.org/seamonkey/ident?i=nsIDOMFocusListener">nsIDOMFocusListener</a></code>)</li>
	    <li><code>nsTextEditorTextListener</code> (as a <code><a href="http://lxr.mozilla.org/seamonkey/ident?i=nsIDOMTextListener">nsIDOMTextListener</a></code>)</li>
	    <li><code>nsTextEditorCompositionListener</code> (as a <code><a href="http://lxr.mozilla.org/seamonkey/ident?i=nsIDOMCompositionListener">nsIDOMCompositionListener</a></code>)</li>
	    <li><code>nsTextEditorDragListener</code> (as a <code><a href="http://lxr.mozilla.org/seamonkey/ident?i=nsIDOMDragListener">nsIDOMDragListener</a></code>)</li>
	</ul>
	</li>
	<li>
	<p>In <code>nsEditorShell::PrepareDocumentForEditing()</code>, we install a mouse listener. This only happens for
	situations where the nsEditorShell is used (i.e. not for text widgets):</p>
	<ul>
	    <li><code>nsEditorShellMouseListener</code> (as a <code><a href="http://lxr.mozilla.org/seamonkey/ident?i=nsIDOMMouseListener">nsIDOMMouseListener</a></code>)</li>
	</ul>
    </li>
</ul>

<h4>nsTextEditorKeyListener</h4>
<p>
This event listener handles key presses for typing, and other editing operations (backspace, delete, enter/return).
Cases that it does not handle explicitly it passes on to <code>nsHTMLEditor::EditorKeyPress()</code>,
which is where normal typing keys end up. Note that it only responds to the <code>KeyPress</code> event;
<code>KeyDown</code> and <code>KeyUp</code> events are ignored.
</p>

<h4>nsTextEditorMouseListener</h4>
<p>
The mouse listener is used to do middle-mouse paste (which is a Unix copy/paste feature). This happens
in response to <code>MouseClick</code> with button 2. It also forces an IME commit.
</p>

<h4>nsTextEditorFocusListener</h4>
<p>
Editor responds to <code>Focus</code> and <code>Blur</code> events by showing and hiding the caret or selection as appropriate.
</p>

<h4>nsTextEditorTextListener</h4>
<p>
The <code>nsIDOMTextListener</code> interface that this implements is used by the IME code. In response
to the <code>HandleText</code> event, the editor sets the inline input composition string.
</p>

<h4>nsTextEditorCompositionListener</h4>
<p>
<code>nsTextEditorCompositionListener</code> implements another IME-related interface,
<code>nsIDOMCompositionListener</code>. This is called by IME at the start, end, and to query the current
composition.
</p>

<h4>nsTextEditorDragListener</h4>
<p>
The drag listener handles drag and drop events in the editor. It responds to the start of a drag in
<code>DragGesture</code> by adding data to the drag, notifies the drag whether a drop can occur in
<code>DragOver</code>, and handles the drop by inserting data in <code>DragDrop</code>.
</p>

<h4>nsEditorShellMouseListener</h4>
<p>
This is an odd-man-out event listener, in that it's registered from the editorShell, rather than
internally to the editor. [Note: this is ugly, and should probably be redesigned to work on callbacks out of
the editor, or moved entirely to JavaScript.] The <code>nsEditorShellMouseListener</code> essentially
calls <code>nsEditorShell::HandleMouseClickOnElement</code> to show property dialogs for items that you double-click on.
</p>

<h3><a name="The_path_of_a_key_press">The path of a key press</a></h3>
<p>
So what happens to a key press once it's got to the <code>nsTextEditorKeyListener</code>? How does that
end up in the document? Let's trace through.
</p>
<ul>
    <li>
    <p><code>nsTextEditorKeyListener::KeyPress()</code> gets the key press event. For normal character
    keys, that falls into <code>nsHTMLEditor::EditorKeyPress()</code>.
    </p>
    </li>
    <li>
    <p><code>nsHTMLEditor::EditorKeyPress()</code> gets the character code from the key event,
    puts that into a string, and calls <code>nsHTMLEditor::TypedText()</code>, which simply
    calls <code>nsHTMLEditor::InsertText()</code>.
    </p>
    </li>
    <li>
    <p>
    <code>nsHTMLEditor::InsertText()</code> hides quite a bit of complexity in some stack-based
    classes.
    </p>
    <p>
    <code>nsAutoPlaceHolderBatch</code> is a utility class that wraps text insertion with calls to
    turn off selection and layout updating (to avoid flicker), and the maintenance of a placeholder
    transaction. This placeholder transaction enables us to <a href="http://www.mozilla.org/editor/txmgr/transaction-manager.html#Batching">batch</a>
    typing events together, so that an Undo undoes the whole series of keystrokes.
    </p>
    <p>
    Another stack-based class, <code>nsAutoRules</code>, ensures that text insertion is wrapped
    with calls to <code>nsHTMLEditor::StartOperation()</code>&nbsp;/ <code>EndOperation()</code>. These
    functions call <code>BeforeEdit()</code> and <code>AfterEdit()</code> on the current typing rules.
    </p>
    <p>
    Now, we initialize a <code>nsTextRulesInfo</code> with the information about the string
    being inserted, and call <code>WillDoAction()</code> on the current <a href="writing-rules.html">editing rules</a>.
    Because the implementation of inserting text differs between the different rules
    (plain text vs. HTML, for example), it is handled entirely by the rules code, in the <code>WillDoAction()</code>call.
    </p>
    <p>
    In Composer, we are using <code>nsHTMLEditRules</code>, so we end up in <code>nsHTMLEditRules::WillDoAction()</code>.
    For text insertion, this drops into <code>nsHTMLEditRules::WillInsertText()</code>. This code
    first deletes the selection if there is one (e.g. you are typing over selected text),
    then calls a generic pre-insertion call <code>WillInsert()</code>, which sets up inline styles
    for the inserted text, and moves the selection to an appropriate place where the text is to be
    inserted.
    </p>
    <p>
    Now we are ready to actually insert the text. Recall that we're going through a generic <code>InsertText()</code>
    call, so this code deals with pasting long strings, as well as inserting single characters.
    The code thus has to do the correct thing with linebreaks, so has a special case for inserting
    into <code>&lt;pre&gt;</code> sections. We call into the normal insertion code,
    which loops through the input string looking for linebreaks, and inserts each text run,
    followed by a <code>&lt;br&gt;</code> when necessary. When handling key presses, this will just
    insert a single character.
    </p>
    <p>
    We fall out of the <code>WillDoAction()</code> call, and drop into <code>WillDoAction()</code>, which, for
    text insertion, does nothing.
    </p>
    <p>
    The last thing that happens on a keypress is that <code>nsTextEditorKeyListener::KeyPress()</code>
    calls <code>ScrollSelectionIntoView()</code>, which, as the name suggests, ensures that the
    text that was just entered is visible.
    </p>    
    </li>
</ul>

<address class="author">Maintained by the editor team: <a href="mailto:mozilla-editor@mozilla.org">mozilla-editor@mozilla.org</a></address>



<hr class="hide">
</div>
</div>
<div id="footer">
<ul>
<li><a href="../sitemap.html">Site Map</a></li>
<li><a href="../security/">Security Updates</a></li>
<li><a href="../contact/">Contact Us</a></li>
<li><a href="../foundation/donate.html">Donate</a></li>
</ul>
<p class="copyright">
Portions of this content are &copy; 1998&#8211;2009 by individual mozilla.org
contributors; content available under a Creative Commons license | <a
href="http://www.mozilla.org/foundation/licensing/website-content.html">Details</a>.</p>
<p>
<span>Last modified November  8,  2006</span>
<span><a href="http://bonsai-www.mozilla.org/cvslog.cgi?file=mozilla-org/html/editor/editor-internals.html&amp;rev=&amp;root=/www/">Document History</a></span>
</p>
</div>
</div>
</body>
</html>
