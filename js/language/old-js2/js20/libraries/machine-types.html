<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>JavaScript 2.0 Machine Types Library</TITLE>
<LINK rel=stylesheet href="../../styles.css">
<LINK rel=Start href="../index.html">
<LINK rel=Contents href="../index.html">
<LINK rel=Prev href="types.html">
<LINK rel=Next href="../formal/index.html">
<SCRIPT type="text/javascript" language="JavaScript1.2" src="../../unicodeCompatibility.js"></SCRIPT>
</HEAD>

<BODY>
<TABLE width="100%" border=0 cellspacing=2 cellpadding=0>
<TR>
  <TD valign=TOP nowrap>
    <DIV class=title2><SPAN class=top-title>JavaScript 2.0</SPAN></DIV>
    <DIV class=title2>Libraries</DIV>
    <DIV class=title1>Machine Types</DIV>
  </TD>
  <TD valign=TOP nowrap align=RIGHT><A href="types.html"><IMG src="../../arrows/left.gif" align=BOTTOM width=37 height=37 alt="previous"></A><A href="../index.html"><IMG src="../../arrows/up.gif" align=BOTTOM width=37 height=37 alt="up"></A><A href="../formal/index.html"><IMG src="../../arrows/right.gif" align=BOTTOM width=37 height=37 alt="next"></A></TD>
</TR>
</TABLE>

<P class=mod-date>Tuesday, March 4, 2003</P>

<H2>Purpose</H2>

<P>Machine types are low-level numeric types for use in JavaScript 2.0 programs. These types provide Java-style integer operations
that are useful for communicating between JavaScript 2.0 and other programming languages. These types are not intended to
replace <CODE>Number</CODE> and <CODE>Integer</CODE> for general-purpose scripting.</P>

<H2>Contents</H2>

<P>The following low-level numeric types are available:</P>

<DIV class=indent>
  <TABLE border=0 cellspacing=2 cellpadding=0>
  <TR>
    <TH valign=TOP nowrap align=LEFT>Type</TH>
    <TH valign=TOP align=LEFT>Suffix&nbsp;</TH>
    <TH valign=TOP align=LEFT>Values</TH>
  </TR>
  <TR>
    <TD valign=TOP nowrap><CODE>sbyte</CODE></TD>
    <TD valign=TOP>&nbsp;</TD>
    <TD valign=TOP><CODE>Integer</CODE> values between &#8211;128 and 127 inclusive, excluding &#8211;0.0</TD>
  </TR>
  <TR>
    <TD valign=TOP nowrap><CODE>byte</CODE></TD>
    <TD valign=TOP>&nbsp;</TD>
    <TD valign=TOP><CODE>Integer</CODE> values between 0 and 255 inclusive, excluding &#8211;0.0</TD>
  </TR>
  <TR>
    <TD valign=TOP nowrap><CODE>short</CODE></TD>
    <TD valign=TOP>&nbsp;</TD>
    <TD valign=TOP><CODE>Integer</CODE> values between &#8211;32768 and 32767 inclusive, excluding &#8211;0.0</TD>
  </TR>
  <TR>
    <TD valign=TOP nowrap><CODE>ushort</CODE>&nbsp;</TD>
    <TD valign=TOP>&nbsp;</TD>
    <TD valign=TOP><CODE>Integer</CODE> values between 0 and 65535 inclusive, excluding &#8211;0.0</TD>
  </TR>
  <TR>
    <TD valign=TOP nowrap><CODE>int</CODE></TD>
    <TD valign=TOP>&nbsp;</TD>
    <TD valign=TOP><CODE>Integer</CODE> values between &#8211;2147483648 and 2147483647 inclusive, excluding &#8211;0.0</TD>
  </TR>
  <TR>
    <TD valign=TOP nowrap><CODE>uint</CODE></TD>
    <TD valign=TOP>&nbsp;</TD>
    <TD valign=TOP><CODE>Integer</CODE> values between 0 and 4294967295 inclusive, excluding &#8211;0.0</TD>
  </TR>
  <TR>
    <TD valign=TOP nowrap><CODE>long</CODE></TD>
    <TD valign=TOP><CODE>L</CODE></TD>
    <TD valign=TOP>Long integer values between &#8211;9223372036854775808 and 9223372036854775807 inclusive</TD>
  </TR>
  <TR>
    <TD valign=TOP nowrap><CODE>ulong</CODE></TD>
    <TD valign=TOP><CODE>UL</CODE></TD>
    <TD valign=TOP>Long integer values between 0 and 18446744073709551615 inclusive</TD>
  </TR>
  <TR>
    <TD valign=TOP nowrap><CODE>float</CODE></TD>
    <TD valign=TOP><CODE>F</CODE></TD>
    <TD valign=TOP>Single-precision IEEE floating-point numbers, including positive and negative zeroes, infinities, and NaN</TD>
  </TR>
  </TABLE>

</DIV>


<P>The above type names are <I>not</I> reserved words.</P>

<H3>8, 16, and 32-bit Integers</H3>

<P>The first six types <CODE>sbyte</CODE>, <CODE>byte</CODE>, <CODE>short</CODE>, <CODE>ushort</CODE>, <CODE>int</CODE>, and
<CODE>uint</CODE> are all proper subtypes of <CODE>Integer</CODE>, which is itself a subtype of <CODE>Number</CODE>. A particular
number is a member of multiple types. For example, 3.0 is a member of <CODE>sbyte</CODE>, <CODE>byte</CODE>, <CODE>short</CODE>,
<CODE>ushort</CODE>, <CODE>int</CODE>, <CODE>uint</CODE>, <CODE>Integer</CODE>, <CODE>Number</CODE>, and <CODE>Object</CODE>,
while &#8211;2000.0 is a member of <CODE>short</CODE>, <CODE>int</CODE>, <CODE>Integer</CODE>, <CODE>Number</CODE>, and <CODE>Object</CODE>.
JavaScript does not distinguish between the literals 3 and 3.0 in any way.</P>

<P>All arithmetic operations and comparisons on <CODE>sbyte</CODE>, <CODE>byte</CODE>, <CODE>short</CODE>, <CODE>ushort</CODE>,
  <CODE>int</CODE>, and <CODE>uint</CODE> values treat them just like they would any other <CODE>Number</CODE> values &#8212;
  the operations are performed using full IEEE double-precision arithmetic.</P>
<H4>Implicit Coercions</H4>

<P>There are no predefined <A href="types.html#implicit-coercion">implicit coercions</A> from values of type <CODE>sbyte</CODE>,
  <CODE>byte</CODE>, <CODE>short</CODE>, <CODE>ushort</CODE>, <CODE>int</CODE>, or <CODE>uint</CODE> other than the coercions
  predefined on the type <CODE>Number</CODE>. The following predefined <A href="types.html#implicit-coercion">implicit coercions</A>
  are applicable when the destination type is <CODE>sbyte</CODE>, <CODE>byte</CODE>, <CODE>short</CODE>, <CODE>ushort</CODE>,
  <CODE>int</CODE>, or <CODE>uint</CODE>:</P>

<UL>
  <LI><CODE>undefined</CODE>
    <SCRIPT type="text/javascript">document.write(U_rarr)</SCRIPT>
    +0.0</LI>
  <LI>&#8211;0.0
    <SCRIPT type="text/javascript">document.write(U_rarr)</SCRIPT>
    +0.0</LI>
  <LI><CODE>long</CODE> and <CODE>ulong</CODE> values within range of the destination type <VAR>T</VAR> are converted to equivalent
    values of type <VAR>T</VAR></LI>
  <LI>finite integral <CODE>float</CODE> values within range of the destination type <VAR>T</VAR> are converted to equivalent
    values of type <VAR>T</VAR></LI>
</UL>

<P>Note that there are no <A href="types.html#implicit-coercion">implicit coercions</A> from +<SCRIPT type="text/javascript">document.write(U_infin)</SCRIPT>,
&#8211;<SCRIPT type="text/javascript">document.write(U_infin)</SCRIPT>, or NaN to <CODE>sbyte</CODE>, <CODE>byte</CODE>, <CODE>short</CODE>,
<CODE>ushort</CODE>, <CODE>int</CODE>, or <CODE>uint</CODE>.</P>
<H4>Explicit Coercions</H4>

<P>There are no predefined <A href="types.html#explicit-coercion">explicit coercions</A> from values of type <CODE>sbyte</CODE>,
<CODE>byte</CODE>, <CODE>short</CODE>, <CODE>ushort</CODE>, <CODE>int</CODE>, or <CODE>uint</CODE> other than the coercions
predefined on the type <CODE>Number</CODE>. The predefined <A href="types.html#explicit-coercion">explicit coercions</A> below
are applicable when the destination type <VAR>T</VAR> is <CODE>sbyte</CODE>, <CODE>byte</CODE>, <CODE>short</CODE>, <CODE>ushort</CODE>,
<CODE>int</CODE>, or <CODE>uint</CODE>. The notation |<VAR>T</VAR>| represents the range of the type <VAR>T</VAR>, where |<CODE>sbyte</CODE>|
= |<CODE>byte</CODE>| = 256, |<CODE>short</CODE>| = |<CODE>ushort</CODE>| = 65536, and |<CODE>int</CODE>| = |<CODE>uint</CODE>|
= 2<SUP>32</SUP>.</P>

<UL>
  <LI><CODE>undefined</CODE> <SCRIPT type="text/javascript">document.write(U_rarr)</SCRIPT> +0.0</LI>
  <LI>A <CODE>long</CODE> or <CODE>ulong</CODE> value <VAR>x</VAR> is converted to the one value <VAR>y</VAR> of type <VAR>T</VAR>
    that satisfies <VAR>x</VAR>&nbsp;=&nbsp;<VAR>y</VAR>&nbsp;(mod |<VAR>T</VAR>|)</LI>
  <LI><CODE>float</CODE> values are first converted to equivalent <CODE>Number</CODE> values and then converted as below</LI>
  <LI>A <CODE>Number</CODE> value is first converted to an <CODE>Integer</CODE> value <VAR>x</VAR> by truncating towards zero
    if necessary. Then, if <VAR>x</VAR> is &#8211;0.0, +<SCRIPT type="text/javascript">document.write(U_infin)</SCRIPT>, &#8211;<SCRIPT type="text/javascript">document.write(U_infin)</SCRIPT>,
    or NaN, it is converted to +0.0; otherwise, <VAR>x</VAR> is converted to the one value <VAR>y</VAR> of type <VAR>T</VAR>
    that satisfies <VAR>x</VAR>&nbsp;=&nbsp;<VAR>y</VAR>&nbsp;(mod |<VAR>T</VAR>|)</LI>
</UL>
<H3>64-bit Integers</H3>

<P>The types <CODE>long</CODE> and <CODE>ulong</CODE> represent signed and unsigned 64-bit integers. <CODE>long</CODE> and
<CODE>ulong</CODE> literals are written with the suffix <CODE>L</CODE> or <CODE>UL</CODE> and no exponent or decimal point.
Literal values of type <CODE>long</CODE> are written as <CODE>&#8211;9223372036854775808L</CODE> through <CODE>9223372036854775807L</CODE>.
Literal values of type <CODE>ulong</CODE> are written as <CODE>0UL</CODE> through <CODE>18446744073709551615UL</CODE>.</P>

<P>The types <CODE>long</CODE> and <CODE>ulong</CODE> are disjoint from <CODE>Number</CODE>, so <CODE>5L</CODE> and <CODE>5</CODE>
are different objects, although they compare <CODE>==</CODE> and <CODE>===</CODE> to each other. <CODE>5L</CODE> and <CODE>5UL</CODE>
are also different objects, although they compare <CODE>==</CODE> and <CODE>===</CODE> to each other.</P>

<P>Negation, addition, subtraction, and multiplication, and modulo (<CODE>%</CODE>) on <CODE>long</CODE> and <CODE>ulong</CODE>
values is exact, and <CODE>long</CODE> and <CODE>ulong</CODE> values may be mixed in an expression. There are five possible
cases depending on the mathematical result <VAR>x</VAR>:</P>

<UL>
  <LI>If &#8211;9223372036854775808&nbsp;<SCRIPT type="text/javascript">document.write(U_le)</SCRIPT>&nbsp;<VAR>x</VAR>&nbsp;<SCRIPT type="text/javascript">document.write(U_le)</SCRIPT>&nbsp;&#8211;1,
    then the result has type <CODE>long</CODE>.</LI>
  <LI>If 0&nbsp;<SCRIPT type="text/javascript">document.write(U_le)</SCRIPT>&nbsp;<VAR>x</VAR>&nbsp;<SCRIPT type="text/javascript">document.write(U_le)</SCRIPT>&nbsp;9223372036854775807,
    then the result has type <CODE>ulong</CODE> if at least one operand has type <CODE>ulong</CODE>; otherwise, the result
    has type <CODE>long</CODE>.</LI>
  <LI>If 9223372036854775808&nbsp;<SCRIPT type="text/javascript">document.write(U_le)</SCRIPT>&nbsp;<VAR>x</VAR>&nbsp;<SCRIPT type="text/javascript">document.write(U_le)</SCRIPT>&nbsp;18446744073709551615,
    then the result has type <CODE>ulong</CODE>.</LI>
  <LI>Otherwise, the result is the closest representable <CODE>Number</CODE> using the IEEE round-to-nearest mode.</LI>
</UL>

<P>Division involving two <CODE>long</CODE> or <CODE>ulong</CODE> operands returns the most precise quotient available from
among the possible <CODE>long</CODE>, <CODE>ulong</CODE>, and <CODE>Number</CODE> values. In some cases the quotient will
be a <CODE>long</CODE> or <CODE>ulong</CODE>; in other cases the quotient will be a <CODE>Number</CODE>. See the <A href="../formal/parser-semantics.html#V-divide">semantics</A>
for the details.</P>

<P>Division and modulo on <CODE>long</CODE> and <CODE>ulong</CODE> values can produce the <CODE>Number</CODE> values positive
or negative infinity or NaN when the divisor is zero.</P>

<P>Addition, subtraction, multiplication, division, and modulo mixing a <CODE>long</CODE> or <CODE>ulong</CODE> operand with
a <CODE>Number</CODE> (or any subtype of <CODE>Number</CODE>) or <CODE>float</CODE> operand first checks whether the <CODE>Number</CODE>
or <CODE>float</CODE> operand is an exact integer (including either +0.0 or &#8211;0.0 but not infinities or NaN). If it is,
then the computation uses the integral semantics above. If not, then the <CODE>long</CODE> or <CODE>ulong</CODE> operand is
coerced to a <CODE>Number</CODE> and the operation is done using <CODE>Number</CODE> arithmetic.</P>

<P>The bitwise operations <CODE>&amp;</CODE>, <CODE>|</CODE>, and <CODE>^</CODE> are 64 bits wide if at least one operand
is a <CODE>long</CODE> or <CODE>ulong</CODE>, in which case the other operand is truncated to an integer and treated modulo
2<SUP>64</SUP> if necessary. The result is a <CODE>ulong</CODE> if at least one operand is a <CODE>ulong</CODE>; otherwise,
the result is a <CODE>long</CODE>.</P>

<P>The bitwise shifts <CODE>&lt;&lt;</CODE>, <CODE>&gt;&gt;</CODE>, and <CODE>&gt;&gt;&gt;</CODE> are 64 bits wide if the
first operand is a <CODE>long</CODE> or <CODE>ulong</CODE>. The result is a <CODE>ulong</CODE> if the first operand is a <CODE>ulong</CODE>;
otherwise, the result is a <CODE>long</CODE>. <CODE>&gt;&gt;</CODE> copies the most significant bit and <CODE>&gt;&gt;&gt;</CODE>
shifts in zero bits regardless of whether the first operand is a <CODE>long</CODE> or <CODE>ulong</CODE>.</P>

<P>Comparisons mixing a <CODE>long</CODE> or <CODE>ulong</CODE> operand with a <CODE>Number</CODE> (or any subtype of <CODE>Number</CODE>)
or <CODE>float</CODE> operand compare exact mathematical values without any coercions.</P>

<H4>Implicit Coercions</H4>

<P>The following predefined <A href="types.html#implicit-coercion">implicit coercions</A> are applicable when the destination
type is <CODE>long</CODE>:</P>

<UL>
  <LI><CODE>undefined</CODE> <SCRIPT type="text/javascript">document.write(U_rarr)</SCRIPT> 0L</LI>
  <LI><CODE>ulong</CODE> values between 0UL and 9223372036854775807UL are converted to equivalent <CODE>long</CODE> values</LI>
  <LI>Finite <CODE>Integer</CODE> values between &#8211;9223372036854775808 and 9223372036854775807 are converted to equivalent
    <CODE>long</CODE> values</LI>
  <LI>Finite integral <CODE>float</CODE> values between &#8211;9223372036854775808F and 9223372036854775807F are converted
    to equivalent <CODE>long</CODE> values</LI>
</UL>

<P>The following predefined <A href="types.html#implicit-coercion">implicit coercions</A> are applicable when the destination
type is <CODE>ulong</CODE>:</P>

<UL>
  <LI><CODE>undefined</CODE> <SCRIPT type="text/javascript">document.write(U_rarr)</SCRIPT> 0UL</LI>
  <LI><CODE>long</CODE> values between 0L and 9223372036854775807L are converted to equivalent <CODE>ulong</CODE> values</LI>
  <LI>Finite <CODE>Integer</CODE> values between &#8211;0.0 and 18446744073709551615 are converted to equivalent <CODE>ulong</CODE>
    values</LI>
  <LI>Finite integral <CODE>float</CODE> values between &#8211;0.0F and 18446744073709551615F are converted to equivalent
    <CODE>ulong</CODE> values</LI>
</UL>

<P>Note that there are no <A href="types.html#implicit-coercion">implicit coercions</A> from NaN or positive or negative infinity
to <CODE>long</CODE> or <CODE>ulong</CODE>.</P>

<P>A <CODE>long</CODE> or <CODE>ulong</CODE> value can be <A href="types.html#implicit-coercion">implicitly coerced</A> to
type <CODE>Number</CODE>, <CODE>Integer</CODE>, or <CODE>float</CODE>. The result is the closest representable <CODE>Number</CODE>
or <CODE>float</CODE> value using the same rounding as when a string is converted to a number. If the source is 0L or 0UL
then the result is +0.0 or +0.0F.</P>

<H4>Explicit Coercions</H4>

<P>The predefined <A href="types.html#explicit-coercion">explicit coercions</A> below are applicable when the destination
type <VAR>T</VAR> is <CODE>long</CODE> or <CODE>ulong</CODE>.</P>

<UL>
  <LI><CODE>undefined</CODE> <SCRIPT type="text/javascript">document.write(U_rarr)</SCRIPT> 0L or 0UL</LI>
  <LI>A <CODE>long</CODE> or <CODE>ulong</CODE> value <VAR>x</VAR> is converted to the one value <VAR>y</VAR> of type <VAR>T</VAR>
    that satisfies <VAR>x</VAR>&nbsp;=&nbsp;<VAR>y</VAR>&nbsp;(mod 2<SUP>64</SUP>)</LI>
  <LI><CODE>float</CODE> values are first converted to equivalent <CODE>Number</CODE> values and then converted as below</LI>
  <LI>A <CODE>Number</CODE> value is first converted to an <CODE>Integer</CODE> value <VAR>x</VAR> by truncating towards zero
    if necessary. Then, if <VAR>x</VAR> is &#8211;0.0, +<SCRIPT type="text/javascript">document.write(U_infin)</SCRIPT>, &#8211;<SCRIPT type="text/javascript">document.write(U_infin)</SCRIPT>,
    or NaN, it is converted to 0L or 0UL; otherwise, <VAR>x</VAR> is converted to the one value <VAR>y</VAR> of type <VAR>T</VAR>
    that satisfies <VAR>x</VAR>&nbsp;=&nbsp;<VAR>y</VAR>&nbsp;(mod 2<SUP>64</SUP>).</LI>
</UL>

<P>A <CODE>long</CODE> or <CODE>ulong</CODE> value <VAR>x</VAR> can be <A href="types.html#explicit-coercion">explicitly coerced</A>
to type <CODE>Number</CODE>, <CODE>Integer</CODE>, <CODE>float</CODE> or <CODE>String</CODE>. Explicit coercions to <CODE>Number</CODE>,
<CODE>Integer</CODE>, <CODE>float</CODE> are the same as the implicit coercions. Explicit coercions to type <CODE>String</CODE>
produce the <VAR>x</VAR> as a string of decimal digits. Negative values have a minus sign prepended. Zero produces the string
<CODE>"0"</CODE>; all other values produce strings starting with a non-zero digit.</P>

<H3>Single-Precision Floats</H3>

<P>The type <CODE>float</CODE> represents single-precision IEEE floating-point numbers. <CODE>float</CODE> literals are written
with the suffix <CODE>F</CODE>. <CODE>float</CODE> infinities and NaN are separate from <CODE>Number</CODE> infinities and
NaN.</P>

<P>The type <CODE>float</CODE> is disjoint from <CODE>Number</CODE>, so <CODE>5F</CODE> and <CODE>5</CODE> are different objects,
although they compare <CODE>==</CODE> to each other.</P>

<P>Negating a <CODE>float</CODE> value returns a <CODE>float</CODE> value. All other arithmetic first converts the <CODE>float</CODE>
value to the corresponding <CODE>Number</CODE> value. The bitwise operations <CODE>&amp;</CODE>, <CODE>|</CODE>, <CODE>^</CODE>,
<CODE>&lt;&lt;</CODE>, <CODE>&gt;&gt;</CODE>, and <CODE>&gt;&gt;&gt;</CODE> coerce any <CODE>float</CODE> operands to type
<CODE>Number</CODE> before proceeding.</P>

<H4>Implicit Coercions</H4>

<P>The following predefined <A href="types.html#implicit-coercion">implicit coercions</A> are applicable when the destination
type is <CODE>float</CODE>:</P>

<UL>
  <LI><CODE>undefined</CODE> <SCRIPT type="text/javascript">document.write(U_rarr)</SCRIPT> <CODE>float(NaN)</CODE></LI>
  <LI><CODE>Number</CODE> values (including NaN and the infinities) are converted to the closest representable <CODE>float</CODE>
    values using the IEEE round-to-nearest mode</LI>
  <LI><CODE>long</CODE> and <CODE>ulong</CODE> values are converted to the closest representable <CODE>float</CODE> values
    (excluding &#8211;0.0F)</LI>
</UL>

<P>A <CODE>float</CODE> value can be <A href="types.html#implicit-coercion">implicitly coerced</A> to type <CODE>Number</CODE>.
The result is the equivalent <CODE>Number</CODE> value.</P>

<HR>
<TABLE width="100%" border=0 cellspacing=2 cellpadding=0>
<TR>
  <TD valign=BOTTOM nowrap>
    <ADDRESS><A href="mailto:waldemar@netscape.com">Waldemar Horwat</A><BR>
    Last modified Tuesday, March 4, 2003</ADDRESS>
  </TD>
  <TD valign=TOP nowrap align=RIGHT><A href="types.html"><IMG src="../../arrows/left.gif" align=BOTTOM width=37 height=37 alt="previous"></A><A href="../index.html"><IMG src="../../arrows/up.gif" align=BOTTOM width=37 height=37 alt="up"></A><A href="../formal/index.html"><IMG src="../../arrows/right.gif" align=BOTTOM width=37 height=37 alt="next"></A></TD>
</TR>
</TABLE>

</BODY>
</HTML>
