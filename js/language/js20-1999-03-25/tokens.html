<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>JavaScript 2.0 Tokens</TITLE>
<LINK rel=stylesheet href="../styles.css">
<LINK rel=Start href="index.html">
<LINK rel=Contents href="index.html">
<LINK rel=Prev href="operator-overloading.html">
<LINK rel=Next href="expressions.html">
<SCRIPT type="text/javascript" language="JavaScript1.2" src="../unicodeCompatibility.js"></SCRIPT>
</HEAD>

<BODY>
<TABLE width="100%" border=0 cellspacing=2 cellpadding=0>
<TR>
  <TD valign=TOP nowrap>
    <DIV class=title2><SPAN class=draft-title>March 1999 Draft</SPAN></DIV>
    <DIV class=title2><SPAN class=draft-title>JavaScript 2.0</SPAN></DIV>
    <DIV class=title1>Tokens</DIV>
  </TD>
  <TD valign=TOP nowrap align=RIGHT><A href="operator-overloading.html"><IMG src="../arrows/left.gif" align=BOTTOM width=37 height=37 alt="previous"></A><A href="index.html"><IMG src="../arrows/up.gif" align=BOTTOM width=37 height=37 alt="up"></A><A href="expressions.html"><IMG src="../arrows/right.gif" align=BOTTOM width=37 height=37 alt="next"></A></TD>
</TR>
</TABLE>

<P class=mod-date>Monday, March 22, 1999</P>

<H2>Punctuators</H2>

<P>The following JavaScript 1.x punctuation tokens are recognized in JavaScript 2.0:</P>

<P class=indent><CODE class=terminal-keyword>!</CODE> &nbsp; <CODE class=terminal-keyword>!=</CODE> &nbsp; <CODE class=terminal-keyword>!==</CODE>
&nbsp; <CODE class=terminal-keyword>%</CODE> &nbsp; <CODE class=terminal-keyword>%=</CODE> &nbsp; <CODE class=terminal-keyword>&amp;</CODE>
&nbsp; <CODE class=terminal-keyword>&amp;&amp;</CODE> &nbsp; <CODE class=terminal-keyword>&amp;=</CODE> &nbsp; <CODE class=terminal-keyword>(</CODE>
&nbsp; <CODE class=terminal-keyword>)</CODE> &nbsp; <CODE class=terminal-keyword>*</CODE> &nbsp; <CODE class=terminal-keyword>*=</CODE>
&nbsp; <CODE class=terminal-keyword>+</CODE> &nbsp; <CODE class=terminal-keyword>++</CODE> &nbsp; <CODE class=terminal-keyword>+=</CODE>
&nbsp; <CODE class=terminal-keyword>,</CODE> &nbsp; <CODE class=terminal-keyword>-</CODE> &nbsp; <CODE class=terminal-keyword>--</CODE>
&nbsp; <CODE class=terminal-keyword>-=</CODE> &nbsp; <CODE class=terminal-keyword>.</CODE> &nbsp; <CODE class=terminal-keyword>..</CODE>
&nbsp; <CODE class=terminal-keyword>...</CODE> &nbsp; <CODE class=terminal-keyword>/</CODE> &nbsp; <CODE class=terminal-keyword>/=</CODE>
&nbsp; <CODE class=terminal-keyword>:</CODE> &nbsp; <CODE class=terminal-keyword>::</CODE> &nbsp; <CODE class=terminal-keyword>;</CODE>
&nbsp; <CODE class=terminal-keyword>&lt;</CODE> &nbsp; <CODE class=terminal-keyword>&lt;&lt;</CODE> &nbsp; <CODE class=terminal-keyword>&lt;&lt;=</CODE>
&nbsp; <CODE class=terminal-keyword>&lt;=</CODE> &nbsp; <CODE class=terminal-keyword>=</CODE> &nbsp; <CODE class=terminal-keyword>==</CODE>
&nbsp; <CODE class=terminal-keyword>===</CODE> &nbsp; <CODE class=terminal-keyword>&gt;</CODE> &nbsp; <CODE class=terminal-keyword>&gt;=</CODE>
&nbsp; <CODE class=terminal-keyword>&gt;&gt;</CODE> &nbsp; <CODE class=terminal-keyword>&gt;&gt;=</CODE> &nbsp; <CODE class=terminal-keyword>&gt;&gt;&gt;</CODE>
&nbsp; <CODE class=terminal-keyword>&gt;&gt;&gt;=</CODE> &nbsp; <CODE class=terminal-keyword>?</CODE> &nbsp; <CODE class=terminal-keyword>[</CODE>
&nbsp; <CODE class=terminal-keyword>]</CODE> &nbsp; <CODE class=terminal-keyword>^</CODE> &nbsp; <CODE class=terminal-keyword>^=</CODE>
&nbsp; <CODE class=terminal-keyword>{</CODE> &nbsp; <CODE class=terminal-keyword>|</CODE> &nbsp; <CODE class=terminal-keyword>|=</CODE>
&nbsp; <CODE class=terminal-keyword>||</CODE> &nbsp; <CODE class=terminal-keyword>}</CODE> &nbsp; <CODE class=terminal-keyword>~</CODE></P>

<P>The following punctuation tokens are new in JavaScript 2.0:</P>

<P class=indent><CODE class=terminal-keyword>#</CODE> &nbsp; <CODE class=terminal-keyword>&amp;&amp;=</CODE> &nbsp; <CODE class=terminal-keyword>-&gt;</CODE>
&nbsp; <CODE class=terminal-keyword>..</CODE> &nbsp; <CODE class=terminal-keyword>...</CODE> &nbsp; <CODE class=terminal-keyword>@</CODE>
&nbsp; <CODE class=terminal-keyword>^^</CODE> &nbsp; <CODE class=terminal-keyword>^^=</CODE> &nbsp; <CODE class=terminal-keyword>||=</CODE></P>

<H2>Keywords</H2>

<P>The following reserved words are used in JavaScript 2.0:</P>

<P class=indent><CODE class=terminal-keyword>break</CODE> &nbsp; <CODE class=terminal-keyword>case</CODE> &nbsp; <CODE class=terminal-keyword>catch</CODE>
&nbsp; <CODE class=terminal-keyword>class</CODE> &nbsp; <CODE class=terminal-keyword>const</CODE> &nbsp; <CODE class=terminal-keyword>continue</CODE>
&nbsp; <CODE class=terminal-keyword>default</CODE> &nbsp; <CODE class=terminal-keyword>delete</CODE> &nbsp; <CODE class=terminal-keyword>do</CODE>
&nbsp; <CODE class=terminal-keyword>else</CODE> &nbsp; <CODE class=terminal-keyword>eval</CODE> &nbsp; <CODE class=terminal-keyword>extends</CODE>
&nbsp; <CODE class=terminal-keyword>false</CODE> &nbsp; <CODE class=terminal-keyword>field</CODE> &nbsp; <CODE class=terminal-keyword>final</CODE>
&nbsp; <CODE class=terminal-keyword>finally</CODE> &nbsp; <CODE class=terminal-keyword>for</CODE> &nbsp; <CODE class=terminal-keyword>function</CODE>
&nbsp; <CODE class=terminal-keyword>if</CODE> &nbsp; <CODE class=terminal-keyword>import</CODE> &nbsp; <CODE class=terminal-keyword>in</CODE>
&nbsp; <CODE class=terminal-keyword>instanceof</CODE> &nbsp; <CODE class=terminal-keyword>new</CODE> &nbsp; <CODE class=terminal-keyword>null</CODE>
&nbsp; <CODE class=terminal-keyword>package</CODE> &nbsp; <CODE class=terminal-keyword>private</CODE> &nbsp; <CODE class=terminal-keyword>protected</CODE>
&nbsp; <CODE class=terminal-keyword>public</CODE> &nbsp; <CODE class=terminal-keyword>return</CODE> &nbsp; <CODE class=terminal-keyword>super</CODE>
&nbsp; <CODE class=terminal-keyword>switch</CODE> &nbsp; <CODE class=terminal-keyword>this</CODE> &nbsp; <CODE class=terminal-keyword>throw</CODE>
&nbsp; <CODE class=terminal-keyword>true</CODE> &nbsp; <CODE class=terminal-keyword>try</CODE> &nbsp; <CODE class=terminal-keyword>typeof</CODE>
&nbsp; <CODE class=terminal-keyword>var</CODE> &nbsp; <CODE class=terminal-keyword>while</CODE> &nbsp; <CODE class=terminal-keyword>with</CODE></P>

<P>Out of these, the only words that were not reserved in JavaScript 1.x are <CODE class=terminal-keyword>eval</CODE> and
<CODE class=terminal-keyword>field</CODE>.</P>

<P>The following reserved words are reserved for future expansion:</P>

<P class=indent><CODE class=terminal-keyword>abstract</CODE> &nbsp; <CODE class=terminal-keyword>debugger</CODE> &nbsp; <CODE class=terminal-keyword>enum</CODE>
&nbsp; <CODE class=terminal-keyword>export</CODE> &nbsp; <CODE class=terminal-keyword>goto</CODE> &nbsp; <CODE class=terminal-keyword>implements</CODE>
&nbsp; <CODE class=terminal-keyword>native</CODE> &nbsp; <CODE class=terminal-keyword>static</CODE> &nbsp; <CODE class=terminal-keyword>synchronized</CODE>
&nbsp; <CODE class=terminal-keyword>throws</CODE> &nbsp; <CODE class=terminal-keyword>transient</CODE> &nbsp; <CODE class=terminal-keyword>volatile</CODE></P>

<P>The following words have special meaning in some contexts in JavaScript 2.0 but are not reserved and may be used as identifiers:</P>

<P class=indent><CODE class=terminal-keyword>constructor</CODE> &nbsp; <CODE class=terminal-keyword>getter</CODE> &nbsp; <CODE class=terminal-keyword>method</CODE>
&nbsp; <CODE class=terminal-keyword>override</CODE> &nbsp; <CODE class=terminal-keyword>setter</CODE> &nbsp; <CODE class=terminal-keyword>traditional</CODE>
&nbsp; <CODE class=terminal-keyword>version</CODE></P>

<P>The following words name predefined types but are not reserved and may be used as identifiers (although this is not recommended):</P>

<P class=indent><CODE class=terminal-keyword>Any</CODE> &nbsp; <CODE class=terminal-keyword>Array</CODE> &nbsp; <CODE class=terminal-keyword>array</CODE>
&nbsp; <CODE class=terminal-keyword>boolean</CODE> &nbsp; <CODE class=terminal-keyword>character</CODE> &nbsp; <CODE class=terminal-keyword>Function</CODE>
&nbsp; <CODE class=terminal-keyword>integer</CODE> &nbsp; <CODE class=terminal-keyword>Null</CODE> &nbsp; <CODE class=terminal-keyword>number</CODE>
&nbsp; <CODE class=terminal-keyword>Object</CODE> &nbsp; <CODE class=terminal-keyword>object</CODE> &nbsp; <CODE class=terminal-keyword>string</CODE>
&nbsp; <CODE class=terminal-keyword>Type</CODE> &nbsp; <CODE class=terminal-keyword>type</CODE> &nbsp; <CODE class=terminal-keyword>void</CODE></P>

<H2>Semicolon Insertion</H2>

<P>General semicolon insertion at any line break cannot be supported in JavaScript 2.0 because it would introduce too many
unexpected program behaviors and break future compatibility (a program with lines <I>LINE1</I> and <I>LINE2</I> separated
by a line break might be interpreted as <I>LINE1</I><CODE>;</CODE><I>LINE2</I> today, while a future syntax extension might
change its meaning to <I>LINE1 LINE2</I>). For example, the program</P>

<PRE>var x
i = 3</PRE>

<P>would be interpreted as</P>

<PRE>var x i = 3</PRE>

<P>and treat <CODE>x</CODE> as a type expression for <CODE>i</CODE>'s declaration.</P>

<P>However, the <A href="grammar.html">JavaScript 2.0 grammar</A> makes semicolons optional in the following situations:</P>

<UL>
  <LI>Before any <CODE>}</CODE></LI>
  <LI>Before the <CODE>else</CODE> of an <CODE>if</CODE>-<CODE>else</CODE> statement</LI>
  <LI>Before the <CODE>while</CODE> of a <CODE>do</CODE>-<CODE>while</CODE> statement (but not before the <CODE>while</CODE>
    of a <CODE>while</CODE> statement)</LI>
  <LI>Before the end of the program</LI>
</UL>
<P>Semicolons are optional in these situations even if they would construct empty statements.</P>

<P>Line breaks are no longer significant in source code and are treated like any other white space. Special JavaScript 1.x
grammar productions that forbid line breaks after a <CODE>return</CODE> or prefix <CODE>++</CODE> or <CODE>--</CODE> now allow
line breaks in those places.</P>

<H2>Regular Expression Literals</H2>

<P>To support <A href="error-recovery.html">error recovery</A>, JavaScript 2.0's lexical grammar must be made independent
of its syntactic grammar. To make the lexical grammar independent of the syntactic grammar, JavaScript 2.0 determines whether
a <CODE>/</CODE> starts a regular expression or is a division (or <CODE>/=</CODE>) operator solely based on the previous token:</P>

<TABLE border=0 cellspacing=2 cellpadding=0>
<TR>
  <TH nowrap align=left><CODE>/</CODE> interpretation</TH>
  <TH nowrap align=left>Previous token</TH>
</TR>
<TR>
  <TD nowrap valign=top><CODE class=terminal-keyword>/</CODE> or <CODE class=terminal-keyword>/=</CODE> &nbsp;</TD>
  <TD><SPAN class=terminal>Identifier</SPAN> &nbsp; <SPAN class=terminal>Number</SPAN> &nbsp; <SPAN class=terminal>RegularExpression</SPAN>
    &nbsp; <SPAN class=terminal>String</SPAN><BR>
    <CODE class=terminal-keyword>!</CODE> &nbsp; <CODE class=terminal-keyword>)</CODE> &nbsp; <CODE class=terminal-keyword>++</CODE>
    &nbsp; <CODE class=terminal-keyword>--</CODE> &nbsp; <CODE class=terminal-keyword>..</CODE> &nbsp; <CODE class=terminal-keyword>...</CODE>
    &nbsp; <CODE class=terminal-keyword>]</CODE> &nbsp; <CODE class=terminal-keyword>}</CODE> &nbsp; <CODE class=terminal-keyword>~</CODE><BR>
    <CODE class=terminal-keyword>false</CODE> &nbsp; <CODE class=terminal-keyword>null</CODE> &nbsp; <CODE class=terminal-keyword>super</CODE>
    &nbsp; <CODE class=terminal-keyword>this</CODE> &nbsp; <CODE class=terminal-keyword>true</CODE><BR>
    <CODE class=terminal-keyword>constructor</CODE> &nbsp; <CODE class=terminal-keyword>getter</CODE> &nbsp; <CODE class=terminal-keyword>method</CODE>
    &nbsp; <CODE class=terminal-keyword>override</CODE> &nbsp; <CODE class=terminal-keyword>setter</CODE> &nbsp; <CODE class=terminal-keyword>traditional</CODE>
    &nbsp; <CODE class=terminal-keyword>version</CODE><BR>
    Any other punctuation</TD>
</TR>
<TR>
  <TD nowrap valign=top><SPAN class=terminal>RegularExpression</SPAN> &nbsp;</TD>
  <TD><CODE class=terminal-keyword>!=</CODE> &nbsp; <CODE class=terminal-keyword>!==</CODE> &nbsp; <CODE class=terminal-keyword>#</CODE>
    &nbsp; <CODE class=terminal-keyword>%</CODE> &nbsp; <CODE class=terminal-keyword>%=</CODE> &nbsp; <CODE class=terminal-keyword>&amp;</CODE>
    &nbsp; <CODE class=terminal-keyword>&amp;&amp;</CODE> &nbsp; <CODE class=terminal-keyword>&amp;&amp;=</CODE> &nbsp; <CODE class=terminal-keyword>&amp;=</CODE>
    &nbsp; <CODE class=terminal-keyword>(</CODE> &nbsp; <CODE class=terminal-keyword>*</CODE> &nbsp; <CODE class=terminal-keyword>*=</CODE>
    &nbsp; <CODE class=terminal-keyword>+</CODE> &nbsp; <CODE class=terminal-keyword>+=</CODE> &nbsp; <CODE class=terminal-keyword>,</CODE>
    &nbsp; <CODE class=terminal-keyword>-</CODE> &nbsp; <CODE class=terminal-keyword>-=</CODE> &nbsp; <CODE class=terminal-keyword>-&gt;</CODE>
    &nbsp; <CODE class=terminal-keyword>.</CODE> &nbsp; <CODE class=terminal-keyword>/</CODE> &nbsp; <CODE class=terminal-keyword>/=</CODE>
    &nbsp; <CODE class=terminal-keyword>:</CODE> &nbsp; <CODE class=terminal-keyword>::</CODE> &nbsp; <CODE class=terminal-keyword>;</CODE>
    &nbsp; <CODE class=terminal-keyword>&lt;</CODE> &nbsp; <CODE class=terminal-keyword>&lt;&lt;</CODE> &nbsp; <CODE class=terminal-keyword>&lt;&lt;=</CODE>
    &nbsp; <CODE class=terminal-keyword>&lt;=</CODE> &nbsp; <CODE class=terminal-keyword>=</CODE> &nbsp; <CODE class=terminal-keyword>==</CODE>
    &nbsp; <CODE class=terminal-keyword>===</CODE> &nbsp; <CODE class=terminal-keyword>&gt;</CODE> &nbsp; <CODE class=terminal-keyword>&gt;=</CODE>
    &nbsp; <CODE class=terminal-keyword>&gt;&gt;</CODE> &nbsp; <CODE class=terminal-keyword>&gt;&gt;=</CODE> &nbsp; <CODE class=terminal-keyword>&gt;&gt;&gt;</CODE>
    &nbsp; <CODE class=terminal-keyword>&gt;&gt;&gt;=</CODE> &nbsp; <CODE class=terminal-keyword>?</CODE> &nbsp; <CODE class=terminal-keyword>@</CODE>
    &nbsp; <CODE class=terminal-keyword>[</CODE> &nbsp; <CODE class=terminal-keyword>^</CODE> &nbsp; <CODE class=terminal-keyword>^=</CODE>
    &nbsp; <CODE class=terminal-keyword>^^</CODE> &nbsp; <CODE class=terminal-keyword>^^=</CODE> &nbsp; <CODE class=terminal-keyword>{</CODE>
    &nbsp; <CODE class=terminal-keyword>|</CODE> &nbsp; <CODE class=terminal-keyword>|=</CODE> &nbsp; <CODE class=terminal-keyword>||</CODE>
    &nbsp; <CODE class=terminal-keyword>||=</CODE><BR>
    <CODE class=terminal-keyword>abstract</CODE> &nbsp; <CODE class=terminal-keyword>break</CODE> &nbsp; <CODE class=terminal-keyword>case</CODE>
    &nbsp; <CODE class=terminal-keyword>catch</CODE> &nbsp; <CODE class=terminal-keyword>class</CODE> &nbsp; <CODE class=terminal-keyword>const</CODE>
    &nbsp; <CODE class=terminal-keyword>continue</CODE> &nbsp; <CODE class=terminal-keyword>debugger</CODE> &nbsp; <CODE class=terminal-keyword>default</CODE>
    &nbsp; <CODE class=terminal-keyword>delete</CODE> &nbsp; <CODE class=terminal-keyword>do</CODE> &nbsp; <CODE class=terminal-keyword>else</CODE>
    &nbsp; <CODE class=terminal-keyword>enum</CODE> &nbsp; <CODE class=terminal-keyword>export</CODE> &nbsp; <CODE class=terminal-keyword>extends</CODE>
    &nbsp; <CODE class=terminal-keyword>field</CODE> &nbsp; <CODE class=terminal-keyword>final</CODE> &nbsp; <CODE class=terminal-keyword>finally</CODE>
    &nbsp; <CODE class=terminal-keyword>for</CODE> &nbsp; <CODE class=terminal-keyword>function</CODE> &nbsp; <CODE class=terminal-keyword>goto</CODE>
    &nbsp; <CODE class=terminal-keyword>if</CODE> &nbsp; <CODE class=terminal-keyword>implements</CODE> &nbsp; <CODE class=terminal-keyword>import</CODE>
    &nbsp; <CODE class=terminal-keyword>in</CODE> &nbsp; <CODE class=terminal-keyword>instanceof</CODE> &nbsp; <CODE class=terminal-keyword>native</CODE>
    &nbsp; <CODE class=terminal-keyword>new</CODE> &nbsp; <CODE class=terminal-keyword>package</CODE> &nbsp; <CODE class=terminal-keyword>private</CODE>
    &nbsp; <CODE class=terminal-keyword>protected</CODE> &nbsp; <CODE class=terminal-keyword>public</CODE> &nbsp; <CODE class=terminal-keyword>return</CODE>
    &nbsp; <CODE class=terminal-keyword>static</CODE> &nbsp; <CODE class=terminal-keyword>switch</CODE> &nbsp; <CODE class=terminal-keyword>synchronized</CODE>
    &nbsp; <CODE class=terminal-keyword>throw</CODE> &nbsp; <CODE class=terminal-keyword>throws</CODE> &nbsp; <CODE class=terminal-keyword>transient</CODE>
    &nbsp; <CODE class=terminal-keyword>try</CODE> &nbsp; <CODE class=terminal-keyword>typeof</CODE> &nbsp; <CODE class=terminal-keyword>var</CODE>
    &nbsp; <CODE class=terminal-keyword>volatile</CODE> &nbsp; <CODE class=terminal-keyword>while</CODE> &nbsp; <CODE class=terminal-keyword>with</CODE></TD>
</TR>
</TABLE>

<P>Regardless of the previous token, <CODE>//</CODE> is interpreted as the beginning of a comment.</P>

<P>The only controversial choices are <CODE class=terminal-keyword>)</CODE> and <CODE class=terminal-keyword>}</CODE>. A <CODE>/</CODE>
after either a <CODE class=terminal-keyword>)</CODE> or <CODE class=terminal-keyword>}</CODE> token can be either a division
symbol (if the <CODE class=terminal-keyword>)</CODE> or <CODE class=terminal-keyword>}</CODE> closes a subexpression or an
object literal) or a regular expression token (if the <CODE class=terminal-keyword>)</CODE> or <CODE class=terminal-keyword>}</CODE>
closes a preceding statement or an <CODE>if</CODE>, <CODE>while</CODE>, or <CODE>for</CODE> expression). Having <CODE>/</CODE>
be interpreted as a <SPAN class=terminal>RegularExpression</SPAN> in expressions such as <CODE>(x+y)/2</CODE> would be problematic,
so it is interpreted as a division operator after <CODE class=terminal-keyword>)</CODE> or <CODE class=terminal-keyword>}</CODE>.
If one wants to place a regular expression literal at the very beginning of an expression statement, it's best to put the
regular expression in parentheses. Fortunately, this is not common since one usually assigns the result of the regular expression
operation to a variable.</P>

<P>A <SPAN class=terminal>RegularExpression</SPAN> can also be specified unambiguously using <CODE>&laquo;</CODE> and <CODE>&raquo;</CODE>
as its opening and closing delimiters instead of <CODE>/</CODE> and <CODE>/</CODE>. For example, <CODE>&laquo;3*&raquo;</CODE>
is a regular expression that matches zero or more <CODE>3</CODE>'s. Such a regular expression can be empty: <CODE>&laquo;&raquo;</CODE>
is a regular expression that matches only the empty string, while <CODE>//</CODE> starts a comment.</P>

<P>Making JavaScript 2.0's lexical grammar independent of its syntactic grammar significantly simplifies the language, removes
many ambiguities, and allow tools to easily process a JavaScript program and escape all instances of, say, <CODE>&lt;/</CODE>
to properly embed a JavaScript 2.0 program in an HTML page. In JavaScript 1.x such a tool is not practical because it requries
a full parser of the langauge to distinguish an unquoted <CODE>&lt;/</CODE> from one inside a string or one in a regular expression.
The full parser changes for each version of JavaScript. To illustrate the difficulties, compare such JavaScript 1.4 gems as:</P>

<PRE>for (var x = a in foo &amp;&amp; "&lt;/x&gt;" || mot ? z:/x:3;x&lt;5;y&lt;/g/i) {xyz(x++);}
for (var x = a in foo &amp;&amp; "&lt;/x&gt;" || mot ? z/x:3;x&lt;5;y&lt;/g/i) {xyz(x++);}</PRE>

<HR>
<TABLE width="100%" border=0 cellspacing=2 cellpadding=0>
  <TR>
    <TD valign=BOTTOM nowrap>
      <ADDRESS><A href="mailto:waldemar@netscape.com">Waldemar Horwat</A><BR>
      Last modified Monday, March 22, 1999</ADDRESS>
    </TD>
    <TD valign=TOP nowrap align=RIGHT><A href="operator-overloading.html"><IMG src="../arrows/left.gif" align=BOTTOM width=37 height=37 alt="previous"></A><A href="index.html"><IMG src="../arrows/up.gif" align=BOTTOM width=37 height=37 alt="up"></A><A href="expressions.html"><IMG src="../arrows/right.gif" align=BOTTOM width=37 height=37 alt="next"></A></TD>
  </TR>
</TABLE>
</BODY>
</HTML>
