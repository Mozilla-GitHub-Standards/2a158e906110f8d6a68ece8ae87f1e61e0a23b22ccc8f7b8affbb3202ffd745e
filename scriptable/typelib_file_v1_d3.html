<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.5 [en] (WinNT; U) [Netscape]">
   <meta name="Author" content="Scott Furman">
   <title>XPCOM Type Library File Format, Version 1.0</title>
</head>
<body bgcolor="#FFFFFF">

<center>
<h1>
XPCOM Type Library<br>
File Format</h1></center>

<center>
<h4>
Version 1.0, Draft 3</h4></center>

<center>Last updated:&nbsp;<script>
document.write(document.lastModified);
</script>

<br>Author: <a href="mailto:fur@netscape.com">Scott Furman &lt;fur@netscape.com></a></center>

<p>
Latest version:<br> 
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://mozilla.org/scriptable/typelib_file.html">http://mozilla.org/scriptable/typelib_file.html</a>
</p>

<h3>
Document History</h3>

<blockquote>
<h4>Draft 3 (1/5/98) -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d3.html">http://mozilla.org/scriptable/typelib_file_v1_d3.html</a></h4>
</blockquote>

<blockquote>
<blockquote>
<li>
Added 'retval' flag and massaged description of 'in' and 'out' flags in
the ParamDescriptor record.</li>

<li>
Fixed errors in descriptions of 'params' and 'result' members of the MethodDescriptor
and in the description of 'method_descriptors' and 'const_descriptors'
members of the InterfaceDescriptor record.&nbsp; (In all cases, these members
were incorrectly described as byte offsets to other records even though
the data layout notation indicated that they were stored inline.)</li>
</blockquote>

<h4>Draft 2 (12/16/98) -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d2.html">http://mozilla.org/scriptable/typelib_file_v1_d2.html</a></h4>

<blockquote>
<li>
Added "Document History" and "Known Issues" sections.</li>

<li>
Tweaked introduction.</li>

<li>
Changed pointers to InterfaceDescriptor records to instead point to InterfaceDirectoryEntry's
so as to allow late-binding of interfaces using only the interface name.&nbsp;
The interface name was moved from the InterfaceDescriptor to the InterfaceDirectoryEntry
for the same reason.</li>

<li>
Changed the description of the parent_interface field of InterfaceDescriptor
so that its use is not optional.</li>

<li>
Updated is_getter and is_setter text to be less confusing about whether
or not method name prefixes are stored for getters and setters.&nbsp; (They're
not.)</li>

<li>
Added is_varargs and is_constructor flags to MethodDescriptor.</li>

<li>
Added support for scoped interface constants.</li>

<li>
Nearly all uses of the String record type were changed to Identifier.&nbsp;
Identifiers are NUL-terminated UTF-8 string records.&nbsp; That means you
can't store embedded NUL characters in an identifier (method or interface
name), but they're one byte shorter because the string length isn't stored
as part of the record.</li>

<li>
Added support for private data to be attached to typelib files (Annotation
records)</li>
</blockquote>
<h4>Draft 1 (12/13/98) -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d1.html">http://mozilla.org/scriptable/typelib_file_v1_d1.html</a></h4>
</blockquote>

<h3>
Known Issues</h3>

<ul>
<li>
All opaque pointers (using the 'native' keyword in XPIDL) are represented
as <tt>void*</tt> pointers in the typelib.&nbsp; That doesn't give us any
type safety in terms of passing such pointers around with JS or other languages.&nbsp;
Should we just disallow methods that use the <tt>void*</tt> type for XPCOMConnect
?&nbsp; Or should we attach type information to the typelib instead of
using <tt>void*</tt> ?</li>

<li>
If we allow late-binding of interface name to IID, how do we avoid collisions
in interface names ?&nbsp; Do we need to add some sort of interface namespace
?&nbsp; Or do we just require developers to link their typelibs in the
correct order ?</li>

<li>
There is no support yet in the typelib for pointers to unions or structs.&nbsp;
Also no support for arrays or array slices.</li>

<li>
We need a way to represent a pointer to an nsVarArgs struct as an argument
to a method.&nbsp; (This structure is used to collect arguments after the
last fixed argument.)&nbsp; There is, as of yet, no way to represent structs
in the typelib.&nbsp; For now, we could maybe lie and call it a void *.&nbsp;
Or we could add a special-case TypeDescriptor for this, as we did for <tt>nsIID*</tt>.</li>

<li>
The common string type(s) that will be passed around in XPCOM methods still
seems to be up in the air.&nbsp; (nsString, nsIString, STL strings, ?)&nbsp;
Until that's resolved, the TypeDescriptor just uses "string" to represent
that type.&nbsp; Depending on what's decided, we may end up adding more
than one string type.</li>
</ul>

<h3>
Introduction</h3>
XPCOM type libraries, or "typelibs", are binary interface description files
generated by the <a href="xpidl/index.html">XPIDL</a> compiler. Type libraries
enumerate the methods of one or more interfaces, including detailed type
information for each method parameter. The typelib is not merely a tokenized
form of the IDL.&nbsp; Rather, it's intended to accurately represent binary
XPCOM interfaces, with annotations derived from the IDL.
<p>Typelibs might be more aptly named "interface libraries", but Microsoft
has already established a precedent with their naming scheme and we'll
stick with it to avoid developer confusion.
<h3>
Goals</h3>

<ul>
<li>
Represent all type information that is required for <a href="index.html">XPCOMConnect</a>
to enable access to COM objects from JS and vice-versa</li>

<li>
Map an IID to an interface description quickly</li>

<li>
Allow for efficiency when interfaces are sparsely used, i.e. without requiring
the entire typelib to be parsed or retained in memory.</li>

<li>
Use a compact file format, so as to accommodate hundreds of interfaces
and thousands of methods.</li>

<li>
Allow for extensibility, so as to accommodate future additions to XPIDL</li>
</ul>

<h3>
Non-goals</h3>

<ul>
<li>
Ability to reconstruct XPIDL source from type library</li>

<li>
Human-readable format</li>

<li>
File-level compatibility with MS typelibs</li>
</ul>

<h3>
Notation</h3>
The syntax used in this document to specify the layout of file data appears
similar to C structs. Unlike C structs, however, data members are not subject
to alignment restrictions.&nbsp; Another difference from C structs is the
use of pointer notation to represent 32-bit file offsets. For example,
<ul><tt>uint16 *ByteOffsetTo16BitValue</tt></ul>
specifies a 32-bit field that contains the offset, in bytes to an array
of one or more 16-bit values.&nbsp;&nbsp; Unless otherwise noted, all file
offsets are byte offsets from the beginning of the <a href="#data_pool">data
pool</a>&nbsp; and are 32-bit signed quantities.&nbsp; The first byte of
the data pool is at offset 1, so as to allow offset 0 to be used as a special
indicator.&nbsp; By adding in an appropriate constant, these offsets are
appropriate as arguments to <tt>seek()</tt>.
<p>Record fields with type <tt>boolean</tt> occupy one bit, not one byte.&nbsp;
A value of 1 represents true and a value of 0 represents false.
<p>All integer fields with multibyte precision are stored in little-endian
order, e.g. for a uint16 field, the low-order byte is stored in the file
followed by the high-order byte.
<h3>
Filename Suffix</h3>
The standard suffix for XPCOM type libraries is <tt>.xpt</tt>.<i> [Editor:
Do we need to define a standard four-character Mac signature/creator ?]</i>
<h3>
<a NAME="File_Header"></a>File Header</h3>
Every XPCOM typelib file begins with a header:
<blockquote>
<pre><tt>TypeLibHeader {
&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#magic">magic[16]</a>;
&nbsp;&nbsp;&nbsp; uint8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#version">major_version</a>;
&nbsp;&nbsp;&nbsp; uint8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#version">minor_version</a>;
&nbsp;&nbsp;&nbsp; uint16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#num_interfaces">num_interfaces</a>;
&nbsp;&nbsp;&nbsp; uint32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#file_length">file_length</a>;
&nbsp;&nbsp;&nbsp; <a href="#InterfaceDirectoryEntry">InterfaceDirectoryEntry</a>* <a href="#InterfaceDirectoryEntry">interface_directory</a>;
&nbsp;&nbsp;&nbsp; uint8*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#data_pool">data_pool</a>;

&nbsp;&nbsp;&nbsp; <a href="#Annotation">Annotation</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#FileHeader_annotations">annotations</a>[];
}</tt></pre>
</blockquote>

<h4>
<a NAME="magic"></a><tt>magic</tt></h4>

<blockquote>The first 16 bytes of the file always contain the following
values:
<pre><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (hex) 58 50 43 4f 4d 0a 54 79 70 65 4c 69 62&nbsp; 0d 0a&nbsp;&nbsp; 1a
(C notation)&nbsp; X&nbsp; P&nbsp; C&nbsp; O&nbsp; M \n&nbsp; T&nbsp; y&nbsp; p&nbsp; e&nbsp; L&nbsp; i&nbsp; b&nbsp; \r \n \032</font></tt></pre>
This signature both identifies the file as an XPCOM typelib file and provides
for immediate detection of common file-transfer problems, i.e. treatment
of a binary file as if it was a text file. The CR-LF sequence catches file
transformations that alter newline sequences. The control-Z character stops
file display under MS-DOS. The linefeed in the sixth character checks for
the inverse of the CR-LF translation problem. (<i>A nod to the PNG folks
for the inspiration behind using these special characters in the header.</i>)</blockquote>

<h4>
<a NAME="version"></a><tt>major_version, minor_version</tt></h4>

<blockquote>These are the major and minor version numbers of the typelib
file format. For this specification <tt>major_version</tt> is 0x01 and
<tt>minor_version</tt>
is 0x00. TypeLib files that share the same major version but have different
minor versions are compatible. Changes to the major version represent typelib
file formats that are not backward-compatible with parsers designed only
to read earlier major versions. If a typelib file is encountered with a
major version for which support is not available, the rest of the file
should not be parsed.</blockquote>

<h4>
<a NAME="num_interfaces"></a><tt>num_interfaces</tt></h4>

<blockquote>This indicates the number of <a href="#InterfaceDirectoryEntry">InterfaceDirectoryEntry</a>
records that are at the offset indicated by the <tt>interface_directory</tt>
field.</blockquote>

<h4>
<a NAME="interface_directory"></a><tt>interface_directory</tt></h4>

<blockquote>This field specifies a zero-relative byte offset from the beginning
of the file.&nbsp; It identifies the start of an array of InterfaceDirectoryEntry
records.&nbsp; If <tt>num_interfaces</tt> is zero, then this field should
also be zero.&nbsp; The value of this field should be a multiple of 4,
i.e. the interface directory must be aligned on a 4-byte boundary.&nbsp;
(This is to guarantee aligned access if the typelib file is mmap'ed into
memory.)</blockquote>

<h4>
<a NAME="file_length"></a><tt>file_length</tt></h4>

<blockquote>Total length of the typelib file, in bytes. This value can
be compared to the length of the file reported by the OS so as to detect
file truncation.</blockquote>

<h4>
<a NAME="data_pool"></a><tt>data_pool</tt></h4>

<blockquote>The data pool is a heap-like storage area that is the container
for most kinds of typelib data including, but not limited to <a href="#InterfaceDescriptor">InterfaceDescriptor</a>,
<a href="#MethodDescriptor">MethodDescriptor</a>,
<a href="#ParamDescriptor">ParamDescriptor</a>,
and <a href="#TypeDescriptor">TypeDescriptor</a> records.&nbsp; Note that,
unlike most file offsets in a typelib, the value of <tt>data_pool</tt>
is zero-relative to the beginning of the file.</blockquote>

<h4>
<a NAME="FileHeader_annotations"></a><tt>annotations</tt></h4>

<blockquote>A variable-length array of variable-size records used to store
secondary information, e.g. such as the name of the tool that generated
the typelib file, the date it was generated, etc.</blockquote>

<h3>
<a NAME="InterfaceDirectoryEntry"></a>InterfaceDirectoryEntry</h3>
A contiguous array of fixed-size InterfaceDirectoryEntry records begins
at the byte offset identified by the <tt><a href="#interface_directory">interface_directory</a></tt>
field in the <a href="#File_Header">file header</a>.&nbsp; The array is
used to quickly locate an interface description using its IID.&nbsp; No
interface should appear more than once in the array.
<blockquote>
<pre><tt>InterfaceDirectoryEntry {
&nbsp;&nbsp;&nbsp; uint128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#iid">iid</a>;
&nbsp;&nbsp;&nbsp; <a href="#Identifier">Identifier</a>*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#InterfaceDirectoryEntry_name">name</a>;
&nbsp;&nbsp;&nbsp; <a href="#InterfaceDescriptor">InterfaceDescriptor</a>* <a href="#interface_descriptor">interface_descriptor</a>;
}</tt></pre>
</blockquote>
An interface is said to be unresolved if its name is known, e.g. "nsISupports",
but its IID and methods have not yet been determined.&nbsp; In that case,
both the <tt>iid</tt> and the <tt>interface_descriptor</tt> field will
be set to zero.&nbsp; If an interface is unresolved it must be linked with
another typelib to resolve the interface, one that contains a resolved
InterfaceDirectoryEntry for the interface in question.
<p>A pointer to an InterfaceDirectoryEntry is always relative to the beginning
of the file.&nbsp; (This is different from other pointers in the typelib
file, which are relative to the byte immediately before the <a href="#data_pool">data
pool</a>.)
<h4>
<a NAME="iid"></a><tt>iid</tt></h4>

<blockquote>The iid field contains a 128-bit value representing the interface
ID. The iid is created from an IID by concatenating the individual bytes
of an IID in a particular order. For example, this IID:
<blockquote><tt>{00112233-4455-6677-8899-aabbccddeeff}</tt></blockquote>
is converted to the 128-bit value
<blockquote><tt>0xffeeddccbbaa88996677445500112233</tt></blockquote>
Note that the byte storage order corresponds to the layout of the nsIID
C-struct on a little-endian architecture.
<p>All InterfaceDirectoryEntry objects must appear sorted in increasing
order of iid, so as to facilitate a binary search of the array.&nbsp; (This
means that unresolved interfaces appear at the beginning of the array.)</blockquote>

<h4>
<a NAME="InterfaceDirectoryEntry_name"></a><tt>name</tt></h4>

<blockquote>The human-readable name of this interface, e.g. "nsISupports",
stored using the <a href="#Identifier">Identifier</a> record format.</blockquote>

<h4>
<a NAME="interface_descriptor"></a><tt>interface_descriptor</tt></h4>

<blockquote>This is a byte offset from the beginning of the file to the
corresponding InterfaceDescriptor object.</blockquote>

<h3>
<a NAME="InterfaceDescriptor"></a>InterfaceDescriptor</h3>
An InterfaceDescriptor is a variable-size record used to describe a single
XPCOM interface, including all of its methods:
<blockquote>
<pre><tt>InterfaceDescriptor {
&nbsp;&nbsp;&nbsp; <a href="#InterfaceDirectoryEntry">InterfaceDirectoryEntry</a>* <a href="#parent_interface">parent_interface</a>;
&nbsp;&nbsp;&nbsp; uint16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#num_methods">num_methods</a>;
&nbsp;&nbsp;&nbsp; <a href="#MethodDescriptor">MethodDescriptor</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#method_descriptors">method_descriptors</a>[num_methods];
&nbsp;&nbsp;&nbsp; uint16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#num_constants">num_constants</a>;
&nbsp;&nbsp;&nbsp; ConstDescriptor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#const_descriptors">const_descriptors</a>[num_constants];
}</tt></pre>
</blockquote>

<h4>
<a NAME="parent_interface"></a><tt>parent_interface</tt></h4>

<blockquote>An interface's methods are specified by composing the methods
of an interface from which it is derived with additional methods it defines.&nbsp;
The <tt>method_descriptors</tt> array does not list any methods that the
interface inherits from its parent and the <tt>parent_interface</tt> field
contains a byte offset, relative to the beginning of the file, to the InterfaceDirectoryEntry
of its parent interface.&nbsp; This field has a value for nsISupports,
the root of the interface inheritance hierarchy.</blockquote>

<h4>
<a NAME="num_methods"></a><tt>num_methods</tt></h4>

<blockquote>The number of methods in the <tt>method_descriptors</tt> array.</blockquote>

<h4>
<a NAME="method_descriptors"></a><tt>method_descriptors</tt></h4>

<blockquote>This is an inline array of MethodDescriptor objects.&nbsp;
The length of the array is determined by the <tt>num_methods</tt> field.</blockquote>

<h4>
<a NAME="num_constants"></a><tt>num_constants</tt></h4>

<blockquote>The number of scoped interface constants in the <tt>const_descriptors</tt>
array.</blockquote>

<h4>
<a NAME="const_descriptors"></a><tt>const_descriptors</tt></h4>

<blockquote>This is an inline array of ConstDescriptor objects.&nbsp; The
length of the array is determined by the <tt>num_constants</tt> field.</blockquote>

<h3>
<a NAME="ConstDescriptor"></a>ConstDescriptor</h3>
A ConstDescriptor is a variable-size record that records the name and value
of a scoped interface constant.&nbsp; All ConstDescriptor records have
this form:
<blockquote><tt>ConstDescriptor {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Identifier*&nbsp;&nbsp;&nbsp;&nbsp; <a href="#ConstDescriptor_name">name</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; TypeDescriptor&nbsp; <a href="#ParamDescriptor_type">type</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &lt;type>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#ConstDescriptor_value">value</a>;</tt>
<br><tt>}</tt></blockquote>

<h4>
<a NAME="ConstDescriptor_name"></a><tt>name</tt></h4>

<blockquote>The human-readable name of this constant, stored in the <a href="#Identifier">Identifier</a>
record format.</blockquote>

<h4>
<a NAME="ConstDescriptor_type"></a><tt>type</tt></h4>

<blockquote>The type of the method parameter.&nbsp; Types are restricted
to the following subset of TypeDescriptors: <tt>int8, uint8, int16, uint16,
int32, uint32, int64, uint64, wchar_t, char, string</tt></blockquote>

<h4>
<a NAME="ConstDescriptor_value"></a><tt>value</tt></h4>

<blockquote>The type (and thus the size) of the <tt>value</tt> record is
determined by the contents of the associated TypeDescriptor record.&nbsp;
For instance, if <tt>type</tt> corresponds to <tt>int16</tt>, then <tt>value</tt>
is a two-byte record consisting of a 16-bit signed integer.&nbsp; For a
ConstDescriptor type of <tt>string</tt>, the <tt>value</tt> record is of
type <a href="#String">String</a>*, i.e. an offset within the data pool
to a String record containing the constant string.</blockquote>

<h3>
<a NAME="MethodDescriptor"></a>MethodDescriptor</h3>
A MethodDescriptor is a variable-size record used to describe a single
interface method:
<blockquote>
<pre><tt>MethodDescriptor {
&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#is_getter">is_getter</a>;
&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#is_getter">is_setter</a>;
&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#is_varargs">is_varargs</a>;
&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#is_constructor">is_constructor</a>;
&nbsp;&nbsp;&nbsp; uint4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reserved;
&nbsp;&nbsp;&nbsp; Identifier*&nbsp;&nbsp;&nbsp;&nbsp; <a href="#MethodDescriptor_name">name</a>;
&nbsp;&nbsp;&nbsp; uint8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#num_args">num_args</a>;
&nbsp;&nbsp;&nbsp; ParamDescriptor <a href="#params">params</a>[num_args];
&nbsp;&nbsp;&nbsp; ParamDescriptor <a href="#result">result</a>;
}</tt></pre>
</blockquote>

<h4>
<a NAME="is_getter"></a><tt>is_getter</tt></h4>

<blockquote>This field is used to allow interface methods to act as property
getters for object-oriented languages such as JavaScript.&nbsp; It could
be set as a result of defining an XPIDL attribute.&nbsp; For example, if
there was an XPIDL attribute named "Banjo",&nbsp; you could access the
"Banjo" property on an interface like so: 'myInterface.Banjo'.&nbsp; Any
prefix added&nbsp; by the XPIDL compiler to an attribute's&nbsp; identifier
in the .h file, such as "Is" or "Get" should not appear in the method's
<tt>name</tt>.</blockquote>

<h4>
<a NAME="is_getter"></a><tt>is_setter</tt></h4>

<blockquote>This field is used to allow interface methods to act as property
setters for object-oriented languages such as JavaScript.&nbsp; It could
be set as a result of defining an XPIDL attribute.&nbsp; For example, if
there was an XPIDL attribute named "Banjo",&nbsp; you could assign to the
"Banjo" property on an interface like so: 'myInterface.Banjo = 3'.&nbsp;
Any prefix added&nbsp; by the XPIDL compiler to an attribute's&nbsp; identifier
in the .h file, such as "Is" or "Get" should not appear in the method's
<tt>name</tt>.</blockquote>

<h4>
<a NAME="is_varargs"></a><tt>is_varargs</tt></h4>

<blockquote>If set, <tt>is_varargs</tt> indicates that the method is designed
to accept a variable number of arguments from, say, a scripting language.&nbsp;
The exact details of how this might be done, however, is beyond the scope
of the typelib definition.&nbsp; (With XPComConnect, an nsVarArgs object
is passed as the last parameter to such a method.&nbsp; That object is
a variable length array of argument values and types.)</blockquote>

<h4>
<a NAME="is_constructor"></a><tt>is_constructor</tt></h4>

<blockquote>This field indicates the default constructor for this interface,
which may be useful for interfaces that act like factories.&nbsp; For example,
with an instance of an XPCOM interface named 'Foo', in JavaScript one might
write 'new Foo(arg1, arg2)', thus calling this interface to be called;&nbsp;
The argument signature of an XPCOM constructor is:
<blockquote><tt><font size=-1>NS_IRESULT ([arg,]*, out nsIID** result_type,
out nsISupports** result)</font></tt></blockquote>
That is, it's a function that takes zero or more arguments and creates
a new interface returned through <tt>result</tt> with a type identified
by the <tt>result_type</tt> output parameter.</blockquote>

<h4>
<a NAME="MethodDescriptor_name"></a><tt>name</tt></h4>

<blockquote>The human-readable name of this method, e.g. "getWindow", stored
in the <a href="#Identifier">Identifier</a> record format.</blockquote>

<h4>
<a NAME="num_args"></a><tt>num_args</tt></h4>

<blockquote>The number of arguments that the method consumes.&nbsp; Also,
the number of elements in the <tt>params</tt> array.</blockquote>

<h4>
<a NAME="params"></a><tt>params</tt></h4>

<blockquote>This is an inline array of <a href="#ParamDescriptor">ParamDescriptor</a>
objects.&nbsp; The length of the array is determined by the <tt>num_args</tt>
field.</blockquote>

<h4>
<a NAME="result"></a><tt>result</tt></h4>

<blockquote>This is a single, inline <a href="#ParamDescriptor">ParamDescriptor</a>
object that identifies the actual return type of an XPCOM method.&nbsp;
The result, however, does not always refer to the effective method return
value when the invocation is from a scripting language, i.e. the return
value as seen from a script-writer's perspective.&nbsp; In particular,
it is possible to designate any <a href="#param_out">out</a> method argument
as the method return value for scripting purposes.&nbsp; See the <a href="#param_retval">retval</a>
flag.</blockquote>

<h3>
<a NAME="ParamDescriptor"></a>ParamDescriptor</h3>
A ParamDescriptor is a variable-size record used to describe either a single
argument to a method or a method's result:
<blockquote>
<pre><tt>ParamDescriptor {
&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#param_in">in</a>;
&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#param_out">out</a>;
&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#param_retval">retval</a>;
&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#reserved6">reserved</a>;
&nbsp;&nbsp;&nbsp; TypeDescriptor&nbsp; <a href="#ParamDescriptor_type">type</a>;
}</tt></pre>
</blockquote>

<h4>
<a NAME="param_in"></a><tt>in</tt></h4>

<blockquote>If <tt>in</tt> is true, it indicates that the parameter is
to be passed from caller to callee.&nbsp; This flag is always false for
a method's <a href="#result">result</a>.</blockquote>

<h4>
<a NAME="param_out"></a><tt>out</tt></h4>

<blockquote>If <tt>out</tt> is true, it indicates that the parameter is
to be passed from callee to caller.&nbsp; It is possible for a parameter
to have both <tt>out</tt> and
<tt>in</tt> bits set.&nbsp; For the actual
method <a href="#result">result</a>, <tt>out</tt> is always true.&nbsp;
Out parameters that are method arguments must always have a pointer type.</blockquote>

<h4>
<a NAME="param_retval"></a><tt>retval</tt></h4>

<blockquote>If <tt>retval</tt> is true, it indicates that this parameter
is to be considered the return value of the method for purposes of invocation
from a scripting language.&nbsp; If the XPCOM method's <a href="#result">result</a>
parameter does not have its <tt>retval</tt> flag set, then the method's
return value is either void or an nsresult (a bitfield encoded as a uint32)
that indicates the success or failure of the method invocation.&nbsp; Note
that <tt>retval</tt> cannot be true unless <tt>out</tt> is also true.</blockquote>

<h4>
<a NAME="reserved6"></a><tt>reserved</tt></h4>

<blockquote>A 5-bit field reserved for future use.</blockquote>

<h4>
<a NAME="ParamDescriptor_type"></a><tt>type</tt></h4>

<blockquote>The type of the method parameter.</blockquote>

<h3>
<a NAME="TypeDescriptor"></a>TypeDescriptor</h3>
A TypeDescriptor is a variable-size record used to identify the type of
a method argument or return value.&nbsp; There are many XPCOM types that
need to be represented in the typelib:
<ul>
<li>
scalar types, e.g. uint16 or boolean</li>

<li>
pointer to a scalar type, e.g. float*</li>

<li>
generic opaque pointer, i.e. void*</li>

<li>
void (only allowed for method return type)</li>

<li>
interface pointer, or a pointer to an interface pointer</li>

<li>
iid_is - that is, an interface pointer with type determined at runtime,
or a pointer to such an interface pointer</li>

<li>
pointer to an nsIID structure (to act as the parameter to an iid_is)</li>
</ul>
[Editor: This specification does not yet cover pointers to unions, structs
or arrays.]
<p><a NAME="variant_TypeDescriptors"></a>To efficiently describe all the
type categories listed above, there are several different variants of TypeDescriptor
records:
<blockquote><tt>union TypeDescriptor {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; SimpleTypeDescriptor;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; InterfaceTypeDescriptor;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; InterfaceIsTypeDescriptor;</tt>
<br><tt>}</tt></blockquote>
The first byte of all these TypeDescriptor variants has the identical layout:
<blockquote><tt>TypeDescriptorPrefix {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_pointer">is_pointer</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_unique_pointer">is_unique_pointer</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_reference">is_reference</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;&nbsp; <a href="#tag">tag</a>;</tt>
<br><tt>}</tt></blockquote>

<h4>
<a NAME="is_pointer"></a><tt>is_pointer</tt></h4>

<blockquote>This field is true only when representing C pointer/reference
types.</blockquote>

<h4>
<a NAME="is_unique_pointer"></a><tt>is_unique_pointer</tt></h4>

<blockquote>This field cannot have a value of true unless <tt>is_pointer</tt>
is also true.&nbsp; The <tt>unique_pointer</tt> field indicates if the
parameter value can be aliased to another parameter value.&nbsp; If <tt>unique_pointer</tt>
is true, it must not be possible to reach the memory pointed at by this
argument value from any other argument to the method.</blockquote>

<h4>
<a NAME="is_reference"></a><tt>is_reference</tt></h4>

<blockquote>This field cannot have a value of true unless <tt>is_pointer</tt>
is also true.&nbsp; This field is true if the parameter is a reference,
which is to say, it's a pointer that can't have a value of NULL.</blockquote>

<h4>
<a NAME="tag"></a><tt>tag</tt></h4>

<blockquote>The tag field indicates which of the <a href="#variant_TypeDescriptors">variant
TypeDescriptor records</a> is being used, and hence the way any remaining
fields should be parsed.
<br>&nbsp;
<table BORDER >
<tr BGCOLOR="#CCFFFF">
<td>
<center><b>&nbsp;Value in <tt>tag</tt> field&nbsp;</b></center>
</td>

<td>
<center><b>&nbsp;TypeDescriptor variant to use&nbsp;</b></center>
</td>
</tr>

<tr>
<td>
<center>0..15</center>
</td>

<td>
<center>SimpleTypeDescriptor</center>
</td>
</tr>

<tr>
<td>
<center>16</center>
</td>

<td>
<center>InterfaceTypeDescriptor</center>
</td>
</tr>

<tr>
<td>
<center>17</center>
</td>

<td>
<center>InterfaceIsTypeDescriptor</center>
</td>
</tr>

<tr>
<td>
<center>18..31</center>
</td>

<td>
<center>reserved</center>
</td>
</tr>
</table>
</blockquote>

<h3>
<a NAME="SimpleTypeDescriptor"></a>SimpleTypeDescriptor</h3>
The one-byte SimpleTypeDescriptor is a kind of <a href="#TypeDescriptor">TypeDescriptor</a>
used to represent scalar types,&nbsp; pointers to scalar types, the <tt>void</tt>
type,&nbsp; the <tt>void*</tt> type and, as a special case, the <tt>nsIID*</tt>
type:
<ul><tt>SimpleTypeDescriptor {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_pointer_and_tag">is_pointer</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_unique_pointer">is_unique_pointer</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_reference">is_reference</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;&nbsp; <a href="#is_pointer_and_tag">tag</a>;</tt>
<br><tt>}</tt></ul>

<h4>
<a NAME="is_pointer_and_tag"></a><tt>is_pointer, tag</tt></h4>

<ul>The <tt>is_pointer</tt> field is true only when representing C pointer/reference
types.&nbsp; The following table indicates the types that can be represented
by combining different values for these two fields:
<br>&nbsp;
<table BORDER WIDTH="80%" >
<tr BGCOLOR="#CCFFFF">
<td COLSPAN="3">
<center><b>&nbsp;SimpleTypeDescriptor</b></center>
</td>
</tr>

<tr BGCOLOR="#CCFFFF">
<td>
<center><b><tt>&nbsp;pointer&nbsp;</tt></b></center>
</td>

<td>
<center><b><tt>&nbsp;tag&nbsp;</tt></b></center>
</td>

<td>
<center><b>Type Represented</b></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>0</center>
</td>

<td>
<center><tt>int8</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>1</center>
</td>

<td>
<center><tt>int16</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>2</center>
</td>

<td>
<center><tt>int32</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>3</center>
</td>

<td>
<center><tt>int64</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>4</center>
</td>

<td>
<center><tt>uint8</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>5</center>
</td>

<td>
<center><tt>uint16</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>6</center>
</td>

<td>
<center><tt>uint32</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>7</center>
</td>

<td>
<center><tt>uint64</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>8</center>
</td>

<td>
<center><tt>float</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>9</center>
</td>

<td>
<center><tt>double</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>10</center>
</td>

<td>
<center><tt>boolean </tt>(8-bit value)</center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>11</center>
</td>

<td>
<center><tt>char</tt> (8-bit character)</center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>12</center>
</td>

<td>
<center><tt>wchar_t</tt> (16-bit character)</center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>13</center>
</td>

<td>
<center><tt>void</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>14</center>
</td>

<td>
<center>reserved</center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>15</center>
</td>

<td>
<center>reserved</center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>0</center>
</td>

<td>
<center><tt>int8*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>1</center>
</td>

<td>
<center><tt>int16*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>2</center>
</td>

<td>
<center><tt>int32*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>3</center>
</td>

<td>
<center><tt>int64*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>4</center>
</td>

<td>
<center><tt>uint8*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>5</center>
</td>

<td>
<center><tt>uint16*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>6</center>
</td>

<td>
<center><tt>uint32*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>7</center>
</td>

<td>
<center><tt>uint64*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>8</center>
</td>

<td>
<center><tt>float*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>9</center>
</td>

<td>
<center><tt>double*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>10</center>
</td>

<td>
<center><tt>boolean* </tt>(8-bit value)</center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>11</center>
</td>

<td>
<center><tt>char*</tt> (8-bit character)</center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>12</center>
</td>

<td>
<center><tt>wchar_t*</tt> (16-bit character)</center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>13</center>
</td>

<td>
<center><tt>void*</tt> (generic opaque pointer)</center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>14</center>
</td>

<td>
<center><tt>nsIID*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>15</center>
</td>

<td>
<center>string</center>
</td>
</tr>
</table>
</ul>

<h3>
<a NAME="InterfaceTypeDescriptor"></a>InterfaceTypeDescriptor</h3>
An InterfaceTypeDescriptor is used to represent either a pointer to an
interface type or a pointer to a pointer to an interface type, e.g. <tt>nsISupports*</tt>
or <tt>nsISupports**:</tt>
<blockquote><tt>InterfaceTypeDescriptor {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<a href="#InterfaceTypeDescriptor_is_pointer">is_pointer</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<a href="#is_unique_pointer">is_unique_pointer</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<a href="#is_reference">is_reference</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<a href="#InterfaceTypeDescriptor_tag">tag</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; InterfaceDirectoryEntry* <a href="#InterfaceTypeDescriptor_interface">interface</a>;</tt>
<br><tt>}</tt></blockquote>

<h4>
<a NAME="InterfaceTypeDescriptor_is_pointer"></a><tt>is_pointer</tt></h4>

<blockquote>When this field is false, the represented type is an interface
pointer.&nbsp; When <tt>is_pointer</tt> is true, the represented type is
a pointer to an interface pointer.</blockquote>

<h4>
<a NAME="InterfaceTypeDescriptor_tag"></a><tt>tag</tt></h4>

<blockquote>The tag field must have the decimal value 16.</blockquote>

<h4>
<a NAME="InterfaceTypeDescriptor_interface"></a>interface</h4>

<blockquote>A byte-offset, relative to the beginning of the file, which
indentifies the interface pointer's type.</blockquote>

<h3>
<a NAME="InterfaceIsTypeDescriptor"></a>InterfaceIsTypeDescriptor</h3>
An InterfaceIsTypeDescriptor describes an interface pointer type.&nbsp;
It is similar to an <a href="#InterfaceTypeDescriptor">InterfaceTypeDescriptor</a>
except that the type of the interface pointer is specified at runtime by
the value of another argument, rather than being specified by the typelib.
<blockquote>
<pre><tt>InterfaceIsTypeDescriptor {
&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#InterfaceTypeDescriptor_is_pointer">is_pointer</a>;
&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_unique_pointer">is_unique_pointer</a>;
&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_reference">is_reference</a>;
&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;&nbsp; <a href="#InterfaceIsTypeDescriptor_tag">tag</a>;
&nbsp;&nbsp;&nbsp; uint8&nbsp;&nbsp;&nbsp; <a href="#InterfaceIsTypeDescriptor_arg_num">arg_num</a>;
}</tt></pre>
</blockquote>

<h4>
<a NAME="InterfaceIsTypeDescriptor_tag"></a><tt>tag</tt></h4>

<blockquote>The tag field must have the decimal value 17.</blockquote>

<h4>
<a NAME="InterfaceIsTypeDescriptor_arg_num"></a><tt>arg_num</tt></h4>

<blockquote>The zero-based index of the method argument that describes
the type of the interface pointer.&nbsp; The specified method argument
must have type
<tt>nsIID*</tt>.</blockquote>

<h3>
<a NAME="Identifier"></a>Identifier</h3>
Identifier records are used to represent variable-length, human-readable
strings:
<blockquote><tt>Identifier {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; <a href="#InternedString_bytes">bytes</a>[];</tt>
<br><tt>}</tt></blockquote>

<h4>
<a NAME="InternedString_bytes"></a><tt>bytes</tt></h4>

<blockquote>Unicode string encoded in UTF-8 format, NUL-terminated.</blockquote>

<h3>
<a NAME="String"></a>String</h3>
String records are used to represent variable-length, human-readable strings,
possibly with embedded NUL's:
<blockquote><tt>String {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; uint16 <a href="#InternedString_length">length</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; <a href="#InternedString_bytes">bytes</a>[];</tt>
<br><tt>}</tt></blockquote>

<h4>
<a NAME="InternedString_length"></a><tt>length</tt></h4>

<blockquote>The length of the string, in characters (not bytes).</blockquote>

<h4>
<a NAME="InternedString_bytes"></a><tt>bytes</tt></h4>

<blockquote>Unicode string encoded in UTF-8 format, with no null-termination.&nbsp;
The length of the bytes array, measured in Unicode characters (not bytes),
is reported by the <tt>length</tt> field.</blockquote>

<h3>
<a NAME="Annotation"></a>Annotation</h3>
Annotation records are variable-size records used to store secondary information
about the typelib, e.g. such as the name of the tool that generated the
typelib file, the date it was generated, etc.&nbsp; The information is
stored with very loose format requirements so as to allow virtually any
private data to be stored in the typelib.
<blockquote><tt>union Annotation {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; EmptyAnnotation</tt>
<br><tt>&nbsp;&nbsp;&nbsp; PrivateAnnotation</tt>
<br><tt>}</tt></blockquote>

<blockquote><tt>EmptyAnnotation {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp; <a href="#Annotation_is_last">is_last</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; uint7&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Annotation_tag">tag</a>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 0</tt>
<br><tt>}</tt>
<p><tt>PrivateAnnotation {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp; <a href="#Annotation_is_last">is_last</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; uint7&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Annotation_tag">tag</a>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp; String&nbsp;&nbsp;&nbsp; <a href="#Annotation_creator">creator</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; String&nbsp;&nbsp;&nbsp; <a href="#Annotation_private_data">private_data</a>;</tt>
<br><tt>}</tt></blockquote>

<h4>
<a NAME="Annotation_is_last"></a><tt>is_last</tt></h4>

<blockquote>When true, no more Annotation records follow the current record.&nbsp;
If false, at least one Annotation record appears immediately after the
current record.</blockquote>

<h4>
<a NAME="Annotation_tag"></a><tt>tag</tt></h4>

<blockquote>The tag field discriminates among the variant record types
for Annotation's.&nbsp; If the tag is 0, this record is an EmptyAnnotation.&nbsp;
EmptyAnnotation's are ignored - they're only used to indicate an array
of Annotation's that's completely empty.&nbsp; If the tag is 1, the record
is a PrivateAnnotation.</blockquote>

<h4>
<a NAME="Annotation_creator"></a><tt>creator</tt></h4>

<blockquote>A string that identifies the application/tool/code that created
the annotation, e.g. "XPIDL Compiler, Version 1.2".&nbsp; There are no
rules about the contents of the <tt>creator</tt> string other than that
it be human-readable.</blockquote>

<h4>
<a NAME="Annotation_private_data"></a><tt>private_data</tt></h4>

<blockquote>An opaque data array that is put into the typelib by the application/tool/code
that created the typelib.&nbsp; There are no restrictions on the format
of the <tt>private_data</tt>.</blockquote>

</body>
</html>
