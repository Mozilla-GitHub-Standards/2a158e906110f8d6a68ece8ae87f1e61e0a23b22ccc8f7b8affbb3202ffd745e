<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.5 [en] (WinNT; I) [Netscape]">
   <meta name="Author" content="Scott Furman">
   <title>XPCOM Type Library File Format, Version 1.0</title>
</head>
<body bgcolor="#FFFFFF">

<center>
<h1>
XPCOM Type Library<br>
File Format</h1></center>

<center>
<h4>
Version 1.0, Draft 1</h4></center>

<center>Last updated:&nbsp;<script>
document.write(document.lastModified);
</script>

<br>Author: <a href="mailto:fur@netscape.com">Scott Furman &lt;fur@netscape.com></a></center>

<p>
Latest version:<br> 
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://mozilla.org/scriptable/typelib_file.html">http://mozilla.org/scriptable/typelib_file.html</a><br>
This version:<br> 
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://mozilla.org/scriptable/typelib_file_v1_d1.html">http://mozilla.org/scriptable/typelib_file_v1_d1.html</a>
</p>

<h3>
Introduction</h3>
XPCOM type libraries, or "typelibs", are binary interface description files
generated by the <a href="xpidl/index.html">XPIDL</a> compiler. Type libraries
enumerate the methods of one or more interfaces, including detailed type
information for each method parameter. Typelibs might be more aptly named
"interface libraries", but Microsoft has already established a precedent
with their naming scheme and we'll stick with it to avoid developer confusion.
<h3>
Goals</h3>

<ul>
<li>
Represent all type information that is required for <a href="index.html">XPCOMConnect</a>
to enable access to COM objects from JS and vice-versa</li>

<li>
Map an IID to an interface description quickly</li>

<li>
Allow for efficiency when interfaces are sparsely used, i.e. without requiring
the entire typelib to be parsed or retained in memory.</li>

<li>
Use a compact file format, so as to accommodate hundreds of interfaces
and thousands of methods.</li>

<li>
Allow for extensibility, so as to accommodate future additions to XPIDL</li>
</ul>

<h3>
Non-goals</h3>

<ul>
<li>
Ability to reconstruct XPIDL source from type library</li>

<li>
Human-readable format</li>

<li>
File-level compatibility with MS typelibs</li>
</ul>

<h3>
Notation</h3>
The syntax used in this document to specify the layout of file data appears
similar to C structs. Unlike C structs, however, data members are not subject
to alignment restrictions.&nbsp; Another difference from C structs is the
use of pointer notation to represent 32-bit file offsets. For example,
<ul><tt>uint16 *ByteOffsetTo16BitValue</tt></ul>
specifies a 32-bit field that contains the offset, in bytes to an array
of one or more 16-bit values.&nbsp;&nbsp; Unless otherwise noted, all file
offsets are byte offsets from the beginning of the <a href="#data_pool">data
pool</a>&nbsp; and are 32-bit signed quantities.&nbsp; The first byte of
the data pool is at offset 1, so as to allow offset 0 to be used as a special
indicator.&nbsp; By adding in an appropriate constant, these offsets are
appropriate as arguments to <tt>seek()</tt>.
<p>Record fields with type <tt>boolean</tt> occupy one bit, not one byte.&nbsp;
A value of 1 represents true and a value of 0 represents false.
<p>All integer fields with multibyte precision are stored in little-endian
order, e.g. for a uint16 field, the low-order byte is stored in the file
followed by the high-order byte.
<h3>
Filename Suffix</h3>
The standard suffix for XPCOM type libraries is <tt>.xpt</tt>. (<i>Do we
need to define a standard four-character Mac signature/creator ?</i>)
<h3>
<a NAME="File_Header"></a>File Header</h3>
Every XPCOM typelib file begins with a header:
<blockquote>
<pre><tt>TypeLibHeader {
&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; <a href="#magic">magic[16]</a>;
&nbsp;&nbsp;&nbsp; uint8&nbsp; <a href="#version">major_version</a>;
&nbsp;&nbsp;&nbsp; uint8&nbsp; <a href="#version">minor_version</a>;
&nbsp;&nbsp;&nbsp; uint16 <a href="#num_interfaces">num_interfaces</a>;
&nbsp;&nbsp;&nbsp; uint32 <a href="#file_length">file_length</a>;
&nbsp;&nbsp;&nbsp; InterfaceDirectoryEntry* <a href="#InterfaceDirectoryEntry">interface_directory</a>;
&nbsp;&nbsp;&nbsp; uint8* <a href="#data_pool">data_pool</a>;
}</tt></pre>
</blockquote>

<h4>
<a NAME="magic"></a><tt>magic</tt></h4>

<blockquote>The first 16 bytes of the file always contain the following
values:
<pre><tt><font size=-2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (hex) 58 50 43 4f 4d 0a 54 79 70 65 4c 69 62&nbsp; 0d 0a&nbsp;&nbsp; 1a
(C notation)&nbsp; X&nbsp; P&nbsp; C&nbsp; O&nbsp; M \n&nbsp; T&nbsp; y&nbsp; p&nbsp; e&nbsp; L&nbsp; i&nbsp; b&nbsp; \r \n \032</font></tt></pre>
This signature both identifies the file as an XPCOM typelib file and provides
for immediate detection of common file-transfer problems, i.e. treatment
of a binary file as if it was a text file. The CR-LF sequence catches file
transformations that alter newline sequences. The control-Z character stops
file display under MS-DOS. The linefeed in the sixth character checks for
the inverse of the CR-LF translation problem. (<i>A nod to the PNG folks
for the inspiration behind using these special characters in the header.</i>)</blockquote>

<h4>
<a NAME="version"></a><tt>major_version, minor_version</tt></h4>

<blockquote>These are the major and minor version numbers of the typelib
file format. For this specification <tt>major_version</tt> is 0x01 and
<tt>minor_version</tt>
is 0x00. TypeLib files that share the same major version but have different
minor versions are compatible. Changes to the major version represent typelib
file formats that are not backward-compatible with parsers designed only
to read earlier major versions. If a typelib file is encountered with a
major version for which support is not available, the rest of the file
should not be parsed.</blockquote>

<h4>
<a NAME="num_interfaces"></a><tt>num_interfaces</tt></h4>

<blockquote>This indicates the number of <a href="#InterfaceDirectoryEntry">InterfaceDirectoryEntry</a>
records that are at the offset indicated by the <tt>interface_directory</tt>
field.</blockquote>

<h4>
<a NAME="interface_directory"></a><tt>interface_directory</tt></h4>

<blockquote>This field specifies a zero-relative byte offset from the beginning
of the file.&nbsp; It identifies the start of an array of InterfaceDirectoryEntry
records.&nbsp; If <tt>num_interfaces</tt> is zero, then this field should
also be zero.&nbsp; The value of this field should be a multiple of 4,
i.e. the interface directory must be aligned on a 4-byte boundary.&nbsp;
(This is to guarantee aligned access if the typelib file is mmap'ed into
memory.)</blockquote>

<h4>
<a NAME="file_length"></a><tt>file_length</tt></h4>

<blockquote>Total length of the typelib file, in bytes. This value can
be compared to the length of the file reported by the OS so as to detect
file truncation.</blockquote>

<h4>
<a NAME="data_pool"></a><tt>data_pool</tt></h4>

<blockquote>The data pool is a heap-like storage area that is the container
for most kinds of typelib data including, but not limited to <a href="#InterfaceDescriptor">InterfaceDescriptor</a>,
<a href="#MethodDescriptor">MethodDescriptor</a>,
<a href="#ParamDescriptor">ParamDescriptor</a>,
and <a href="#TypeDescriptor">TypeDescriptor</a> records.&nbsp; Note that,
unlike most file offsets in a typelib, the value of <tt>data_pool</tt>
is relative to the beginning of the file.</blockquote>

<h3>
<a NAME="InterfaceDirectoryEntry"></a>InterfaceDirectoryEntry</h3>
A contiguous array of fixed-size InterfaceDirectoryEntry records begins
at the byte offset identified by the <tt><a href="#interface_directory">interface_directory</a></tt>
field in the <a href="#File_Header">file header</a>.&nbsp; The array is
used to quickly locate an interface description using its IID.&nbsp; No
interface should appear more than once in the array.
<blockquote>
<pre><tt>InterfaceDirectoryEntry {
&nbsp;&nbsp;&nbsp; uint128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#iid">iid</a>;
&nbsp;&nbsp;&nbsp; InterfaceDescriptor* <a href="#interface_descriptor">interface_descriptor</a>;
}</tt></pre>
</blockquote>

<h4>
<a NAME="iid"></a><tt>iid</tt></h4>

<blockquote>The iid field contains a 128-bit value representing the interface
ID. The iid is created from an IID by concatenating the individual bytes
of an IID in a particular order. For example, this IID:
<blockquote><tt>{00112233-4455-6677-8899-aabbccddeeff}</tt></blockquote>
is converted to the 128-bit value
<blockquote><tt>0xffeeddccbbaa88996677445500112233</tt></blockquote>
Note that the byte storage order corresponds to the layout of the nsIID
C-struct on a little-endian architecture.
<p>All InterfaceDirectoryEntry objects must appear sorted in increasing
order of iid, so as to facilitate a binary search of the array.</blockquote>

<h4>
<a NAME="interface_descriptor"></a><tt>interface_descriptor</tt></h4>

<blockquote>This is a byte offset from the beginning of the file to the
corresponding InterfaceDescriptor object.</blockquote>

<h3>
<a NAME="InterfaceDescriptor"></a>InterfaceDescriptor</h3>
An InterfaceDescriptor is a variable-size record used to describe a single
XPCOM interface, including all of its methods:
<blockquote>
<pre><tt>InterfaceDescriptor {
&nbsp;&nbsp;&nbsp; <a href="#String">String</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name;
&nbsp;&nbsp;&nbsp; InterfaceDescriptor* <a href="#parent_interface">parent_interface</a>;
&nbsp;&nbsp;&nbsp; uint16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#num_methods">num_methods</a>;
&nbsp;&nbsp;&nbsp; <a href="#MethodDescriptor">MethodDescriptor</a>&nbsp;&nbsp;&nbsp;&nbsp; <a href="#method_descriptors">method_descriptors</a>[num_methods];
}</tt></pre>
</blockquote>

<h4>
<a NAME="InterfaceDescriptor_name"></a><tt>name</tt></h4>

<blockquote>The human-readable name of this interface, e.g. "nsISupports",
stored using the <a href="#String">String</a> record format.</blockquote>

<h4>
<a NAME="parent_interface"></a><tt>parent_interface</tt></h4>

<blockquote>As a space-saving measure, an interface's methods can be specified
by composing the methods of an interface from which it is derived with
additional methods it defines.&nbsp; In this case, the <tt>method_descriptors</tt>
array does not list any methods that the interface inherits from its parent
and the <tt>parent_interface</tt> field contains a byte offset to the InterfaceDescriptor
of its parent interface.&nbsp; Note: the XPIDL compiler is not required
to compress interface descriptions in this manner - it's purely a space
optimization.</blockquote>

<h4>
<a NAME="num_methods"></a><tt>num_methods</tt></h4>

<blockquote>The number of methods in the <tt>method_descriptors</tt> array.</blockquote>

<h4>
<a NAME="method_descriptors"></a><tt>method_descriptors</tt></h4>

<blockquote>This is a byte offset from the beginning of the data pool to
an array of MethodDescriptor objects.&nbsp; The length of the array is
determined by the <tt>num_methods</tt> field.</blockquote>

<h3>
<a NAME="MethodDescriptor"></a>MethodDescriptor</h3>
A MethodDescriptor is a variable-size record used to describe a single
interface method:
<blockquote>
<pre><tt>MethodDescriptor {
&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#is_getter">is_getter</a>;
&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#is_getter">is_setter</a>;
&nbsp;&nbsp;&nbsp; uint6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reserved;
&nbsp;&nbsp;&nbsp; String*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#MethodDescriptor_name">name</a>;
&nbsp;&nbsp;&nbsp; uint8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#num_args">num_args</a>;
&nbsp;&nbsp;&nbsp; ParamDescriptor <a href="#params">params</a>[num_args];
&nbsp;&nbsp;&nbsp; ParamDescriptor <a href="#result">result</a>;
}</tt></pre>
</blockquote>

<h4>
<a NAME="is_getter"></a>is_getter</h4>

<blockquote>This field is used to allow interface methods to act as property
getters for object-oriented languages such as JavaScript.&nbsp; For example,
if there was an XPCOM method named "get_Banjo", you could access a "Banjo"
property on an interface like this: 'myInterface.Banjo'.&nbsp; If <tt>is_getter</tt>
is true, then the "get_" prefix should be stripped off the method's <tt>name</tt>
by the XPIDL compiler.</blockquote>

<h4>
<a NAME="is_getter"></a>is_setter</h4>

<blockquote>This field is used to allow interface methods to act as property
setters for object-oriented languages such as JavaScript.&nbsp; For example,
if there was an XPCOM method named "set_Banjo", you could assign to a "Banjo"
property on an interface like this: 'myInterface.Banjo = 3'.&nbsp; If <tt>is_setter</tt>
is true, then the "set_" prefix should be stripped off the method's <tt>name</tt>
by the XPIDL compiler.</blockquote>

<h4>
<a NAME="MethodDescriptor_name"></a><tt>name</tt></h4>

<blockquote>The human-readable name of this method, e.g. "getWindow", stored
in the <a href="#String">String</a> record format.</blockquote>

<h4>
<a NAME="num_args"></a><tt>num_args</tt></h4>

<blockquote>The number of arguments that the method consumes.&nbsp; Also,
the number of elements in the <tt>params</tt> array.</blockquote>

<h4>
<a NAME="params"></a><tt>params</tt></h4>

<blockquote>This is a byte offset from the beginning of the data pool to
an array of <a href="#ParamDescriptor">ParamDescriptor</a> objects.&nbsp;
The length of the array is determined by the <tt>num_args</tt> field.</blockquote>

<h4>
<a NAME="result"></a><tt>result</tt></h4>

<blockquote>This is a byte offset from the beginning of the data pool to
a single <a href="#ParamDescriptor">ParamDescriptor</a> object that identifies
the type of the method return value.</blockquote>

<h3>
<a NAME="ParamDescriptor"></a>ParamDescriptor</h3>
A ParamDescriptor is a variable-size record used to describe either a single
argument to a method or a method's result:
<blockquote>
<pre><tt>ParamDescriptor {
&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#param_in">in</a>;
&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#param_out">out</a>;
&nbsp;&nbsp;&nbsp; uint6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#reserved6">reserved</a>;
&nbsp;&nbsp;&nbsp; TypeDescriptor&nbsp; <a href="#ParamDescriptor_type">type</a>;
}</tt></pre>
</blockquote>

<h4>
<a NAME="param_in"></a><tt>in</tt></h4>

<blockquote>If <tt>in</tt> is true, it indicates that the parameter is
to be passed from caller to callee.</blockquote>

<h4>
<a NAME="param_out"></a><tt>out</tt></h4>

<blockquote>If <tt>out</tt> is true, it indicates that the parameter is
to be passed from callee to caller.&nbsp; Out parameters must have pointer
type.&nbsp; It is possible for a parameter to have both <tt>out</tt> and
<tt>in</tt>
bits set.</blockquote>

<h4>
<a NAME="reserved6"></a><tt>reserved</tt></h4>

<blockquote>A 6-bit field reserved for future use.</blockquote>

<h4>
<a NAME="ParamDescriptor_type"></a><tt>type</tt></h4>

<blockquote>The type of the method parameter.</blockquote>

<h3>
<a NAME="TypeDescriptor"></a>TypeDescriptor</h3>
A TypeDescriptor is a variable-size record used to identify the type of
a method argument or return value.&nbsp; There are many XPCOM types that
need to be represented in the typelib:
<ul>
<li>
scalar types, e.g. uint16 or boolean</li>

<li>
pointer to a scalar type, e.g. float*</li>

<li>
generic opaque pointer, i.e. void*</li>

<li>
void (only allowed for method return type)</li>

<li>
interface pointer, or a pointer to an interface pointer</li>

<li>
iid_is - that is, an interface pointer with type determined at runtime,
or a pointer to such an interface pointer</li>

<li>
pointer to an nsIID structure (to act as the parameter to an iid_is)</li>
</ul>
[Editor: This specification does not yet cover pointers to unions, structs
or arrays.]
<p><a NAME="variant_TypeDescriptors"></a>To efficiently describe all the
type categories listed above, there are several different variants of TypeDescriptor
records:
<blockquote><tt>union TypeDescriptor {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; SimpleTypeDescriptor;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; InterfaceTypeDescriptor;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; InterfaceIsTypeDescriptor;</tt>
<br><tt>}</tt></blockquote>
The first byte of all these TypeDescriptor variants has the identical layout:
<blockquote><tt>TypeDescriptorPrefix {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_pointer">is_pointer</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_unique_pointer">is_unique_pointer</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_reference">is_reference</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;&nbsp; <a href="#tag">tag</a>;</tt>
<br><tt>}</tt></blockquote>

<h4>
<a NAME="is_pointer"></a><tt>is_pointer</tt></h4>

<blockquote>This field is true only when representing C pointer/reference
types.</blockquote>

<h4>
<a NAME="is_unique_pointer"></a><tt>is_unique_pointer</tt></h4>

<blockquote>This field cannot have a value of true unless <tt>is_pointer</tt>
is also true.&nbsp; The <tt>unique_pointer</tt> field indicates if the
parameter value can be aliased to another parameter value.&nbsp; If <tt>unique_pointer</tt>
is true, it must not be possible to reach the memory pointed at by this
argument value from any other argument to the method.</blockquote>

<h4>
<a NAME="is_reference"></a><tt>is_reference</tt></h4>

<blockquote>This field cannot have a value of true unless <tt>is_pointer</tt>
is also true.&nbsp; This field is true if the parameter is a reference,
which is to say, it's a pointer that can't have a value of NULL.</blockquote>

<h4>
<a NAME="tag"></a><tt>tag</tt></h4>

<blockquote>The tag field indicates which of the <a href="#variant_TypeDescriptors">variant
TypeDescriptor records</a> is being used, and hence the way any remaining
fields should be parsed.
<br>&nbsp;
<table BORDER >
<tr BGCOLOR="#CCFFFF">
<td>
<center><b>&nbsp;Value in <tt>tag</tt> field&nbsp;</b></center>
</td>

<td>
<center><b>&nbsp;TypeDescriptor variant to use&nbsp;</b></center>
</td>
</tr>

<tr>
<td>
<center>0..15</center>
</td>

<td>
<center>SimpleTypeDescriptor</center>
</td>
</tr>

<tr>
<td>
<center>16</center>
</td>

<td>
<center>InterfaceTypeDescriptor</center>
</td>
</tr>

<tr>
<td>
<center>17</center>
</td>

<td>
<center>InterfaceIsTypeDescriptor</center>
</td>
</tr>

<tr>
<td>
<center>18..31</center>
</td>

<td>
<center>reserved</center>
</td>
</tr>
</table>
</blockquote>

<h3>
<a NAME="SimpleTypeDescriptor"></a>SimpleTypeDescriptor</h3>
The one-byte SimpleTypeDescriptor is a kind of <a href="#TypeDescriptor">TypeDescriptor</a>
used to represent scalar types,&nbsp; pointers to scalar types, the <tt>void</tt>
type,&nbsp; the <tt>void*</tt> type and, as a special case, the <tt>nsIID*</tt>
type:
<ul><tt>SimpleTypeDescriptor {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_pointer_and_tag">is_pointer</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_unique_pointer">is_unique_pointer</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_reference">is_reference</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;&nbsp; <a href="#is_pointer_and_tag">tag</a>;</tt>
<br><tt>}</tt></ul>

<h4>
<a NAME="is_pointer_and_tag"></a><tt>is_pointer, tag</tt></h4>

<ul>The <tt>is_pointer</tt> field is true only when representing C pointer/reference
types.&nbsp; The following table indicates the types that can be represented
by combining different values for these two fields:
<br>&nbsp;
<table BORDER WIDTH="80%" >
<tr BGCOLOR="#CCFFFF">
<td COLSPAN="3">
<center><b>&nbsp;SimpleTypeDescriptor</b></center>
</td>
</tr>

<tr BGCOLOR="#CCFFFF">
<td>
<center><b><tt>&nbsp;pointer&nbsp;</tt></b></center>
</td>

<td>
<center><b><tt>&nbsp;tag&nbsp;</tt></b></center>
</td>

<td>
<center><b>Type Represented</b></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>0</center>
</td>

<td>
<center><tt>int8</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>1</center>
</td>

<td>
<center><tt>int16</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>2</center>
</td>

<td>
<center><tt>int32</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>3</center>
</td>

<td>
<center><tt>int64</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>4</center>
</td>

<td>
<center><tt>uint8</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>5</center>
</td>

<td>
<center><tt>uint16</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>6</center>
</td>

<td>
<center><tt>uint32</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>7</center>
</td>

<td>
<center><tt>uint64</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>8</center>
</td>

<td>
<center><tt>float</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>9</center>
</td>

<td>
<center><tt>double</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>10</center>
</td>

<td>
<center><tt>boolean </tt>(8-bit value)</center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>11</center>
</td>

<td>
<center><tt>char</tt> (8-bit character)</center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>12</center>
</td>

<td>
<center><tt>wchar_t</tt> (16-bit character)</center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>13</center>
</td>

<td>
<center><tt>void</tt></center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>14</center>
</td>

<td>
<center>reserved</center>
</td>
</tr>

<tr>
<td>
<center>false</center>
</td>

<td>
<center>15</center>
</td>

<td>
<center>reserved</center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>0</center>
</td>

<td>
<center><tt>int8*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>1</center>
</td>

<td>
<center><tt>int16*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>2</center>
</td>

<td>
<center><tt>int32*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>3</center>
</td>

<td>
<center><tt>int64*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>4</center>
</td>

<td>
<center><tt>uint8*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>5</center>
</td>

<td>
<center><tt>uint16*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>6</center>
</td>

<td>
<center><tt>uint32*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>7</center>
</td>

<td>
<center><tt>uint64*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>8</center>
</td>

<td>
<center><tt>float*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>9</center>
</td>

<td>
<center><tt>double*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>10</center>
</td>

<td>
<center><tt>boolean* </tt>(8-bit value)</center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>11</center>
</td>

<td>
<center><tt>char*</tt> (8-bit character)</center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>12</center>
</td>

<td>
<center><tt>wchar_t*</tt> (16-bit character)</center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>13</center>
</td>

<td>
<center><tt>void*</tt> (generic opaque pointer)</center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>14</center>
</td>

<td>
<center><tt>nsIID*</tt></center>
</td>
</tr>

<tr>
<td>
<center>true</center>
</td>

<td>
<center>15</center>
</td>

<td>
<center>string</center>
</td>
</tr>
</table>
</ul>

<h3>
<a NAME="InterfaceTypeDescriptor"></a>InterfaceTypeDescriptor</h3>
An InterfaceTypeDescriptor is used to represent either a pointer to an
interface type or a pointer to a pointer to an interface type, e.g. <tt>nsISupports*</tt>
or <tt>nsISupports**:</tt>
<blockquote><tt>InterfaceTypeDescriptor {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
is_<a href="#InterfaceTypeDescriptor_is_pointer">pointer</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#is_unique_pointer">is_unique_pointer</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#is_reference">is_reference</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#InterfaceTypeDescriptor_tag">tag</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; InterfaceDescriptor* interface;</tt>
<br><tt>}</tt></blockquote>

<h4>
<a NAME="InterfaceTypeDescriptor_is_pointer"></a><tt>is_pointer</tt></h4>

<blockquote>When this field is false, the represented type is an interface
pointer.&nbsp; When <tt>is_pointer</tt> is true, the represented type is
a pointer to an interface pointer.</blockquote>

<h4>
<a NAME="InterfaceTypeDescriptor_tag"></a><tt>tag</tt></h4>

<blockquote>The tag field must have the decimal value 16.</blockquote>

<h3>
<a NAME="InterfaceIsTypeDescriptor"></a>InterfaceIsTypeDescriptor</h3>
An InterfaceIsTypeDescriptor describes an interface pointer type.&nbsp;
It is similar to an <a href="#InterfaceTypeDescriptor">InterfaceTypeDescriptor</a>
except that the type of the interface pointer is specified at runtime by
the value of another argument, rather than being specified by the typelib.
<blockquote>
<pre><tt>InterfaceIsTypeDescriptor {
&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#InterfaceTypeDescriptor_is_pointer">is_pointer</a>;
&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_unique_pointer">is_unique_pointer</a>;
&nbsp;&nbsp;&nbsp; boolean&nbsp; <a href="#is_reference">is_reference</a>;
&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;&nbsp; <a href="#InterfaceIsTypeDescriptor_tag">tag</a>;
&nbsp;&nbsp;&nbsp; uint8&nbsp;&nbsp;&nbsp; <a href="#InterfaceIsTypeDescriptor_arg_num">arg_num</a>;
}</tt></pre>
</blockquote>

<h4>
<a NAME="InterfaceIsTypeDescriptor_tag"></a><tt>tag</tt></h4>

<blockquote>The tag field must have the decimal value 17.</blockquote>

<h4>
<a NAME="InterfaceIsTypeDescriptor_arg_num"></a><tt>arg_num</tt></h4>

<blockquote>The index of the method argument that describes the type of
the interface pointer.&nbsp; The specified method argument must have type
<tt>nsIID*</tt>.</blockquote>

<h3>
<a NAME="String"></a>String</h3>
String records are used to represent variable-length, human-readable strings:
<blockquote><tt>String {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; uint16 <a href="#InternedString_length">length</a>;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; <a href="#InternedString_bytes">bytes</a>[];</tt>
<br><tt>}</tt></blockquote>

<h4>
<a NAME="InternedString_length"></a><tt>length</tt></h4>

<blockquote>The length of the string, in characters (not bytes).</blockquote>

<h4>
<a NAME="InternedString_bytes"></a><tt>bytes</tt></h4>

<blockquote>Unicode string encoded in UTF-8 format, with no null-termination.&nbsp;
The length of the bytes array, measured in Unicode characters (not bytes),
is reported by the <tt>length</tt> field.</blockquote>

<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
</body>
</html>
