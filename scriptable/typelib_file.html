<HTML>
<HEAD>
   <META NAME="Author" CONTENT="Scott Furman">
   <TITLE>XPCOM Type Library File Format, Version 1.0</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000"
      LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">

<H1 ALIGN=CENTER>XPCOM Type Library<BR>
File Format</H1>

<H4 ALIGN=CENTER>Version 1.1, Revision 1</H4>

<CENTER>Last updated:&nbsp;<SCRIPT>
document.write(document.lastModified);
</SCRIPT>

<BR><A HREF="mailto:fur@netscape.com">Scott Furman &lt;fur@netscape.com></A><BR>
    <A HREF="mailto:jband@netscape.com">John Bandhauer &lt;jband@netscape.com></A></CENTER>

<p>
Latest version:<br> 
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://mozilla.org/scriptable/typelib_file.html">http://mozilla.org/scriptable/typelib_file.html</a>
</p>

<H3><a href="#Document_History">Document History</a></H3>
<H3><a href="#Known_Issues">Known Issues</a></H3>
<H3>Introduction</H3>
<P>XPCOM type libraries, or "typelibs", are binary interface description files 
  generated by the <A HREF="xpidl/index.html">XPIDL</A> compiler. Type libraries 
  enumerate the methods of one or more interfaces, including detailed type information 
  for each method parameter. Typelibs might be more aptly named "interface libraries", 
  but Microsoft has already established a precedent with their naming scheme and 
  we'll stick with it to avoid developer confusion. </P>
<P>Ideally, XPCOM typelibs would be binary-compatible with those generated by 
  Microsoft's MIDL compiler, but the MS typelib format is proprietary. Thus, 
  this document specifies a format quite different from the Microsoft format.</P>
<P>Note that the typelib is not merely a tokenized form of the IDL.&nbsp; Rather, 
  it's intended to accurately represent binary XPCOM interfaces, with annotations 
  derived from the IDL.</P>

<H3>Goals</H3>

<UL>
  <LI> Represent all type information that is required for 
    <A HREF="index.html">XPConnect</A>,
    <A HREF="../projects/xpcom/Proxies.html">xpcom/proxy</A>, and
    <A HREF="../projects/blackwood/index.html">Blackwood</A>
  <LI> Map an IID to an interface description quickly
  <LI> Allow for efficiency when interfaces are sparsely used, i.e. without requiring 
    the entire typelib to be parsed or retained in memory
  <LI> Use a compact file format, so as to accommodate hundreds of interfaces 
    and thousands of methods
  <LI> Allow for extensibility, so as to accommodate future additions to XPIDL
</UL>

<H3>Non-goals</H3>

<UL>
  <LI>Ability to reconstruct XPIDL source from type library
  <LI>Human-readable format
  <LI>File-level compatibility with MS typelibs
</UL>

<H3>Notation</H3>

The syntax used in this document to specify the layout of file data appears
similar to C structs. Unlike C structs, however, data members are not subject
to alignment restrictions.&nbsp; Another difference from C structs is the
use of pointer notation to represent 32-bit file offsets. For example,
<UL><TT>uint16 *ByteOffsetTo16BitValue</TT></UL>
specifies a 32-bit field that contains the offset, in bytes, to an array of one 
or more unsigned 16-bit values.&nbsp;&nbsp; Unless otherwise noted, all file offsets 
are byte offsets from the beginning of the <A HREF="#data_pool">data pool</A>&nbsp; 
and are 32-bit signed quantities.&nbsp; The first byte of the data pool is at 
offset 1, so as to allow offset 0 to be used as a special indicator.&nbsp; By 
adding an appropriate constant, these offsets are appropriate as arguments to 
<TT>seek()</TT>. 
<P>Record fields with type <TT>boolean</TT> occupy one bit, not one byte.
A value of 1 represents true and a value of 0 represents false.

<P>All integer fields with multibyte precision are stored in big-endian order, 
  e.g. for a uint16 field, the high-order byte is stored in the file followed 
  by the low-order byte. 

<P>All records are 8-bit aligned. In some records reserved fields of less than
8 bits are specified to make that alignment explicit.

<H3>Filename Suffix</H3>

The standard suffix for XPCOM type libraries is <TT>.xpt</TT>.
<H3><A NAME="File_Header"></A>File Header</H3>

Every XPCOM typelib file begins with a header:
<BLOCKQUOTE> 
  <PRE><TT>TypeLibHeader {
    char                     <A HREF="#magic">magic[16]</A>;
    uint8                    <A HREF="#version">major_version</A>;
    uint8                    <A HREF="#version">minor_version</A>;
    uint16                   <A HREF="#num_interfaces">num_interfaces</A>;
    uint32                   <A HREF="#file_length">file_length</A>;
    <A HREF="#InterfaceDirectoryEntry">InterfaceDirectoryEntry</A>* <A HREF="#interface_directory">interface_directory</A>;
    uint8*                   <A HREF="#data_pool">data_pool</A>;
    <A HREF="#Annotation">Annotation</A>               <A HREF="#FileHeader_annotations">annotations</A>[];
}</TT></PRE>
</BLOCKQUOTE>

<H4><A NAME="magic"></A><TT>magic</TT></H4>


<BLOCKQUOTE>The first 16 bytes of the file always contain the following
values:

<PRE><TT>       (hex) 58 50 43 4f 4d 0a 54 79 70 65 4c 69 62  0d 0a   1a
(C notation)  X  P  C  O  M \n  T  y  p  e  L  i  b  \r \n \032</TT></PRE>
  This signature both identifies the file as an XPCOM typelib file and provides 
  for immediate detection of common file-transfer problems, i.e. treatment of 
  a binary file as if it was a text file. The CR-LF sequence catches file transformations 
  that alter newline sequences. The control-Z character stops file display under 
  MS-DOS. The sixth character, a linefeed, checks for the inverse of the CR-LF 
  translation problem. (<I>A nod to the PNG folks for the inspiration behind using 
  these special characters in the header.</I>)</BLOCKQUOTE>

<H4><A NAME="version"></A><TT>major_version, minor_version</TT></H4>


<BLOCKQUOTE>These are the major and minor version numbers of the typelib file 
  format. For this specification <TT>major_version</TT> is 0x01 and <TT>minor_version</TT> 
  is 0x00. Typelib files that share the same major version but have different 
  minor versions are compatible. Changes to the major version represent typelib 
  file formats that are not backward-compatible with parsers designed only to 
  read earlier major versions. If a typelib file is encountered with a major version 
  for which support is not available, the rest of the file should not be parsed.</BLOCKQUOTE>

<H4><A NAME="num_interfaces"></A><TT>num_interfaces</TT></H4>


<BLOCKQUOTE>This indicates the count of <A HREF="#InterfaceDirectoryEntry">InterfaceDirectoryEntry</A> 
  records that are at the offset indicated by the <TT>interface_directory</TT> 
  field.</BLOCKQUOTE>

<H4><A NAME="interface_directory"></A><TT>interface_directory</TT></H4>


<BLOCKQUOTE> 
  <P>This field specifies a zero-relative byte offset from the beginning of the 
    file.&nbsp; It identifies the start of an array of InterfaceDirectoryEntry 
    records.&nbsp; If <TT>num_interfaces</TT> is zero, then this field should 
    also be zero.&nbsp; The value of this field should be a multiple of 4, i.e. 
    the interface directory must be aligned on a 4-byte boundary. (This is to 
    guarantee aligned access if the typelib file is mmap'ed into memory.)</P>
</BLOCKQUOTE>
<H4><A NAME="file_length"></A><TT>file_length</TT></H4>


<BLOCKQUOTE>Total length of the typelib file, in bytes. This value can
be compared to the length of the file reported by the OS so as to detect
file truncation.</BLOCKQUOTE>

<H4><A NAME="data_pool"></A><TT>data_pool</TT></H4>


<BLOCKQUOTE>The data pool is a heap-like storage area that is the container for 
  most kinds of typelib data including, but not limited to, <A HREF="#InterfaceDescriptor">InterfaceDescriptor</A>, 
  <A HREF="#MethodDescriptor">MethodDescriptor</A>, <A HREF="#ParamDescriptor">ParamDescriptor</A>, 
  and <A HREF="#TypeDescriptor">TypeDescriptor</A> records.&nbsp; Note that, unlike 
  most file offsets in a typelib, the value of <TT>data_pool</TT> is zero-relative 
  to the beginning of the file. Pointers to records within a typelib are 1-based 
  (not zero-based) relative to the beginning of the data pool. </BLOCKQUOTE>

<H4><A NAME="FileHeader_annotations"></A><TT>annotations</TT></H4>


<BLOCKQUOTE>A variable-length array of variable-size records used to store
secondary information, e.g. such as the name of the tool that generated
the typelib file, the date it was generated, etc.</BLOCKQUOTE>

<H3><A NAME="InterfaceDirectoryEntry"></A>InterfaceDirectoryEntry</H3>

A contiguous array of fixed-size InterfaceDirectoryEntry records begins at the 
byte offset identified by the <TT><A HREF="#interface_directory">interface_directory</A></TT> 
field in the <A HREF="#File_Header">file header</A>.&nbsp; The array is used to 
quickly locate an interface description given its IID.&nbsp; No interface should 
appear more than once in the array. 
<BLOCKQUOTE> 
  <PRE><TT>InterfaceDirectoryEntry {
    uint128              <A HREF="#iid">iid</A>;
    <A HREF="#Identifier">Identifier</A>*          <A HREF="#InterfaceDirectoryEntry_name">name</A>;
    <a href="#Identifier">Identifier</a>*          <a href="#InterfaceDirectoryEntry_namespace">namespace</a>;
    <A HREF="#InterfaceDescriptor">InterfaceDescriptor</A>* <A HREF="#interface_descriptor">interface_descriptor</A>;
}</TT></PRE>
</BLOCKQUOTE>



<P>An interface is said to be unresolved if its methods and constants have not 
   yet been determined. In order for an <TT>InterfaceDirectoryEntry</TT> to appear 
   in the <TT>interface_directory</TT> at all the <TT>name</TT> (e.g. "nsISupports")
   must be present. The <TT>iid</TT> might be present. Only if the
   <TT>name</TT> and <TT>iid</TT> are present may the <TT>interface_descriptor</tt>
   be present. Only when all three are present is the interface said to be resolved.
   It is always permitted that <TT>namespace</TT> be missing. In any case, any 
   missing fields must be set to zero.

<P>If an interface is unresolved, then its typelib must be &quot;linked&quot; 
  with another typelib to resolve the interface, namely a typelib that contains 
  a resolved InterfaceDirectoryEntry that matches the specified <tt>iid</tt>, 
  <tt>name</tt>, and <tt>namespace</tt>. Such linking might result in the 
  merging of multiple typelibs - each containing some unresolved interfaces - 
  into one typelib containing only resolved interfaces. It also might mean the 
  activity of loading multiple typelibs at runtime and doing that resolution in 
  memory.


<H4><A NAME="iid"></A><TT>iid</TT></H4>

<BLOCKQUOTE>The iid field contains a 128-bit value representing the interface
ID. The iid is created from an IID by concatenating the individual bytes
of an IID in a particular order. For example, this IID:
<BLOCKQUOTE><TT>{00112233-4455-6677-8899-aabbccddeeff}</TT></BLOCKQUOTE>
is converted to the 128-bit value
  <BLOCKQUOTE><TT>0x00112233445566778899aabbccddeeff</TT></BLOCKQUOTE>
Note that the byte storage order corresponds to the layout of the nsIID C-struct 
  on a big-endian architecture. 
  <P>All InterfaceDirectoryEntry objects must appear sorted in increasing order 
    of iid, so as to facilitate a binary search of the array.&nbsp; (This means 
    that unresolved interfaces always appear at the beginning of the array.)
</BLOCKQUOTE>

<H4><A NAME="InterfaceDirectoryEntry_name"></A><TT>name</TT></H4>


<BLOCKQUOTE> 
  <p>The human-readable name of this interface, e.g. "nsISupports", stored using 
    the <A HREF="#Identifier">Identifier</A> record format.</p>
</BLOCKQUOTE>
<h4><a name="InterfaceDirectoryEntry_namespace"></a><tt>namespace</tt></h4>
<blockquote>The human-readable identifier for the namespace of this interface, 
  stored using the <a href="#Identifier">Identifier</a> record format. This is 
  the declared name of an interface's module in the XPIDL. The use of namespace 
  permits identically-named interfaces that do not conflict. (Reference to an 
  interface from one namespace to an interface in another namespace would probably 
  be written as <i>namespace.interfaceName</i>.) If namespace is zero, the interface 
  is in the default namespace.</blockquote>
<H4><A NAME="interface_descriptor"></A><TT>interface_descriptor</TT></H4>


<BLOCKQUOTE>This is a 1-based byte offset from the beginning of the data pool 
  to the corresponding InterfaceDescriptor object.</BLOCKQUOTE>

<H3><A NAME="InterfaceDescriptor"></A>InterfaceDescriptor</H3>

An InterfaceDescriptor is a variable-size record used to describe a single XPCOM 
interface, including all of its methods, scoped constants and types: 
<BLOCKQUOTE>

  <PRE><TT>InterfaceDescriptor {
    uint16                   <A HREF="#parent_interface">parent_interface_index</A>;
    uint16                   <A HREF="#num_methods">num_methods</A>;
    <A HREF="#MethodDescriptor">MethodDescriptor</A>         <A HREF="#method_descriptors">method_descriptors</A>[num_methods];
    uint16                   <A HREF="#num_constants">num_constants</A>;
    <A HREF="#ConstDescriptor">ConstDescriptor</A>          <A HREF="#const_descriptors">const_descriptors</A>[num_constants];
    boolean                  <A HREF="#is_scriptable">is_scriptable</A>;
    boolean                  <A HREF="#is_function">is_function</A>;
    uint6                    <A HREF="#reserved1">reserved</A>;

}</TT></PRE>
</BLOCKQUOTE>

<H4><A NAME="parent_interface"></A><TT>parent_interface_index</TT></H4>


<BLOCKQUOTE>An interface's methods are specified by composing the methods of an 
  interface from which it is derived with additional methods it defines. The <TT>method_descriptors</TT> 
  array does not list any methods that the interface inherits from its parent. 
  The <TT>parent_interface_index</TT> field contains an index into the <A HREF="#interface_directory">interface_directory</A>, 
  thus identifying the InterfaceDirectoryEntry of the parent interface. The first 
  entry in the interface_directory has index 1. This field has a value of zero 
  for nsISupports, the root of the interface inheritance hierarchy.</BLOCKQUOTE>

<H4><A NAME="num_methods"></A><TT>num_methods</TT></H4>


<BLOCKQUOTE>The number of methods in the <TT>method_descriptors</TT> array.</BLOCKQUOTE>

<H4><A NAME="method_descriptors"></A><TT>method_descriptors</TT></H4>


<BLOCKQUOTE>This is an inline array of MethodDescriptor objects.
The length of the array is determined by the <TT>num_methods</TT> field.</BLOCKQUOTE>

<H4><A NAME="num_constants"></A><TT>num_constants</TT></H4>


<BLOCKQUOTE>The number of scoped interface constants in the <TT>const_descriptors</TT>
array.</BLOCKQUOTE>

<H4><A NAME="const_descriptors"></A><TT>const_descriptors</TT></H4>


<BLOCKQUOTE>This is an inline array of ConstDescriptor objects.&nbsp; The
length of the array is determined by the <TT>num_constants</TT> field.</BLOCKQUOTE>


<H4><A NAME="is_scriptable"></A><TT>is_scriptable</TT></H4>

<BLOCKQUOTE>This field indicates that the interface has been marked to be 
visible to scripting languages. Individual method can be marked as hidden 
from scripting languages by setting the <A HREF="#is_hidden">is_hidden</A>
flag on the individual methods.</BLOCKQUOTE>

<H4><A NAME="is_function"></A><TT>is_function</TT></H4>

<BLOCKQUOTE>This field indicates that the interface has been marked such that
all of its methods will be considered to be functions. This allows us to support 
certain legacy interfaces for the JavaScript DOM that need to sometimes be able 
to treat functions as if they were objects with named methods.
This flag is very rarely used and can generally be ignored.</BLOCKQUOTE>

<H4><A NAME="reserved1"></A><TT>reserved</TT></H4>

<H3><A NAME="ConstDescriptor"></A>ConstDescriptor</H3>

A ConstDescriptor is a variable-size record that records the name and value
of a scoped interface constant.&nbsp; All ConstDescriptor records have
this form:
<BLOCKQUOTE>
  <PRE><TT>ConstDescriptor {<BR>&nbsp;&nbsp;&nbsp; Identifier*&nbsp;&nbsp;&nbsp;&nbsp; <A HREF="#ConstDescriptor_name">name</A>;<BR>&nbsp;&nbsp;&nbsp; TypeDescriptor&nbsp; <A HREF="#ParamDescriptor_type">type</A>;<BR>&nbsp;&nbsp;&nbsp; &lt;type>          <A HREF="#ConstDescriptor_value">value</A>;<BR>}</TT></PRE></BLOCKQUOTE>

<H4><A NAME="ConstDescriptor_name"></A><TT>name</TT></H4>


<BLOCKQUOTE>The human-readable name of this constant, stored in the <A HREF="#Identifier">Identifier</A>
record format.</BLOCKQUOTE>

<H4><A NAME="ConstDescriptor_type"></A><TT>type</TT></H4>


<BLOCKQUOTE>The type of the method parameter.&nbsp; Types are restricted
to the following subset of TypeDescriptors: <TT>int16, uint16, int32, uint32</TT>
</BLOCKQUOTE>

<H4><A NAME="ConstDescriptor_value"></A><TT>value</TT></H4>


<BLOCKQUOTE>The type (and thus the size) of the <TT>value</TT> record is
determined by the contents of the associated TypeDescriptor record.
For instance, if <TT>type</TT> corresponds to <TT>int16</TT>, then <TT>value</TT>
is a two-byte record consisting of a 16-bit signed integer.

<!--
For a ConstDescriptor type of <TT>string</TT>, the <TT>value</TT> record is of
type <A HREF="#String">String</A>*, i.e. an offset within the data pool
to a String record containing the constant string.
-->

</BLOCKQUOTE>

<H3><A NAME="MethodDescriptor"></A>MethodDescriptor</H3>

A MethodDescriptor is a variable-size record used to describe a single
interface method:
<BLOCKQUOTE> 
  <PRE><TT>MethodDescriptor {
    boolean         <A HREF="#is_getter">is_getter</A>;
    boolean         <A HREF="#is_getter">is_setter</A>;
    boolean         <A HREF="#is_not_xpcom">is_not_xpcom</A>;
    boolean         <A HREF="#is_constructor">is_constructor</A>;
    boolean         <A HREF="#is_hidden">is_hidden</A>;
    uint3           reserved;
    Identifier*     <A HREF="#MethodDescriptor_name">name</A>;
    uint8           <A HREF="#num_args">num_args</A>;
    ParamDescriptor <A HREF="#params">params</A>[num_args];
    ParamDescriptor <A HREF="#result">result</A>;
}</TT></PRE>
</BLOCKQUOTE>

<H4><A NAME="is_getter"></A><TT>is_getter</TT></H4>


<BLOCKQUOTE>This field is used to allow interface methods to act as property getters 
  for object-oriented languages such as JavaScript.&nbsp; The <TT>is_getter</TT> 
  flag would typically be set as a result of defining an XPIDL attribute.&nbsp; 
  For example, if there was an XPIDL attribute named "Banjo",&nbsp; you could 
  access the "Banjo" property on an interface from JavaScript like so: 'myInterface.Banjo'.&nbsp; 
  Any prefix added&nbsp; by the XPIDL compiler to an attribute's&nbsp; identifier 
  in a generated .h file, such as "Is" or "Get" should not appear in the method's 
  <TT>name</TT>.</BLOCKQUOTE>

<H4><A NAME="is_getter"></A><TT>is_setter</TT></H4>


<BLOCKQUOTE>This field is used to allow interface methods to act as property setters 
  for object-oriented languages such as JavaScript.&nbsp; The <TT>is_setter</TT> 
  flag would typically set as a result of defining an XPIDL attribute.&nbsp; For 
  example, if there was an XPIDL attribute named "Banjo",&nbsp; you could assign 
  to the "Banjo" property on an interface using JavaScript like so: 'myInterface.Banjo 
  = 3'. Any prefix added&nbsp; by the XPIDL compiler to an attribute's&nbsp; identifier 
  in a generated .h file, such as "Set" should not appear in the method's <TT>name</TT>.

<p> 

  <B>Note</B>: If an interface has both a MethodDescriptor marked 
  <TT>is_getter</TT> and a MethodDescriptor marked <TT>is_setter</TT>
  for the same named  attribute then the two MethodDescriptors must be
  adjacent and the <TT>is_getter</TT> descriptor must preceed the
  <TT>is_setter</TT> descriptor.

  
</BLOCKQUOTE>

<h4><a name="is_not_xpcom"></a><tt>is_not_xpcom</tt></h4>

<blockquote>If true, this field indicates that the method does not follow xpcom
  calling conventions and can not be called by most proxying code or xpconnect.
  This is most useful for methods that do not return a <TT>nsresult</TT>; e.g the 
  <TT>AddRef</TT> and <TT>Release</TT> methods of <TT>nsISupports</TT>. 
  The method remains in the typelib to fill a slot in the interface's vtable. 
</blockquote>

<H4><A NAME="is_constructor"></A><TT>is_constructor</TT></H4>


<BLOCKQUOTE>This field indicates the default constructor for this interface, which 
  may be useful for interfaces that act like factories.&nbsp; For example, with 
  an instance of an XPCOM interface named 'Foo', in JavaScript one might write 
  'new Foo(arg1, arg2)', thus calling this interface to be called; The argument 
  signature of an XPCOM constructor is: 
  <BLOCKQUOTE><TT>NS_IRESULT ([arg,]*, out nsISomeInterface result)</TT></BLOCKQUOTE>
  <p>That is, it's a function that takes zero or more arguments and creates a 
    new interface returned through the <TT>result</TT> output parameter.</p>
  <p>Only one method in an interface can have this flag set.</p>
</BLOCKQUOTE>

<h4><a name="is_hidden"></a><tt>is_hidden</tt></h4>

<blockquote>If true, this field indicates that the method is not to be exposed 
  to scripters, although it remains in the typelib to fill a slot in the interface's 
  vtable. </blockquote>

<H4><A NAME="MethodDescriptor_name"></A><TT>name</TT></H4>

<BLOCKQUOTE>The human-readable name of this method, e.g. "getWindow", stored in 
  the <A HREF="#Identifier">Identifier</A> record format.&nbsp; Any prefix added&nbsp; 
  by the XPIDL compiler to an attribute's&nbsp; identifier in a generated .h file, 
  such as "Is" or "Get" should not appear in the method's <TT>name</TT>.</BLOCKQUOTE>

<H4><A NAME="num_args"></A><TT>num_args</TT></H4>


<BLOCKQUOTE>The number of arguments that the method consumes.&nbsp; Also,
the number of elements in the <TT>params</TT> array.</BLOCKQUOTE>

<H4><A NAME="params"></A><TT>params</TT></H4>


<BLOCKQUOTE>This is an inline array of <A HREF="#ParamDescriptor">ParamDescriptor</A>
objects.&nbsp; The length of the array is determined by the <TT>num_args</TT>
field.</BLOCKQUOTE>

<H4><A NAME="result"></A><TT>result</TT></H4>


<BLOCKQUOTE>This is a single, inline <A HREF="#ParamDescriptor">ParamDescriptor</A>
object that identifies the actual return type of an XPCOM method.
The result, however, does not always refer to the effective method return
value when the invocation is from a scripting language, i.e. the return
value as seen from a script-writer's perspective.&nbsp; In particular,
it is possible to designate any <A HREF="#param_out">out</A> method argument
as the method return value for scripting purposes.&nbsp; See the <A HREF="#param_retval">retval</A>
flag.

</BLOCKQUOTE>

<H3><A NAME="ParamDescriptor"></A>ParamDescriptor</H3>

A ParamDescriptor is a variable-size record used to describe either a single
argument to a method or a method's result:
<BLOCKQUOTE>

<PRE><TT>ParamDescriptor {
    boolean         <A HREF="#param_in">in</A>;
    boolean         <A HREF="#param_out">out</A>;
    boolean         <A HREF="#param_retval">retval</A>;
    boolean         <A HREF="#param_shared">shared</A>;
    boolean         <A HREF="#param_dipper">dipper</A>;
    uint3           <A HREF="#reserved6">reserved</A>;
    TypeDescriptor  <A HREF="#ParamDescriptor_type">type</A>;
}</TT></PRE>
</BLOCKQUOTE>

<H4><A NAME="param_in"></A><TT>in</TT></H4>


<BLOCKQUOTE>If <TT>in</TT> is true, it indicates that the parameter is
to be passed from caller to callee.&nbsp; This flag is always false for
a method's <A HREF="#result">result</A>.</BLOCKQUOTE>

<H4><A NAME="param_out"></A><TT>out</TT></H4>


<BLOCKQUOTE>If <TT>out</TT> is true, it indicates that the parameter is to be 
  passed from callee to caller.&nbsp; It is possible for a parameter to have both 
  <TT>out</TT> and <TT>in</TT> bits set.&nbsp; For the actual method <A HREF="#result">result</A>, 
  <TT>out</TT> is always false. Out parameters imply an additional level of indirection 
  than specified by the parameter's TypeDescriptor, e.g. if the parameter's <A HREF="#ParamDescriptor_type">type</A> 
  specifies uint32, the actual type of the argument passed at runtime is a uint32*. 
  Hence out parameters are always pointers.</BLOCKQUOTE>

<H4><A NAME="param_retval"></A><TT>retval</TT></H4>


 <BLOCKQUOTE>If <TT>retval</TT> is true, it indicates that this parameter is to
 be considered the return value of the method for purposes of invocation from a
 scripting language.&nbsp; If the XPCOM method's <A HREF="#result">result</A>
 parameter does not have its <TT>retval</TT> flag set, then the method's return
 value must either be void or an nsresult (a bitfield encoded as a uint32) that
 indicates the success or failure of the method invocation. However, a method
 marked as <A HREF="#is_not_xpcom">is_not_xpcom</A> might have any return type
 and is assumed to not be describable by this typelib information.&nbsp; Note
 that when <TT>retval</TT> is set on a method parameter, the <TT>out</TT> flag
 must also be true.</BLOCKQUOTE>

<H4><A NAME="param_shared"></A><TT>shared</TT></H4>


<BLOCKQUOTE>If <TT>shared</TT> is true, it indicates that this parameter does
  not follow the normal xpcom rules for transfer of ownership of pointer type
  object. It only makes sense to use this with params that are marked <TT>out</TT>
  and which are also pointer type things; e.g. strings. This flag indicates that
  the interface is providing a pointer to its own copy of the data rather that
  making a copy for the caller. This explicitly breaks the xpcom rules. This 
  should be used as little as possible. Still, this flag does allow for this 
  optimization where absolutely necessary.</BLOCKQUOTE>

<H4><A NAME="param_dipper"></A><TT>dipper</TT></H4>


<BLOCKQUOTE>If <TT>dipper</TT> is true, it indicates that this parameter uses a
  special means of being received as an <i>out</i> parameter. The idea is that in
  order to get an <i>out</i> value an object reference (the dipper) is passed
  by the caller as an <i>in</i> parameter of the method call and the value to 
  be received is set in a call to that dipper object. The caller can then examine
  the dipper object to get the received value.
  <p>
  The <TT>dipper</TT> flag should always be used with the <TT>in</TT> flag and
  <em>never</em> with the <TT>out</TT> flag. In practice, we use this parameter 
  passing convention with the <a href="#astring">astring</a> type.</BLOCKQUOTE>


<H4><A NAME="reserved6"></A><TT>reserved</TT></H4>


<BLOCKQUOTE>A 3-bit field reserved for future use.</BLOCKQUOTE>

<H4><A NAME="ParamDescriptor_type"></A><TT>type</TT></H4>


<BLOCKQUOTE>The type of the method parameter.</BLOCKQUOTE>

<H3><A NAME="TypeDescriptor"></A>TypeDescriptor</H3>

A TypeDescriptor is a variable-size record used to identify the type of a method 
argument or return value.&nbsp; There are many categories of XPCOM types that 
need to be represented in the typelib: 
<UL>
  <LI> scalar types, e.g. uint16 or boolean 
  <LI> pointer to a scalar type, e.g. float* 
  <LI> void (only allowed for method return type) 
  <LI> interface pointer 
  <LI> iid_is - that is, an interface pointer with type determined at runtime, 
    or a pointer to such an interface pointer 
  <LI> pointer to an nsIID structure (to act as the parameter to an iid_is) 
  <LI> pointer to an an array with size or size and length information.
</UL>
[<I>Editor: This specification does not yet cover pointers to unions or structs, 
typedefs, or enums.</I>] 
<P><A NAME="variant_TypeDescriptors"></A>To efficiently describe all the
type categories listed above, there are several different variants of TypeDescriptor
records:
<BLOCKQUOTE>
  <PRE><TT>union TypeDescriptor {
    SimpleTypeDescriptor;
    InterfaceTypeDescriptor;
    InterfaceIsTypeDescriptor;
    ArrayTypeDescriptor;
}</TT></PRE></BLOCKQUOTE>
The first byte of all these TypeDescriptor variants has the identical layout:
<BLOCKQUOTE>
  <PRE><TT>TypeDescriptorPrefix {<BR>&nbsp;&nbsp;&nbsp; boolean&nbsp; <A HREF="#is_pointer">is_pointer</A>;<BR>&nbsp;&nbsp;&nbsp; boolean&nbsp; <A HREF="#is_unique_pointer">is_unique_pointer</A>;<BR>&nbsp;&nbsp;&nbsp; boolean&nbsp; <A HREF="#is_reference">is_reference</A>;<BR>&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;&nbsp; <A HREF="#tag">tag</A>;<BR>}</TT></PRE></BLOCKQUOTE>

<H4><A NAME="is_pointer"></A><TT>is_pointer</TT></H4>


<BLOCKQUOTE>This field is true only when representing C pointer/reference
types.</BLOCKQUOTE>

<H4><A NAME="is_unique_pointer"></A><TT>is_unique_pointer</TT></H4>


<BLOCKQUOTE>This field cannot have a value of true unless <TT>is_pointer</TT> 
  is also true.&nbsp; The <TT>unique_pointer</TT> field indicates if the parameter 
  value can be aliased to another parameter value.&nbsp; If <TT>unique_pointer</TT> 
  is true, it must not be possible to reach the memory pointed at by this argument 
  value from any other argument to the method. This flag is used to promote efficiency 
  when marshalling arguments for a remote method invocation.</BLOCKQUOTE>

<H4><A NAME="is_reference"></A><TT>is_reference</TT></H4>


<BLOCKQUOTE>This field cannot have a value of true unless <TT>is_pointer</TT>
is also true.&nbsp; This field is true if the parameter is a reference,
which is to say, it's a pointer that can't have a value of NULL.</BLOCKQUOTE>

<H4><A NAME="tag"></A><TT>tag</TT></H4>


<BLOCKQUOTE>
  <P>The tag field indicates which of the <A HREF="#variant_TypeDescriptors">variant 
    TypeDescriptor records</A> is being used, and hence the way any remaining 
    fields should be parsed. </P>
  <TABLE BORDER ALIGN="CENTER" >
    <TR BGCOLOR="#CCFFFF"> 
      <TD WIDTH="159"> 
        <CENTER>
          <B>&nbsp;Value in <TT>tag</TT> field&nbsp;</B> 
        </CENTER>
      </TD>
      <TD WIDTH="269"> 
        <CENTER>
          <B>&nbsp;TypeDescriptor variant to use&nbsp;</B> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD WIDTH="159"> 
        <CENTER>
          0..17 
        </CENTER>
      </TD>
      <TD WIDTH="269"> 
        <CENTER>
          SimpleTypeDescriptor 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD WIDTH="159"> 
        <CENTER>
          18 
        </CENTER>
      </TD>
      <TD WIDTH="269"> 
        <CENTER>
          InterfaceTypeDescriptor 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD WIDTH="159"> 
        <CENTER>
          19 
        </CENTER>
      </TD>
      <TD WIDTH="269"> 
        <CENTER>
          InterfaceIsTypeDescriptor 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD WIDTH="159"> 
        <CENTER>
          20 
        </CENTER>
      </TD>
      <TD WIDTH="269"> 
        <CENTER>
          ArrayTypeDescriptor 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD WIDTH="159"> 
        <CENTER>
          21 
        </CENTER>
      </TD>
      <TD WIDTH="269"> 
        <CENTER>
          StringWithSizeTypeDescriptor 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD WIDTH="159"> 
        <CENTER>
          22 
        </CENTER>
      </TD>
      <TD WIDTH="269"> 
        <CENTER>
          WideStringWithSizeTypeDescriptor 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD WIDTH="159"> 
        <CENTER>
          23..31 
        </CENTER>
      </TD>
      <TD WIDTH="269"> 
        <CENTER>
          reserved 
        </CENTER>
      </TD>
    </TR>
  </TABLE>
</BLOCKQUOTE>

<H3><A NAME="SimpleTypeDescriptor"></A>SimpleTypeDescriptor</H3>

The one-byte SimpleTypeDescriptor is a kind of <A HREF="#TypeDescriptor">TypeDescriptor</A> 
used to represent scalar types,&nbsp; pointers to scalar types, the <TT>void</TT> 
type and, as a special case, the <TT>nsIID*</TT> type: 
<UL>
  <PRE><TT>SimpleTypeDescriptor {
&nbsp;&nbsp;&nbsp; boolean&nbsp;<A HREF="#is_pointer_and_tag">is_pointer</A>;
&nbsp;&nbsp;&nbsp; boolean&nbsp;<A HREF="#is_unique_pointer">is_unique_pointer</A>;
&nbsp;&nbsp;&nbsp; boolean&nbsp;<A HREF="#is_reference">is_reference</A>;
&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;&nbsp;<A HREF="#is_pointer_and_tag">tag</A>;
}</TT></PRE>
</UL>

<H4><A NAME="is_pointer_and_tag"></A><TT>is_pointer, tag</TT></H4>


<UL>
  The <TT>is_pointer</TT> field is true only when representing C pointer/reference 
  types.&nbsp; The following table indicates the types that can be represented 
  by combining different values for these two fields:<BR>
  <BR>
  <TABLE BORDER WIDTH="80%" >
    <TR BGCOLOR="#CCFFFF"> 
      <TD COLSPAN="3"> 
        <CENTER>
          <B>&nbsp;SimpleTypeDescriptor</B> 
        </CENTER>
      </TD>
    </TR>
    <TR BGCOLOR="#CCFFFF"> 
      <TD> 
        <CENTER>
          <B><TT>&nbsp;is_pointer&nbsp;</TT></B> 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <B><TT>&nbsp;tag&nbsp;</TT></B> 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <B>Type Represented</B> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          0 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int8</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          1 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int16</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          2 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int32</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          3 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int64</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          4 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint8</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          5 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint16</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          6 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint32</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          7 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint64</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          8 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>float</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          9 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>double</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          10 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>boolean </TT><br>(8-bit value)<SUP>1</SUP> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          11 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>char</TT><br>(8-bit character)<SUP>2</SUP>
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          12 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>wchar_t</TT><br>(16-bit character)<SUP>3</SUP> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          13 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>void</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          14 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          reserved 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          15 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          reserved 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <div align="center">false</div>
      </TD>
      <TD> 
        <div align="center">16</div>
      </TD>
      <TD> 
        <div align="center">reserved </div>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <div align="center">false</div>
      </TD>
      <TD> 
        <div align="center">17</div>
      </TD>
      <TD> 
        <div align="center">reserved </div>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          0 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int8*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          1 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int16*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          2 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int32*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          3 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int64*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          4 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint8*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          5 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint16*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          6 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint32*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          7 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint64*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          8 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>float*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          9 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>double*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          10 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>boolean*</TT><br>(pointer to a single 8-bit value)<SUP>1</SUP>
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          11 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>char*</TT><br>(pointer to a single 8-bit character)<SUP>2</SUP> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          12 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>wchar_t*</TT><br>(pointer to a single 16-bit character)<SUP>3</SUP> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          13 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>void*</TT>
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          14 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>nsIID*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          15 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>astring*</TT><SUP>4</SUP> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <div align="center">true</div>
      </TD>
      <TD> 
        <div align="center">16</div>
      </TD>
      <TD> 
        <div align="center"><TT>char*</TT><br>(pointer to a NUL-terminated array)<SUP>2</SUP></div>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <div align="center">true</div>
      </TD>
      <TD> 
        <div align="center">17</div>
      </TD>
      <TD> 
        <div align="center"><TT>wchar_t*</TT><br>(pointer to a NUL-terminated array)<SUP>3</SUP></div>
      </TD>
    </TR>
  </TABLE>
  <br>
  <SUP>1</SUP>Type <i>boolean</i> values are always passed as 8-bit values. They
  can contain 0 (zero) to represent <i>false</i> or 1 (one) to represent 
  <i>true</i>. Other values are undefined.
  <P>
  <SUP>2</SUP>Type <i>char</i> values are always passed as 8-bit values. They
  can hold 7-bit ASCII characters only. Other character encodings 
  (e.g. UTF-8) are not supported by <i>char</i>.
  <P>
  <SUP>3</SUP>We use <i>wchar_t</i> here to specifically mean a 16-bit data 
  type. This is true even though <i>wchar_t</i> as a native type is implemented 
  on some platforms using something other than a 16-bit data type. Each 
  <i>wchar_t</i> character holds one Unicode character.  
  <P>
  <a name="astring"></a>
  <SUP>4</SUP>The type <TT>astring*</TT> represents a pointer the C++ abstract 
  <TT>nsAString</TT> class. See the nsAString 
  <a href="http://lxr.mozilla.org/seamonkey/source/string/doc/string-guide.html">documentation</a>
  and 
  <a href="http://lxr.mozilla.org/seamonkey/source/string/public/nsAString.h">declarations</a>.
  <BR><i><b>Note</b> that this type uses the tag previously assigned to the (never implmented) 
  support for BSTR.</i> 
  <BR><i><b>Note</b> that this type is sometimes called <TT>domstring</TT>.</i>
</UL>

<H3><A NAME="InterfaceTypeDescriptor"></A>InterfaceTypeDescriptor</H3>

An InterfaceTypeDescriptor is used to represent a pointer to an interface type, 
e.g. <TT>nsISupports*</TT><TT>:</TT> 
<BLOCKQUOTE>
  <PRE><TT>InterfaceTypeDescriptor {
    boolean <A HREF="#InterfaceTypeDescriptor_is_pointer">is_pointer</A>;     // 1
    boolean <A HREF="#is_unique_pointer">is_unique_pointer</A>;
    boolean <A HREF="#is_reference">is_reference</A>;
    uint5   <A HREF="#InterfaceTypeDescriptor_tag">tag</A>;     // 18
    uint16  <A HREF="#InterfaceTypeDescriptor_interface_index">interface_index</A>;
}</TT></PRE>
</BLOCKQUOTE>

<H4><A NAME="InterfaceTypeDescriptor_is_pointer"></A><TT>is_pointer</TT></H4>


<BLOCKQUOTE>Must always be 1 (true).</BLOCKQUOTE>

<H4><A NAME="InterfaceTypeDescriptor_tag"></A><TT>tag</TT></H4>


<BLOCKQUOTE>The tag field must have the decimal value 18.</BLOCKQUOTE>

<H4><A NAME="InterfaceTypeDescriptor_interface_index"></A>interface_index</H4>


<BLOCKQUOTE>This field specifies a index into the <A HREF="#interface_directory">interface_directory</A>, 
  thus identifying an InterfaceDirectoryEntry. The first entry in the interface_directory 
  has index 1. Note that the value is specified in terms of table entries, not 
  bytes.</BLOCKQUOTE>

<H3><A NAME="InterfaceIsTypeDescriptor"></A>InterfaceIsTypeDescriptor</H3>

An InterfaceIsTypeDescriptor describes an interface pointer type.
It is similar to an <A HREF="#InterfaceTypeDescriptor">InterfaceTypeDescriptor</A>
except that the type of the interface pointer is specified at runtime by
the value of another argument, rather than being specified by the typelib.
<BLOCKQUOTE> 
  <PRE><TT>InterfaceIsTypeDescriptor {
    boolean  <A HREF="#InterfaceIsTypeDescriptor_is_pointer">is_pointer</A>;   // 1
    boolean  <A HREF="#is_unique_pointer">is_unique_pointer</A>;
    boolean  <A HREF="#is_reference">is_reference</A>;
    uint5    <A HREF="#InterfaceIsTypeDescriptor_tag">tag</A>;    //19
    uint8    <A HREF="#InterfaceIsTypeDescriptor_arg_num">arg_num</A>;
}</TT></PRE>
</BLOCKQUOTE>
<H4><A NAME="InterfaceIsTypeDescriptor_is_pointer"></A><TT>is_pointer</TT></H4>
<BLOCKQUOTE>
  <P>Must always be 1 (true).</P>
</BLOCKQUOTE>

<H4><A NAME="InterfaceIsTypeDescriptor_tag"></A><TT>tag</TT></H4>


<BLOCKQUOTE>The tag field must have the decimal value 19.</BLOCKQUOTE>

<H4><A NAME="InterfaceIsTypeDescriptor_arg_num"></A><TT>arg_num</TT></H4>


<BLOCKQUOTE>The zero-based index of the method argument that describes
the type of the interface pointer.&nbsp; The specified method argument
must have type
<TT>nsIID*</TT>.</BLOCKQUOTE>

<H3><A NAME="ArrayTypeDescriptor"></A>ArrayTypeDescriptor</H3>

An ArrayTypeDescriptor describes an array. Arrays are assumed to be allocated
just like other pointer type objects. An array may contain a homeogenous series 
of any type that can appear in a parameter list. Array parameters are always 
associated with some other parameter whose value indicates the size of the 
array; i.e. how many elements the array contains.

<BLOCKQUOTE> 
  <PRE><TT>ArrayTypeDescriptor {
    boolean         <A HREF="#ArrayTypeDescriptor_is_pointer">is_pointer</A>;   // 1
    boolean         <A HREF="#is_unique_pointer">is_unique_pointer</A>;
    boolean         <A HREF="#is_reference">is_reference</A>;
    uint5           <A HREF="#ArrayTypeDescriptor_tag">tag</A>;    //20
    uint8           <A HREF="#ArrayTypeDescriptor_size_is_arg_num">size_is_arg_num</A>;
    uint8           <A HREF="#ArrayTypeDescriptor_length_is_arg_num">length_is_arg_num</A>;
    <A HREF="#TypeDescriptor">TypeDescriptor</A>  <A HREF="#ArrayTypeDescriptor_type_descriptor">type_descriptor</A>;
}</TT></PRE>
</BLOCKQUOTE>

<H4><A NAME="ArrayTypeDescriptor_is_pointer"></A><TT>is_pointer</TT></H4>
<BLOCKQUOTE>
  <P>Must always be 1 (true).</P>
</BLOCKQUOTE>

<H4><A NAME="ArrayTypeDescriptor_tag"></A><TT>tag</TT></H4>

<BLOCKQUOTE>The tag field must have the decimal value 20.</BLOCKQUOTE>

<H4><A NAME="ArrayTypeDescriptor_size_is_arg_num"></A><TT>size_is_arg_num</TT></H4>

<BLOCKQUOTE>The zero-based index of the method argument that describes
the count of elements in the array. The specified method argument
must have type <TT>uint32</TT>.</BLOCKQUOTE>

<H4><A NAME="ArrayTypeDescriptor_length_is_arg_num"></A><TT>length_is_arg_num</TT></H4>

<BLOCKQUOTE>The zero-based index of the method argument that describes
the count of elements in the array which are 'significant'. This allows for 
reusing a buffer which might get passed back and forth. While the size_is 
parameter allows for tracking the size of the buffer, the length_is parameter
allows for tracking how many elements in the buffer are currently 'valid'. This
may specify the same parameter that is used for 
<A HREF="#ArrayTypeDescriptor_size_is_arg_num">size_is_arg_num</A>.
The specified method argument must have type <TT>uint32</TT>.</BLOCKQUOTE>

<H4><A NAME="ArrayTypeDescriptor_type_descriptor"></A><TT>type_descriptor</TT></H4>

<BLOCKQUOTE>This describes the type of the elements in the array. Any type that
can be used as a parameter is allowed <b>except</b> the types
<TT>ArrayTypeDescriptor</TT>, <TT>StringWithSizeTypeDescriptor</TT>, and 
<TT>WideStringWithSizeTypeDescriptor</TT>. 
This means that for this version of the spec multidimensional arrays are 
not supported. However, some future version may relax this restriction and 
allow for multidimensional arrays.</BLOCKQUOTE>

<H3><A NAME="StringWithSizeTypeDescriptor"></A>StringWithSizeTypeDescriptor</H3>

A StringWithSizeTypeDescriptor describes a string that has extra information
which indicates which parameters will at runtime have information about the
string's size and length. This is very much like an ArrayTypeDescriptor with
a type of <tt>char</tt> except that some language mappings may choose to map
this type with language specific string semantics rather than array-of-char sematics.

<BLOCKQUOTE> 
  <PRE><TT>StringWithSizeTypeDescriptor {
    boolean         <A HREF="#StringWithSizeTypeDescriptor_is_pointer">is_pointer</A>;   // 1
    boolean         <A HREF="#is_unique_pointer">is_unique_pointer</A>;
    boolean         <A HREF="#is_reference">is_reference</A>;
    uint5           <A HREF="#StringWithSizeTypeDescriptor_tag">tag</A>;    //21
    uint8           <A HREF="#StringWithSizeTypeDescriptor_size_is_arg_num">size_is_arg_num</A>;
    uint8           <A HREF="#StringWithSizeTypeDescriptor_length_is_arg_num">length_is_arg_num</A>;
}</TT></PRE>
</BLOCKQUOTE>

<H4><A NAME="StringWithSizeTypeDescriptor_is_pointer"></A><TT>is_pointer</TT></H4>
<BLOCKQUOTE>
  <P>Must always be 1 (true).</P>
</BLOCKQUOTE>

<H4><A NAME="StringWithSizeTypeDescriptor_tag"></A><TT>tag</TT></H4>

<BLOCKQUOTE>The tag field must have the decimal value 21.</BLOCKQUOTE>

<H4><A NAME="StringWithSizeTypeDescriptor_size_is_arg_num"></A><TT>size_is_arg_num</TT></H4>

<BLOCKQUOTE>The zero-based index of the method argument that describes the count
of chars in the string. The specified method argument must have type
<TT>uint32</TT>. The runtime value of the referenced parameter is the count of
actual characters and does not include any extra space that might be required
for zero termintaion.</BLOCKQUOTE>

<H4><A NAME="StringWithSizeTypeDescriptor_length_is_arg_num"></A><TT>length_is_arg_num</TT></H4>

<BLOCKQUOTE>The zero-based index of the method argument that describes the count
of chars in the string which are 'significant'. This allows for  reusing a
buffer which might get passed back and forth. While the size_is  parameter
allows for tracking the size of the buffer, the length_is parameter allows for
tracking how many elements in the buffer are currently 'valid'. This may specify
the same parameter that is used for  <A
HREF="#StringWithSizeTypeDescriptor_size_is_arg_num">size_is_arg_num</A>. The
specified method argument must have type <TT>uint32</TT>. The runtime value of
the referenced parameter is the count of actual characters and does not include
any extra space that might be required for zero termintaion.</BLOCKQUOTE>


<H3><A NAME="WideStringWithSizeTypeDescriptor"></A>WideStringWithSizeTypeDescriptor</H3>

A WideStringWithSizeTypeDescriptor is just like a StringWithSizeTypeDescriptor
except that the elements are <tt>wchar_t</tt> rather than <tt>char</tt>. It
describes a wide string that has extra information which indicates which
parameters will at runtime have information about the string's size and length.
This is very much like an ArrayTypeDescriptor with a type of <tt>wchar_t</tt>
except that some language mappings may choose to map this type with language
specific wide string semantics rather than array-of-wchar_t sematics.

<BLOCKQUOTE> 
  <PRE><TT>WideStringWithSizeTypeDescriptor {
    boolean         <A HREF="#WideStringWithSizeTypeDescriptor_is_pointer">is_pointer</A>;   // 1
    boolean         <A HREF="#is_unique_pointer">is_unique_pointer</A>;
    boolean         <A HREF="#is_reference">is_reference</A>;
    uint5           <A HREF="#WideStringWithSizeTypeDescriptor_tag">tag</A>;    //22
    uint8           <A HREF="#WideStringWithSizeTypeDescriptor_size_is_arg_num">size_is_arg_num</A>;
    uint8           <A HREF="#WideStringWithSizeTypeDescriptor_length_is_arg_num">length_is_arg_num</A>;
}</TT></PRE>
</BLOCKQUOTE>

<H4><A NAME="WideStringWithSizeTypeDescriptor_is_pointer"></A><TT>is_pointer</TT></H4>
<BLOCKQUOTE>
  <P>Must always be 1 (true).</P>
</BLOCKQUOTE>

<H4><A NAME="WideStringWithSizeTypeDescriptor_tag"></A><TT>tag</TT></H4>

<BLOCKQUOTE>The tag field must have the decimal value 22.</BLOCKQUOTE>

<H4><A NAME="WideStringWithSizeTypeDescriptor_size_is_arg_num"></A><TT>size_is_arg_num</TT></H4>

<BLOCKQUOTE>The zero-based index of the method argument that describes the count
of char in the string. The specified method argument must have type
<TT>uint32</TT>. The runtime value of the referenced parameter is the count of
actual characters and does not include any extra space that might be required
for zero termintaion.</BLOCKQUOTE>

<H4><A NAME="WideStringWithSizeTypeDescriptor_length_is_arg_num"></A><TT>length_is_arg_num</TT></H4>

<BLOCKQUOTE>The zero-based index of the method argument that describes the count
of chars in the string which are 'significant'. This allows for  reusing a
buffer which might get passed back and forth. While the size_is  parameter
allows for tracking the size of the buffer, the length_is parameter allows for
tracking how many elements in the buffer are currently 'valid'. This may specify
the same parameter that is used for  <A
HREF="#WideStringWithSizeTypeDescriptor_size_is_arg_num">size_is_arg_num</A>.
The specified method argument must have type <TT>uint32</TT>. The runtime value
of the referenced parameter is the count of actual characters and does not
include any extra space that might be required for zero
termintaion.</BLOCKQUOTE>


<H3><A NAME="Identifier"></A>Identifier</H3>
Identifier records are used to represent variable-length, human-readable strings: 
<BLOCKQUOTE><TT>Identifier {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; <A HREF="#InternedString_bytes">bytes</A>[];</TT>
<BR><TT>}</TT></BLOCKQUOTE>

<H4><A NAME="InternedString_bytes"></A><TT>bytes</TT></H4>


<BLOCKQUOTE>Unicode string encoded in UTF-8 format, NUL-terminated.</BLOCKQUOTE>

<H3><A NAME="String"></A>String</H3>

String records are used to represent variable-length, human-readable strings,
possibly with embedded NUL's:
<BLOCKQUOTE>
  <PRE><TT>String {<BR>&nbsp;&nbsp;&nbsp; uint16 <A HREF="#InternedString_length">length</A>;<BR>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; <A HREF="#InternedString_bytes">bytes</A>[length];<BR>}</TT></PRE></BLOCKQUOTE>

<H4><A NAME="InternedString_length"></A><TT>length</TT></H4>


<BLOCKQUOTE>The length of the string, in characters (not bytes).</BLOCKQUOTE>

<H4><A NAME="InternedString_bytes"></A><TT>bytes</TT></H4>


<BLOCKQUOTE>Unicode string encoded in UTF-8 format, with no null-termination.
The length of the bytes array, measured in Unicode characters (not bytes),
is reported by the <TT>length</TT> field.</BLOCKQUOTE>

<H3><A NAME="Annotation"></A>Annotation</H3>

Annotation records are variable-size records used to store secondary information
about the typelib, e.g. such as the name of the tool that generated the
typelib file, the date it was generated, etc.&nbsp; The information is
stored with very loose format requirements so as to allow virtually any
private data to be stored in the typelib.
<BLOCKQUOTE>
  <PRE><TT>union Annotation {<BR>&nbsp;&nbsp;&nbsp; EmptyAnnotation<BR>&nbsp;&nbsp;&nbsp; PrivateAnnotation<BR>}

EmptyAnnotation {<BR>&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp; <A HREF="#Annotation_is_last">is_last</A>;<BR>&nbsp;&nbsp;&nbsp; uint7&nbsp;&nbsp;&nbsp;&nbsp; <A HREF="#Annotation_tag">tag</A>;            // 0<BR>}

<P>PrivateAnnotation {<BR>&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp; <A HREF="#Annotation_is_last">is_last</A>;<BR>&nbsp;&nbsp;&nbsp; uint7&nbsp;&nbsp;&nbsp;&nbsp; <A HREF="#Annotation_tag">tag</A>;            // 1<BR>&nbsp;&nbsp;&nbsp; String&nbsp;&nbsp;&nbsp; <A HREF="#Annotation_creator">creator</A>;<BR>&nbsp;&nbsp;&nbsp; String&nbsp;&nbsp;&nbsp; <A HREF="#Annotation_private_data">private_data</A>;<BR>}</TT></PRE></BLOCKQUOTE>

<H4><TT><A NAME="Annotation_is_last"></A>is_last</TT></H4>


<BLOCKQUOTE>When true, no more Annotation records follow the current record.
If false, at least one Annotation record appears immediately after the
current record.</BLOCKQUOTE>

<H4><A NAME="Annotation_tag"></A><TT>tag</TT></H4>


<BLOCKQUOTE>The tag field discriminates among the variant record types
for Annotation's.&nbsp; If the tag is 0, this record is an EmptyAnnotation.
EmptyAnnotation's are ignored - they're only used to indicate an array
of Annotation's that's completely empty.&nbsp; If the tag is 1, the record
is a PrivateAnnotation.</BLOCKQUOTE>

<H4><A NAME="Annotation_creator"></A><TT>creator</TT></H4>


<BLOCKQUOTE>A string that identifies the application/tool/code that created
the annotation, e.g. "XPIDL Compiler, Version 1.2".&nbsp; There are no
rules about the contents of the <TT>creator</TT> string other than that
it be human-readable.</BLOCKQUOTE>

<H4><A NAME="Annotation_private_data"></A><TT>private_data</TT></H4>


<BLOCKQUOTE>An opaque data array that is put into the typelib by the application/tool/code
that created the typelib.&nbsp; There are no restrictions on the format
of the <TT>private_data</TT>.</BLOCKQUOTE>
<H3><a name="Document_History"></a>Document History</H3>


<BLOCKQUOTE> 
  <h4>Version 1.1, Draft 1 (07 May 2001) [jband]</h4>
  <UL>
    <LI> Added <TT>is_function</TT>.
    <LI> Added <TT>astring</TT>.
    <LI> Added <TT>is_dipper</TT>.
  </UL>
<hr>
  <h4>Version 1.0, Draft 10 (27 April 2000) [jband] -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d9.html">http://mozilla.org/scriptable/typelib_file_v1_d10.html</a></h4>
  <UL>
    <LI> <b>This draft reflects typelibs as shipped with Netscape6 and through Mozilla 0.9</b>
    <LI> Fixed Blackwood link.
    <LI> Added tighter specification of <i>boolean</i>
    <LI> Added tighter specification of <i>char</i>
    <LI> Added tighter specification of <i>wchar_t</i>
  </UL>
  <h4>Version 1.0, Draft 9 (19 September 99) [jband] -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d9.html">http://mozilla.org/scriptable/typelib_file_v1_d9.html</a></h4>
  <UL>
    <LI>Combined ArrayWithLengthTypeDescriptor into ArrayTypeDescriptor.
    <LI>Added StringWithSizeTypeDescriptor and WideStringWithSizeTypeDescriptor.
    <LI>Added reserved field to InterfaceDescriptor to pad record to 8-bit 
    boundary.
    <LI>Added note that records are 8-bit aligned.
    <LI>Specified ordering of getter and setter MethodDecriptors.
    <LI>Removed VarArgs issue from 'Known Issues' section.
  </UL>
  <h4>Version 1.0, Draft 8 (10 September 99) [jband] -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d8.html">http://mozilla.org/scriptable/typelib_file_v1_d8.html</a></h4>
  <UL>
    <LI>Added ArrayTypeDescriptor and ArrayWithLengthTypeDescriptor.
    <LI>Removed OpaqueTypeDescriptor, NamedTypeDescriptor, EnumTypeDescriptor,
    and TypeDef. These were not implemented. They may well reappear in a subsequent
    version of the spec.
    <LI>Re-added void* as a supported type.
    <LI>Added <TT>shared</TT> as a flag for ParamDescriptor.
    <LI>Added <TT>is_not_xpcom</TT> as a flag for MethodDescriptor.
    <LI>Changed definition of 'unresolved' to include the case where both name 
    and iid are known.
    <LI>Added flags to InterfaceDescriptor.
    <LI>Narrowed the list of supported const types to match the implementation.
    <LI>Note the fact that typelibs are used by technologies other than xpconnect.
    <LI>Fixed various typos.
  </UL>
  <h4>Version 1.0, Draft 7 (3/11/98)  -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d7.html">http://mozilla.org/scriptable/typelib_file_v1_d7.html</a></h4>
  <UL>
    <LI>InterfaceTypeDescriptors now always represent a pointer to an interface 
      and never a pointer to a pointer to an interface type. The <TT>is_pointer</TT> 
      flag on an InterfaceTypeDescriptor is always set.</LI>
    <LI>Eliminated <TT>is_varargs</TT> flag from MethodDescriptor. Methods with 
      variable numbers of arguments cannot be expressed directly using XPIDL.</LI>
    <LI>Eliminated void* type from SimpleTypeDescriptor. Use of a void* as an 
      XPCOM method parameter is discouraged, but if it must be done, it should 
      be encoded using an OpaqueTypeDescriptor record.<BR>
    </LI>
  </UL>
  <h4>Version 1.0, Draft 6(3/9/98)  -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d6.html">http://mozilla.org/scriptable/typelib_file_v1_d6.html</a></h4>
  <UL>
    <LI>Added <A HREF="#TypeDef">TypeDef</A> records which contains module-wide 
      XPCOM type definitions, i.e. equivalent to C++ typedefs.</LI>
    <LI>Added support for native (opaque) types, named types (references to typedefs), 
      and enumeration types in method parameters. See <A HREF="#OpaqueTypeDescriptor">OpaqueTypeDescriptor</A>, 
      <A HREF="#NamedTypeDescriptor">NamedTypeDescriptor</A>, and <A HREF="#EnumTypeDescriptor">EnumTypeDescriptor</A>.</LI>
    <LI>Shaver and jband pointer out a screwup in ParamDescriptors: Out parameters 
      should imply an additional level of indirection than specified by the parameter's 
      TypeDescriptor, e.g. if the parameter's <A HREF="#ParamDescriptor_type">type</A> 
      specifies uint32, the actual type of the argument passed at runtime is a 
      uint32*.</LI>
    <LI>The 16-bit interface_directory table offsets were made one-based rather 
      than zero-based, so that it's possible to specify a null interface as the 
      parent of nsISupports. </LI>
    <LI> parent_interface should be a 16-bit interface_directory table offset, 
      not a 32-bit file offset, in keeping with the changes made in draft 5.</LI>
  </UL>
  <h4>Version 1.0, Draft 5(1/24/98)  -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d5.html">http://mozilla.org/scriptable/typelib_file_v1_d5.html</a></h4>
  <UL>
    <LI>References to a given InterfaceDirectoryEntry's were changed from a 32-bit 
      file offset to a 16-bit table offset.</LI>
  </UL>
  <h4>Version 1.0, Draft 4 (1/14/98)  -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d4.html">http://mozilla.org/scriptable/typelib_file_v1_d4.html</a></h4>
  <ul>
    <li>Changed to big-endian layout due to arm-twisting. (Note resulting change 
      to IID layout.)</li>
    <li>Changed entries in SimpleTypeDescriptor table to distinguish between a 
      pointer to a single character and a pointer to a null-terminated array of 
      characters, both for 8-bit and 16-bit characters. This also resulted in 
      changes to the tag member of the TypeDescriptor field for InterfaceTypeDescriptor 
      and InterfaceIsTypeDescriptor.</li>
    <li>Changed string type in SimpleTypeDescriptor to BSTR, since it's starting 
      to look like this is what we may standardize on for XPCOM strings.</li>
    <li>Added interface namespace field to the InterfaceDirectoryEntry, aka CORBA 
      modules, aka MIDL libraries. This is to allow for identically-named interfaces 
      that don't clash.</li>
    <li>Added 'is_hidden' bit to MethodDescriptor for methods that are not exposed 
      to script authors.</li>
    <li>Moved Document History and Known Issues to bottom of spec.<br>
    </li>
  </ul>
  <h4>Version 1.0, Draft 3 (1/5/98) -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d3.html">http://mozilla.org/scriptable/typelib_file_v1_d3.html</a></H4>
</BLOCKQUOTE>
<BLOCKQUOTE> 
  <BLOCKQUOTE> 
    <LI> Added 'retval' flag and massaged description of 'in' and 'out' flags 
      in the ParamDescriptor record. 
    <LI> Fixed errors in descriptions of 'params' and 'result' members of the 
      MethodDescriptor and in the description of 'method_descriptors' and 'const_descriptors' 
      members of the InterfaceDescriptor record.&nbsp; (In all cases, these members 
      were incorrectly described as byte offsets to other records even though 
      the data layout notation indicated that they were stored inline.) 
  </BLOCKQUOTE>
  <h4>Version 1.0, Draft 2 (12/16/98) -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d2.html">http://mozilla.org/scriptable/typelib_file_v1_d2.html</a></H4>
  <BLOCKQUOTE> 
    <LI> Added "Document History" and "Known Issues" sections. 
    <LI> Tweaked introduction. 
    <LI> Changed pointers to InterfaceDescriptor records to instead point to InterfaceDirectoryEntry's 
      so as to allow late-binding of interfaces using only the interface name. 
      The interface name was moved from the InterfaceDescriptor to the InterfaceDirectoryEntry 
      for the same reason. 
    <LI> Changed the description of the parent_interface field of InterfaceDescriptor 
      so that its use is not optional. 
    <LI> Updated is_getter and is_setter text to be less confusing about whether 
      or not method name prefixes are stored for getters and setters.&nbsp; (They're 
      not.) 
    <LI> Added is_varargs and is_constructor flags to MethodDescriptor. 
    <LI> Added support for scoped interface constants. 
    <LI> Nearly all uses of the String record type were changed to Identifier. 
      Identifiers are NUL-terminated UTF-8 string records.&nbsp; That means you 
      can't store embedded NUL characters in an identifier (method or interface 
      name), but they're one byte shorter because the string length isn't stored 
      as part of the record. 
    <LI> Added support for private data to be attached to typelib files (Annotation 
      records) 
  </BLOCKQUOTE>
  <h4>Version 1.0, Draft 1 (12/13/98) -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d1.html">http://mozilla.org/scriptable/typelib_file_v1_d1.html</a></h4>
</BLOCKQUOTE>

<H3><a name="Known_Issues"></a>Known Issues</H3>
<UL>
  <LI> There is no support yet in the typelib for pointers to unions or structs. 
    Also no support for array slices. 
  <LI> The common string type(s) that will be passed around in XPCOM methods still 
    seems to be up in the air.&nbsp; (nsString, nsIString, STL strings, ?) Until 
    that's resolved, the TypeDescriptor just uses "string" to represent that type.&nbsp; 
    Depending on what's decided, we may end up adding more than one string type. 
</UL>


</BODY>
</HTML>
