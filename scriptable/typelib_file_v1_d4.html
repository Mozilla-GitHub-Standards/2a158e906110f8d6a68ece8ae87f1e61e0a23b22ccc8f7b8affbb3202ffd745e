<HTML>
<HEAD>
   <META NAME="Author" CONTENT="Scott Furman">
   <TITLE>XPCOM Type Library File Format, Version 1.0</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000"
      LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">

<H1 ALIGN=CENTER>XPCOM Type Library<BR>
File Format</H1>

<H4 ALIGN=CENTER>Version 1.0, Draft 4</H4>

<CENTER>Last updated:&nbsp;<SCRIPT>
document.write(document.lastModified);
</SCRIPT>

<BR>Author: <A HREF="mailto:fur@netscape.com">Scott Furman &lt;fur@netscape.com></A></CENTER>

<p>
Latest version:<br> 
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://mozilla.org/scriptable/typelib_file.html">http://mozilla.org/scriptable/typelib_file.html</a>
</p>

<H3><a href="#Document_History">Document History</a></H3>
<H3><a href="#Known_Issues">Known Issues</a></H3>
<H3>Introduction</H3>
XPCOM type libraries, or "typelibs", are binary interface description files
generated by the <A HREF="xpidl/index.html">XPIDL</A> compiler. Type libraries
enumerate the methods of one or more interfaces, including detailed type
information for each method parameter. The typelib is not merely a tokenized
form of the IDL.&nbsp; Rather, it's intended to accurately represent binary
XPCOM interfaces, with annotations derived from the IDL.

<P>Typelibs might be more aptly named "interface libraries", but Microsoft
has already established a precedent with their naming scheme and we'll
stick with it to avoid developer confusion.
<H3>Goals</H3>


<UL>
<LI>
Represent all type information that is required for <A HREF="index.html">XPCOMConnect</A>
to enable access to COM objects from JS and vice-versa

<LI>
Map an IID to an interface description quickly

<LI>
Allow for efficiency when interfaces are sparsely used, i.e. without requiring
the entire typelib to be parsed or retained in memory.

<LI>
Use a compact file format, so as to accommodate hundreds of interfaces
and thousands of methods.

<LI>
Allow for extensibility, so as to accommodate future additions to XPIDL
</UL>

<H3>Non-goals</H3>


<UL>
<LI>
Ability to reconstruct XPIDL source from type library

<LI>
Human-readable format

<LI>
File-level compatibility with MS typelibs
</UL>

<H3>Notation</H3>

The syntax used in this document to specify the layout of file data appears
similar to C structs. Unlike C structs, however, data members are not subject
to alignment restrictions.&nbsp; Another difference from C structs is the
use of pointer notation to represent 32-bit file offsets. For example,
<UL><TT>uint16 *ByteOffsetTo16BitValue</TT></UL>
specifies a 32-bit field that contains the offset, in bytes to an array
of one or more 16-bit values.&nbsp;&nbsp; Unless otherwise noted, all file
offsets are byte offsets from the beginning of the <A HREF="#data_pool">data
pool</A>&nbsp; and are 32-bit signed quantities.&nbsp; The first byte of
the data pool is at offset 1, so as to allow offset 0 to be used as a special
indicator.&nbsp; By adding in an appropriate constant, these offsets are
appropriate as arguments to <TT>seek()</TT>.

<P>Record fields with type <TT>boolean</TT> occupy one bit, not one byte.
A value of 1 represents true and a value of 0 represents false.

<P>All integer fields with multibyte precision are stored in big-endian order, 
  e.g. for a uint16 field, the high-order byte is stored in the file followed 
  by the low-order byte. 
<H3>Filename Suffix</H3>

The standard suffix for XPCOM type libraries is <TT>.xpt</TT>.<I> [Editor:
Do we need to define a standard four-character Mac signature/creator ?]</I>
<H3><A NAME="File_Header"></A>File Header</H3>

Every XPCOM typelib file begins with a header:
<BLOCKQUOTE>

<PRE><TT>TypeLibHeader {
    char                     <A HREF="#magic">magic[16]</A>;
    uint8                    <A HREF="#version">major_version</A>;
    uint8                    <A HREF="#version">minor_version</A>;
    uint16                   <A HREF="#num_interfaces">num_interfaces</A>;
    uint32                   <A HREF="#file_length">file_length</A>;
    <A HREF="#InterfaceDirectoryEntry">InterfaceDirectoryEntry</A>* <A HREF="#InterfaceDirectoryEntry">interface_directory</A>;
    uint8*                   <A HREF="#data_pool">data_pool</A>;

    <A HREF="#Annotation">Annotation</A>               <A HREF="#FileHeader_annotations">annotations</A>[];
}</TT></PRE>
</BLOCKQUOTE>

<H4><A NAME="magic"></A><TT>magic</TT></H4>


<BLOCKQUOTE>The first 16 bytes of the file always contain the following
values:

<PRE><TT>       (hex) 58 50 43 4f 4d 0a 54 79 70 65 4c 69 62  0d 0a   1a
(C notation)  X  P  C  O  M \n  T  y  p  e  L  i  b  \r \n \032</TT></PRE>
This signature both identifies the file as an XPCOM typelib file and provides
for immediate detection of common file-transfer problems, i.e. treatment
of a binary file as if it was a text file. The CR-LF sequence catches file
transformations that alter newline sequences. The control-Z character stops
file display under MS-DOS. The linefeed in the sixth character checks for
the inverse of the CR-LF translation problem. (<I>A nod to the PNG folks
for the inspiration behind using these special characters in the header.</I>)</BLOCKQUOTE>

<H4><A NAME="version"></A><TT>major_version, minor_version</TT></H4>


<BLOCKQUOTE>These are the major and minor version numbers of the typelib
file format. For this specification <TT>major_version</TT> is 0x01 and
<TT>minor_version</TT>
is 0x00. TypeLib files that share the same major version but have different
minor versions are compatible. Changes to the major version represent typelib
file formats that are not backward-compatible with parsers designed only
to read earlier major versions. If a typelib file is encountered with a
major version for which support is not available, the rest of the file
should not be parsed.</BLOCKQUOTE>

<H4><A NAME="num_interfaces"></A><TT>num_interfaces</TT></H4>


<BLOCKQUOTE>This indicates the number of <A HREF="#InterfaceDirectoryEntry">InterfaceDirectoryEntry</A>
records that are at the offset indicated by the <TT>interface_directory</TT>
field.</BLOCKQUOTE>

<H4><A NAME="interface_directory"></A><TT>interface_directory</TT></H4>


<BLOCKQUOTE>This field specifies a zero-relative byte offset from the beginning
of the file.&nbsp; It identifies the start of an array of InterfaceDirectoryEntry
records.&nbsp; If <TT>num_interfaces</TT> is zero, then this field should
also be zero.&nbsp; The value of this field should be a multiple of 4,
i.e. the interface directory must be aligned on a 4-byte boundary.
(This is to guarantee aligned access if the typelib file is mmap'ed into
memory.)</BLOCKQUOTE>

<H4><A NAME="file_length"></A><TT>file_length</TT></H4>


<BLOCKQUOTE>Total length of the typelib file, in bytes. This value can
be compared to the length of the file reported by the OS so as to detect
file truncation.</BLOCKQUOTE>

<H4><A NAME="data_pool"></A><TT>data_pool</TT></H4>


<BLOCKQUOTE>The data pool is a heap-like storage area that is the container
for most kinds of typelib data including, but not limited to <A HREF="#InterfaceDescriptor">InterfaceDescriptor</A>,
<A HREF="#MethodDescriptor">MethodDescriptor</A>,
<A HREF="#ParamDescriptor">ParamDescriptor</A>,
and <A HREF="#TypeDescriptor">TypeDescriptor</A> records.&nbsp; Note that,
unlike most file offsets in a typelib, the value of <TT>data_pool</TT>
is zero-relative to the beginning of the file.</BLOCKQUOTE>

<H4><A NAME="FileHeader_annotations"></A><TT>annotations</TT></H4>


<BLOCKQUOTE>A variable-length array of variable-size records used to store
secondary information, e.g. such as the name of the tool that generated
the typelib file, the date it was generated, etc.</BLOCKQUOTE>

<H3><A NAME="InterfaceDirectoryEntry"></A>InterfaceDirectoryEntry</H3>

A contiguous array of fixed-size InterfaceDirectoryEntry records begins
at the byte offset identified by the <TT><A HREF="#interface_directory">interface_directory</A></TT>
field in the <A HREF="#File_Header">file header</A>.&nbsp; The array is
used to quickly locate an interface description using its IID.&nbsp; No
interface should appear more than once in the array.
<BLOCKQUOTE> 
  <PRE><TT>InterfaceDirectoryEntry {
    uint128              <A HREF="#iid">iid</A>;
    <A HREF="#Identifier">Identifier</A>*          <A HREF="#InterfaceDirectoryEntry_name">name</A>;
    <a href="#Identifier">Identifier</a>*          <a href="#InterfaceDirectoryEntry_namespace">namespace</a>;
    <A HREF="#InterfaceDescriptor">InterfaceDescriptor</A>* <A HREF="#interface_descriptor">interface_descriptor</A>;
}</TT></PRE>
</BLOCKQUOTE>
An interface is said to be unresolved if its name is known, e.g. "nsISupports", 
but its IID and methods have not yet been determined.&nbsp; In that case, both 
the <TT>iid</TT> and the <TT>interface_descriptor</TT> field will be set to zero.&nbsp; 
If an interface is unresolved, then its typelib must be linked with another typelib 
to resolve the interface, namely the one that contains a resolved InterfaceDirectoryEntry 
that matches the specified <tt>name</tt> and <tt>namespace</tt>. 
<P>A pointer to an InterfaceDirectoryEntry is always relative to the beginning
of the file.&nbsp; (This is different from other pointers in the typelib
file, which are relative to the byte immediately before the <A HREF="#data_pool">data
pool</A>.)
<H4><A NAME="iid"></A><TT>iid</TT></H4>


<BLOCKQUOTE>The iid field contains a 128-bit value representing the interface
ID. The iid is created from an IID by concatenating the individual bytes
of an IID in a particular order. For example, this IID:
<BLOCKQUOTE><TT>{00112233-4455-6677-8899-aabbccddeeff}</TT></BLOCKQUOTE>
is converted to the 128-bit value
  <BLOCKQUOTE><TT>0x00112233445566778899aabbccddeeff</TT></BLOCKQUOTE>
Note that the byte storage order corresponds to the layout of the nsIID C-struct 
  on a big-endian architecture. 
  <P>All InterfaceDirectoryEntry objects must appear sorted in increasing
order of iid, so as to facilitate a binary search of the array.&nbsp; (This
means that unresolved interfaces appear at the beginning of the array.)</BLOCKQUOTE>

<H4><A NAME="InterfaceDirectoryEntry_name"></A><TT>name</TT></H4>


<BLOCKQUOTE> 
  <p>The human-readable name of this interface, e.g. "nsISupports", stored using 
    the <A HREF="#Identifier">Identifier</A> record format.</p>
</BLOCKQUOTE>
<h4><a name="InterfaceDirectoryEntry_namespace"></a><tt>namespace</tt></h4>
<blockquote>The human-readable identifier for the namespace of this interface, 
  stored using the <a href="#Identifier">Identifier</a> record format. This is 
  the declared name of an interface's module in the XPIDL. The use of namespace 
  permits identically-named interfaces that do not conflict. (Reference to an 
  interface in one namespace to one in another namespace would probably be written 
  as <i>namespace.interfaceName</i>.) If namespace is zero, the interface is in 
  the default namespace.</blockquote>
<H4><A NAME="interface_descriptor"></A><TT>interface_descriptor</TT></H4>


<BLOCKQUOTE>This is a byte offset from the beginning of the file to the
corresponding InterfaceDescriptor object.</BLOCKQUOTE>

<H3><A NAME="InterfaceDescriptor"></A>InterfaceDescriptor</H3>

An InterfaceDescriptor is a variable-size record used to describe a single
XPCOM interface, including all of its methods:
<BLOCKQUOTE>

<PRE><TT>InterfaceDescriptor {
    <A HREF="#InterfaceDirectoryEntry">InterfaceDirectoryEntry</A>* <A HREF="#parent_interface">parent_interface</A>;
    uint16                   <A HREF="#num_methods">num_methods</A>;
    <A HREF="#MethodDescriptor">MethodDescriptor</A>         <A HREF="#method_descriptors">method_descriptors</A>[num_methods];
    uint16                   <A HREF="#num_constants">num_constants</A>;
    ConstDescriptor          <A HREF="#const_descriptors">const_descriptors</A>[num_constants];
}</TT></PRE>
</BLOCKQUOTE>

<H4><A NAME="parent_interface"></A><TT>parent_interface</TT></H4>


<BLOCKQUOTE>An interface's methods are specified by composing the methods
of an interface from which it is derived with additional methods it defines.
The <TT>method_descriptors</TT> array does not list any methods that the
interface inherits from its parent and the <TT>parent_interface</TT> field
contains a byte offset, relative to the beginning of the file, to the InterfaceDirectoryEntry
of its parent interface.&nbsp; This field has a value for nsISupports,
the root of the interface inheritance hierarchy.</BLOCKQUOTE>

<H4><A NAME="num_methods"></A><TT>num_methods</TT></H4>


<BLOCKQUOTE>The number of methods in the <TT>method_descriptors</TT> array.</BLOCKQUOTE>

<H4><A NAME="method_descriptors"></A><TT>method_descriptors</TT></H4>


<BLOCKQUOTE>This is an inline array of MethodDescriptor objects.
The length of the array is determined by the <TT>num_methods</TT> field.</BLOCKQUOTE>

<H4><A NAME="num_constants"></A><TT>num_constants</TT></H4>


<BLOCKQUOTE>The number of scoped interface constants in the <TT>const_descriptors</TT>
array.</BLOCKQUOTE>

<H4><A NAME="const_descriptors"></A><TT>const_descriptors</TT></H4>


<BLOCKQUOTE>This is an inline array of ConstDescriptor objects.&nbsp; The
length of the array is determined by the <TT>num_constants</TT> field.</BLOCKQUOTE>

<H3><A NAME="ConstDescriptor"></A>ConstDescriptor</H3>

A ConstDescriptor is a variable-size record that records the name and value
of a scoped interface constant.&nbsp; All ConstDescriptor records have
this form:
<BLOCKQUOTE><TT>ConstDescriptor {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; Identifier*&nbsp;&nbsp;&nbsp;&nbsp; <A HREF="#ConstDescriptor_name">name</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; TypeDescriptor&nbsp; <A HREF="#ParamDescriptor_type">type</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; &lt;type>
<A HREF="#ConstDescriptor_value">value</A>;</TT>
<BR><TT>}</TT></BLOCKQUOTE>

<H4><A NAME="ConstDescriptor_name"></A><TT>name</TT></H4>


<BLOCKQUOTE>The human-readable name of this constant, stored in the <A HREF="#Identifier">Identifier</A>
record format.</BLOCKQUOTE>

<H4><A NAME="ConstDescriptor_type"></A><TT>type</TT></H4>


<BLOCKQUOTE>The type of the method parameter.&nbsp; Types are restricted
to the following subset of TypeDescriptors: <TT>int8, uint8, int16, uint16,
int32, uint32, int64, uint64, wchar_t, char, string</TT></BLOCKQUOTE>

<H4><A NAME="ConstDescriptor_value"></A><TT>value</TT></H4>


<BLOCKQUOTE>The type (and thus the size) of the <TT>value</TT> record is
determined by the contents of the associated TypeDescriptor record.
For instance, if <TT>type</TT> corresponds to <TT>int16</TT>, then <TT>value</TT>
is a two-byte record consisting of a 16-bit signed integer.&nbsp; For a
ConstDescriptor type of <TT>string</TT>, the <TT>value</TT> record is of
type <A HREF="#String">String</A>*, i.e. an offset within the data pool
to a String record containing the constant string.</BLOCKQUOTE>

<H3><A NAME="MethodDescriptor"></A>MethodDescriptor</H3>

A MethodDescriptor is a variable-size record used to describe a single
interface method:
<BLOCKQUOTE>

  <PRE><TT>MethodDescriptor {
    boolean         <A HREF="#is_getter">is_getter</A>;
    boolean         <A HREF="#is_getter">is_setter</A>;
    boolean         <A HREF="#is_varargs">is_varargs</A>;
    boolean         <A HREF="#is_constructor">is_constructor</A>;<br>	boolean		<a href="#is_hidden">is_hidden</a>;
    uint3           reserved;
    Identifier*     <A HREF="#MethodDescriptor_name">name</A>;
    uint8           <A HREF="#num_args">num_args</A>;
    ParamDescriptor <A HREF="#params">params</A>[num_args];
    ParamDescriptor <A HREF="#result">result</A>;
}</TT></PRE>
</BLOCKQUOTE>

<H4><A NAME="is_getter"></A><TT>is_getter</TT></H4>


<BLOCKQUOTE>This field is used to allow interface methods to act as property
getters for object-oriented languages such as JavaScript.&nbsp; It could
be set as a result of defining an XPIDL attribute.&nbsp; For example, if
there was an XPIDL attribute named "Banjo",&nbsp; you could access the
"Banjo" property on an interface like so: 'myInterface.Banjo'.&nbsp; Any
prefix added&nbsp; by the XPIDL compiler to an attribute's&nbsp; identifier
in the .h file, such as "Is" or "Get" should not appear in the method's
<TT>name</TT>.</BLOCKQUOTE>

<H4><A NAME="is_getter"></A><TT>is_setter</TT></H4>


<BLOCKQUOTE>This field is used to allow interface methods to act as property
setters for object-oriented languages such as JavaScript.&nbsp; It could
be set as a result of defining an XPIDL attribute.&nbsp; For example, if
there was an XPIDL attribute named "Banjo",&nbsp; you could assign to the
"Banjo" property on an interface like so: 'myInterface.Banjo = 3'.
Any prefix added&nbsp; by the XPIDL compiler to an attribute's&nbsp; identifier
in the .h file, such as "Is" or "Get" should not appear in the method's
<TT>name</TT>.</BLOCKQUOTE>

<H4><A NAME="is_varargs"></A><TT>is_varargs</TT></H4>


<BLOCKQUOTE>If set, <TT>is_varargs</TT> indicates that the method is designed
to accept a variable number of arguments from, say, a scripting language.
The exact details of how this might be done, however, is beyond the scope
of the typelib definition.&nbsp; (With XPComConnect, an nsVarArgs object
is passed as the last parameter to such a method.&nbsp; That object is
a variable length array of argument values and types.)</BLOCKQUOTE>

<H4><A NAME="is_constructor"></A><TT>is_constructor</TT></H4>


<BLOCKQUOTE>This field indicates the default constructor for this interface, which 
  may be useful for interfaces that act like factories.&nbsp; For example, with 
  an instance of an XPCOM interface named 'Foo', in JavaScript one might write 
  'new Foo(arg1, arg2)', thus calling this interface to be called; The argument 
  signature of an XPCOM constructor is: 
  <BLOCKQUOTE><TT>NS_IRESULT ([arg,]*, out nsISomeInterface** result)</TT></BLOCKQUOTE>
  <p>That is, it's a function that takes zero or more arguments and creates a 
    new interface returned through the <TT>result</TT> output parameter.</p>
</BLOCKQUOTE>
<h4><a name="is_hidden"></a><tt>is_hidden</tt></h4>
<blockquote>If true, this field indicates that the method is not to be exposed 
  to scripters, although it remains in the typelib to fill a slot in the interface's 
  vtable. </blockquote>
<H4><A NAME="MethodDescriptor_name"></A><TT>name</TT></H4>


<BLOCKQUOTE>The human-readable name of this method, e.g. "getWindow", stored
in the <A HREF="#Identifier">Identifier</A> record format.</BLOCKQUOTE>

<H4><A NAME="num_args"></A><TT>num_args</TT></H4>


<BLOCKQUOTE>The number of arguments that the method consumes.&nbsp; Also,
the number of elements in the <TT>params</TT> array.</BLOCKQUOTE>

<H4><A NAME="params"></A><TT>params</TT></H4>


<BLOCKQUOTE>This is an inline array of <A HREF="#ParamDescriptor">ParamDescriptor</A>
objects.&nbsp; The length of the array is determined by the <TT>num_args</TT>
field.</BLOCKQUOTE>

<H4><A NAME="result"></A><TT>result</TT></H4>


<BLOCKQUOTE>This is a single, inline <A HREF="#ParamDescriptor">ParamDescriptor</A>
object that identifies the actual return type of an XPCOM method.
The result, however, does not always refer to the effective method return
value when the invocation is from a scripting language, i.e. the return
value as seen from a script-writer's perspective.&nbsp; In particular,
it is possible to designate any <A HREF="#param_out">out</A> method argument
as the method return value for scripting purposes.&nbsp; See the <A HREF="#param_retval">retval</A>
flag.</BLOCKQUOTE>

<H3><A NAME="ParamDescriptor"></A>ParamDescriptor</H3>

A ParamDescriptor is a variable-size record used to describe either a single
argument to a method or a method's result:
<BLOCKQUOTE>

<PRE><TT>ParamDescriptor {
    boolean         <A HREF="#param_in">in</A>;
    boolean         <A HREF="#param_out">out</A>;
    boolean         <A HREF="#param_retval">retval</A>;
    uint5           <A HREF="#reserved6">reserved</A>;
    TypeDescriptor  <A HREF="#ParamDescriptor_type">type</A>;
}</TT></PRE>
</BLOCKQUOTE>

<H4><A NAME="param_in"></A><TT>in</TT></H4>


<BLOCKQUOTE>If <TT>in</TT> is true, it indicates that the parameter is
to be passed from caller to callee.&nbsp; This flag is always false for
a method's <A HREF="#result">result</A>.</BLOCKQUOTE>

<H4><A NAME="param_out"></A><TT>out</TT></H4>


<BLOCKQUOTE>If <TT>out</TT> is true, it indicates that the parameter is
to be passed from callee to caller.&nbsp; It is possible for a parameter
to have both <TT>out</TT> and
<TT>in</TT> bits set.&nbsp; For the actual
method <A HREF="#result">result</A>, <TT>out</TT> is always true.
Out parameters that are method arguments must always have a pointer type.</BLOCKQUOTE>

<H4><A NAME="param_retval"></A><TT>retval</TT></H4>


<BLOCKQUOTE>If <TT>retval</TT> is true, it indicates that this parameter
is to be considered the return value of the method for purposes of invocation
from a scripting language.&nbsp; If the XPCOM method's <A HREF="#result">result</A>
parameter does not have its <TT>retval</TT> flag set, then the method's
return value is either void or an nsresult (a bitfield encoded as a uint32)
that indicates the success or failure of the method invocation.&nbsp; Note
that <TT>retval</TT> cannot be true unless <TT>out</TT> is also true.</BLOCKQUOTE>

<H4><A NAME="reserved6"></A><TT>reserved</TT></H4>


<BLOCKQUOTE>A 5-bit field reserved for future use.</BLOCKQUOTE>

<H4><A NAME="ParamDescriptor_type"></A><TT>type</TT></H4>


<BLOCKQUOTE>The type of the method parameter.</BLOCKQUOTE>

<H3><A NAME="TypeDescriptor"></A>TypeDescriptor</H3>

A TypeDescriptor is a variable-size record used to identify the type of
a method argument or return value.&nbsp; There are many XPCOM types that
need to be represented in the typelib:
<UL>
<LI>
scalar types, e.g. uint16 or boolean

<LI>
pointer to a scalar type, e.g. float*

<LI>
generic opaque pointer, i.e. void*

<LI>
void (only allowed for method return type)

<LI>
interface pointer, or a pointer to an interface pointer

<LI>
iid_is - that is, an interface pointer with type determined at runtime,
or a pointer to such an interface pointer

<LI>
pointer to an nsIID structure (to act as the parameter to an iid_is)
</UL>
[Editor: This specification does not yet cover pointers to unions, structs
or arrays.]

<P><A NAME="variant_TypeDescriptors"></A>To efficiently describe all the
type categories listed above, there are several different variants of TypeDescriptor
records:
<BLOCKQUOTE><TT>union TypeDescriptor {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; SimpleTypeDescriptor;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; InterfaceTypeDescriptor;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; InterfaceIsTypeDescriptor;</TT>
<BR><TT>}</TT></BLOCKQUOTE>
The first byte of all these TypeDescriptor variants has the identical layout:
<BLOCKQUOTE><TT>TypeDescriptorPrefix {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; boolean&nbsp; <A HREF="#is_pointer">is_pointer</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; boolean&nbsp; <A HREF="#is_unique_pointer">is_unique_pointer</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; boolean&nbsp; <A HREF="#is_reference">is_reference</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;&nbsp; <A HREF="#tag">tag</A>;</TT>
<BR><TT>}</TT></BLOCKQUOTE>

<H4><A NAME="is_pointer"></A><TT>is_pointer</TT></H4>


<BLOCKQUOTE>This field is true only when representing C pointer/reference
types.</BLOCKQUOTE>

<H4><A NAME="is_unique_pointer"></A><TT>is_unique_pointer</TT></H4>


<BLOCKQUOTE>This field cannot have a value of true unless <TT>is_pointer</TT>
is also true.&nbsp; The <TT>unique_pointer</TT> field indicates if the
parameter value can be aliased to another parameter value.&nbsp; If <TT>unique_pointer</TT>
is true, it must not be possible to reach the memory pointed at by this
argument value from any other argument to the method.</BLOCKQUOTE>

<H4><A NAME="is_reference"></A><TT>is_reference</TT></H4>


<BLOCKQUOTE>This field cannot have a value of true unless <TT>is_pointer</TT>
is also true.&nbsp; This field is true if the parameter is a reference,
which is to say, it's a pointer that can't have a value of NULL.</BLOCKQUOTE>

<H4><A NAME="tag"></A><TT>tag</TT></H4>


<BLOCKQUOTE>The tag field indicates which of the <A HREF="#variant_TypeDescriptors">variant
TypeDescriptor records</A> is being used, and hence the way any remaining
fields should be parsed.
<BR>
<TABLE BORDER >
 <TR BGCOLOR="#CCFFFF">
  <TD>

<CENTER><B>&nbsp;Value in <TT>tag</TT> field&nbsp;</B></CENTER>
  </TD>
  <TD>

<CENTER><B>&nbsp;TypeDescriptor variant to use&nbsp;</B></CENTER>
  </TD>
 </TR>
 <TR>
  <TD>

<CENTER>
          0..17 
        </CENTER>
  </TD>
  <TD>

<CENTER>SimpleTypeDescriptor</CENTER>
  </TD>
 </TR>
 <TR>
  <TD>

<CENTER>
          18 
        </CENTER>
  </TD>
  <TD>

<CENTER>InterfaceTypeDescriptor</CENTER>
  </TD>
 </TR>
 <TR>
  <TD>

<CENTER>
          19 
        </CENTER>
  </TD>
  <TD>

<CENTER>InterfaceIsTypeDescriptor</CENTER>
  </TD>
 </TR>
 <TR>
  <TD>

<CENTER>
          20..31 
        </CENTER>
  </TD>
  <TD>

<CENTER>reserved</CENTER>
  </TD>
 </TR>
</TABLE>
</BLOCKQUOTE>

<H3><A NAME="SimpleTypeDescriptor"></A>SimpleTypeDescriptor</H3>

The one-byte SimpleTypeDescriptor is a kind of <A HREF="#TypeDescriptor">TypeDescriptor</A>
used to represent scalar types,&nbsp; pointers to scalar types, the <TT>void</TT>
type,&nbsp; the <TT>void*</TT> type and, as a special case, the <TT>nsIID*</TT>
type:
<UL><TT>SimpleTypeDescriptor {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; boolean&nbsp; <A HREF="#is_pointer_and_tag">is_pointer</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; boolean&nbsp; <A HREF="#is_unique_pointer">is_unique_pointer</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; boolean&nbsp; <A HREF="#is_reference">is_reference</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;&nbsp; <A HREF="#is_pointer_and_tag">tag</A>;</TT>
<BR><TT>}</TT></UL>

<H4><A NAME="is_pointer_and_tag"></A><TT>is_pointer, tag</TT></H4>


<UL>
  The <TT>is_pointer</TT> field is true only when representing C pointer/reference 
  types.&nbsp; The following table indicates the types that can be represented 
  by combining different values for these two fields: <BR>
  <TABLE BORDER WIDTH="80%" >
    <TR BGCOLOR="#CCFFFF"> 
      <TD COLSPAN="3"> 
        <CENTER>
          <B>&nbsp;SimpleTypeDescriptor</B> 
        </CENTER>
      </TD>
    </TR>
    <TR BGCOLOR="#CCFFFF"> 
      <TD> 
        <CENTER>
          <B><TT>&nbsp;is_pointer&nbsp;</TT></B> 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <B><TT>&nbsp;tag&nbsp;</TT></B> 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <B>Type Represented</B> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          0 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int8</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          1 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int16</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          2 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int32</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          3 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int64</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          4 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint8</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          5 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint16</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          6 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint32</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          7 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint64</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          8 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>float</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          9 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>double</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          10 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>boolean </TT>(8-bit value) 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          11 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>char</TT> (8-bit character) 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          12 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>wchar_t</TT> (16-bit character) 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          13 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>void</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          14 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          reserved 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          false 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          15 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          reserved 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <div align="center">false</div>
      </TD>
      <TD> 
        <div align="center">16</div>
      </TD>
      <TD> 
        <div align="center">reserved </div>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <div align="center">false</div>
      </TD>
      <TD> 
        <div align="center">17</div>
      </TD>
      <TD> 
        <div align="center">reserved </div>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          0 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int8*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          1 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int16*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          2 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int32*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          3 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>int64*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          4 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint8*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          5 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint16*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          6 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint32*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          7 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>uint64*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          8 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>float*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          9 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>double*</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          10 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>boolean* </TT>(8-bit value) 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          11 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>char*</TT> (pointer to a single 8-bit character) 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          12 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>wchar_t*<br>
          </TT>(pointer to a single 16-bit character) 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          13 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>void*</TT> (generic opaque pointer) 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          14 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          <TT>nsIID**</TT> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <CENTER>
          true 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          15 
        </CENTER>
      </TD>
      <TD> 
        <CENTER>
          BSTR<SUP>1</SUP> 
        </CENTER>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <div align="center">true</div>
      </TD>
      <TD> 
        <div align="center">16</div>
      </TD>
      <TD> 
        <div align="center">char* (pointer to a NUL-terminated array)</div>
      </TD>
    </TR>
    <TR> 
      <TD> 
        <div align="center">true</div>
      </TD>
      <TD> 
        <div align="center">17</div>
      </TD>
      <TD> 
        <div align="center">wchar_t* (pointer to a NUL-terminated array)</div>
      </TD>
    </TR>
  </TABLE>
  <br>
  <SUP>1</SUP>A BSTR is an OLE type consisting of a 32-bit string-length field 
  followed bu a NUL-terminated Unicode string. 
</UL>

<H3><A NAME="InterfaceTypeDescriptor"></A>InterfaceTypeDescriptor</H3>

An InterfaceTypeDescriptor is used to represent either a pointer to an
interface type or a pointer to a pointer to an interface type, e.g. <TT>nsISupports*</TT>
or <TT>nsISupports**:</TT>
<BLOCKQUOTE><TT>InterfaceTypeDescriptor {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; boolean

<A HREF="#InterfaceTypeDescriptor_is_pointer">is_pointer</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; boolean

<A HREF="#is_unique_pointer">is_unique_pointer</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; boolean

<A HREF="#is_reference">is_reference</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; uint5&nbsp;&nbsp;
<A HREF="#InterfaceTypeDescriptor_tag">tag</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; InterfaceDirectoryEntry* <A HREF="#InterfaceTypeDescriptor_interface">interface</A>;</TT>
<BR><TT>}</TT></BLOCKQUOTE>

<H4><A NAME="InterfaceTypeDescriptor_is_pointer"></A><TT>is_pointer</TT></H4>


<BLOCKQUOTE>When this field is false, the represented type is an interface
pointer.&nbsp; When <TT>is_pointer</TT> is true, the represented type is
a pointer to an interface pointer.</BLOCKQUOTE>

<H4><A NAME="InterfaceTypeDescriptor_tag"></A><TT>tag</TT></H4>


<BLOCKQUOTE>The tag field must have the decimal value 18.</BLOCKQUOTE>

<H4><A NAME="InterfaceTypeDescriptor_interface"></A>interface</H4>


<BLOCKQUOTE>A byte-offset, relative to the beginning of the file, which
indentifies the interface pointer's type.</BLOCKQUOTE>

<H3><A NAME="InterfaceIsTypeDescriptor"></A>InterfaceIsTypeDescriptor</H3>

An InterfaceIsTypeDescriptor describes an interface pointer type.
It is similar to an <A HREF="#InterfaceTypeDescriptor">InterfaceTypeDescriptor</A>
except that the type of the interface pointer is specified at runtime by
the value of another argument, rather than being specified by the typelib.
<BLOCKQUOTE>

<PRE><TT>InterfaceIsTypeDescriptor {
    boolean  <A HREF="#InterfaceTypeDescriptor_is_pointer">is_pointer</A>;
    boolean  <A HREF="#is_unique_pointer">is_unique_pointer</A>;
    boolean  <A HREF="#is_reference">is_reference</A>;
    uint5    <A HREF="#InterfaceIsTypeDescriptor_tag">tag</A>;
    uint8    <A HREF="#InterfaceIsTypeDescriptor_arg_num">arg_num</A>;
}</TT></PRE>
</BLOCKQUOTE>

<H4><A NAME="InterfaceIsTypeDescriptor_tag"></A><TT>tag</TT></H4>


<BLOCKQUOTE>The tag field must have the decimal value 19.</BLOCKQUOTE>

<H4><A NAME="InterfaceIsTypeDescriptor_arg_num"></A><TT>arg_num</TT></H4>


<BLOCKQUOTE>The zero-based index of the method argument that describes
the type of the interface pointer.&nbsp; The specified method argument
must have type
<TT>nsIID*</TT>.</BLOCKQUOTE>

<H3><A NAME="Identifier"></A>Identifier</H3>

Identifier records are used to represent variable-length, human-readable
strings:
<BLOCKQUOTE><TT>Identifier {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; <A HREF="#InternedString_bytes">bytes</A>[];</TT>
<BR><TT>}</TT></BLOCKQUOTE>

<H4><A NAME="InternedString_bytes"></A><TT>bytes</TT></H4>


<BLOCKQUOTE>Unicode string encoded in UTF-8 format, NUL-terminated.</BLOCKQUOTE>

<H3><A NAME="String"></A>String</H3>

String records are used to represent variable-length, human-readable strings,
possibly with embedded NUL's:
<BLOCKQUOTE><TT>String {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; uint16 <A HREF="#InternedString_length">length</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; <A HREF="#InternedString_bytes">bytes</A>[];</TT>
<BR><TT>}</TT></BLOCKQUOTE>

<H4><A NAME="InternedString_length"></A><TT>length</TT></H4>


<BLOCKQUOTE>The length of the string, in characters (not bytes).</BLOCKQUOTE>

<H4><A NAME="InternedString_bytes"></A><TT>bytes</TT></H4>


<BLOCKQUOTE>Unicode string encoded in UTF-8 format, with no null-termination.
The length of the bytes array, measured in Unicode characters (not bytes),
is reported by the <TT>length</TT> field.</BLOCKQUOTE>

<H3><A NAME="Annotation"></A>Annotation</H3>

Annotation records are variable-size records used to store secondary information
about the typelib, e.g. such as the name of the tool that generated the
typelib file, the date it was generated, etc.&nbsp; The information is
stored with very loose format requirements so as to allow virtually any
private data to be stored in the typelib.
<BLOCKQUOTE><TT>union Annotation {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; EmptyAnnotation</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; PrivateAnnotation</TT>
<BR><TT>}</TT></BLOCKQUOTE>

<BLOCKQUOTE><TT>EmptyAnnotation {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp; <A HREF="#Annotation_is_last">is_last</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; uint7&nbsp;&nbsp;&nbsp;&nbsp; <A HREF="#Annotation_tag">tag</A>;
// 0</TT>
<BR><TT>}</TT>

<P><TT>PrivateAnnotation {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; boolean&nbsp;&nbsp; <A HREF="#Annotation_is_last">is_last</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; uint7&nbsp;&nbsp;&nbsp;&nbsp; <A HREF="#Annotation_tag">tag</A>;
// 1</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; String&nbsp;&nbsp;&nbsp; <A HREF="#Annotation_creator">creator</A>;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; String&nbsp;&nbsp;&nbsp; <A HREF="#Annotation_private_data">private_data</A>;</TT>
<BR><TT>}</TT></BLOCKQUOTE>

<H4><A NAME="Annotation_is_last"></A><TT>is_last</TT></H4>


<BLOCKQUOTE>When true, no more Annotation records follow the current record.
If false, at least one Annotation record appears immediately after the
current record.</BLOCKQUOTE>

<H4><A NAME="Annotation_tag"></A><TT>tag</TT></H4>


<BLOCKQUOTE>The tag field discriminates among the variant record types
for Annotation's.&nbsp; If the tag is 0, this record is an EmptyAnnotation.
EmptyAnnotation's are ignored - they're only used to indicate an array
of Annotation's that's completely empty.&nbsp; If the tag is 1, the record
is a PrivateAnnotation.</BLOCKQUOTE>

<H4><A NAME="Annotation_creator"></A><TT>creator</TT></H4>


<BLOCKQUOTE>A string that identifies the application/tool/code that created
the annotation, e.g. "XPIDL Compiler, Version 1.2".&nbsp; There are no
rules about the contents of the <TT>creator</TT> string other than that
it be human-readable.</BLOCKQUOTE>

<H4><A NAME="Annotation_private_data"></A><TT>private_data</TT></H4>


<BLOCKQUOTE>An opaque data array that is put into the typelib by the application/tool/code
that created the typelib.&nbsp; There are no restrictions on the format
of the <TT>private_data</TT>.</BLOCKQUOTE>
<H3><a name="Document_History"></a>Document History</H3>


<BLOCKQUOTE> 
  <h4>Draft 4 (1/14/98)  -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d4.html">http://mozilla.org/scriptable/typelib_file_v1_d4.html</a></h4>
  <ul>
    <li>Changed to big-endian layout due to arm-twisting. (Note resulting change 
      to IID layout.)</li>
    <li>Changed entries in SimpleTypeDescriptor table to distinguish between a 
      pointer to a single character and a pointer to a null-terminated array of 
      characters, both for 8-bit and 16-bit characters. This also resulted in 
      changes to the tag member of the TypeDescriptor field for InterfaceTypeDescriptor 
      and InterfaceIsTypeDescriptor.</li>
    <li>Changed string type in SimpleTypeDescriptor to BSTR, since it's starting 
      to look like this is what we may standardize on for XPCOM strings.</li>
    <li>Added interface namespace field to the InterfaceDirectoryEntry, aka CORBA 
      modules, aka MIDL libraries. This is to allow for identically-named interfaces 
      that don't clash.</li>
    <li>Added 'is_hidden' bit to MethodDescriptor for methods that are not exposed 
      to script authors.</li>
    <li>Moved Document History and Known Issues to bottom of spec.<br>
    </li>
  </ul>
  <H4>Draft 3 (1/5/98) -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d3.html">http://mozilla.org/scriptable/typelib_file_v1_d3.html</a></H4>
</BLOCKQUOTE>
<BLOCKQUOTE> 
  <BLOCKQUOTE> 
    <LI> Added 'retval' flag and massaged description of 'in' and 'out' flags 
      in the ParamDescriptor record. 
    <LI> Fixed errors in descriptions of 'params' and 'result' members of the 
      MethodDescriptor and in the description of 'method_descriptors' and 'const_descriptors' 
      members of the InterfaceDescriptor record.&nbsp; (In all cases, these members 
      were incorrectly described as byte offsets to other records even though 
      the data layout notation indicated that they were stored inline.) 
  </BLOCKQUOTE>
  <H4>Draft 2 (12/16/98) -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d2.html">http://mozilla.org/scriptable/typelib_file_v1_d2.html</a></H4>
  <BLOCKQUOTE> 
    <LI> Added "Document History" and "Known Issues" sections. 
    <LI> Tweaked introduction. 
    <LI> Changed pointers to InterfaceDescriptor records to instead point to InterfaceDirectoryEntry's 
      so as to allow late-binding of interfaces using only the interface name. 
      The interface name was moved from the InterfaceDescriptor to the InterfaceDirectoryEntry 
      for the same reason. 
    <LI> Changed the description of the parent_interface field of InterfaceDescriptor 
      so that its use is not optional. 
    <LI> Updated is_getter and is_setter text to be less confusing about whether 
      or not method name prefixes are stored for getters and setters.&nbsp; (They're 
      not.) 
    <LI> Added is_varargs and is_constructor flags to MethodDescriptor. 
    <LI> Added support for scoped interface constants. 
    <LI> Nearly all uses of the String record type were changed to Identifier. 
      Identifiers are NUL-terminated UTF-8 string records.&nbsp; That means you 
      can't store embedded NUL characters in an identifier (method or interface 
      name), but they're one byte shorter because the string length isn't stored 
      as part of the record. 
    <LI> Added support for private data to be attached to typelib files (Annotation 
      records) 
  </BLOCKQUOTE>
  <h4>Draft 1 (12/13/98) -- <a href="http://mozilla.org/scriptable/typelib_file_v1_d1.html">http://mozilla.org/scriptable/typelib_file_v1_d1.html</a></h4>
</BLOCKQUOTE>

<H3><a name="Known_Issues"></a>Known Issues</H3>


<UL>
  <LI> All opaque pointers (using the 'native' keyword in XPIDL) are represented 
    as <TT>void*</TT> pointers in the typelib.&nbsp; That doesn't give us any 
    type safety in terms of passing such pointers around with JS or other languages. 
    Should we just disallow methods that use the <TT>void*</TT> type for XPCOMConnect 
    ?&nbsp; Or should we attach type information to the typelib instead of using 
    <TT>void*</TT> ? 
  <LI> There is no support yet in the typelib for pointers to unions or structs. 
    Also no support for arrays, array slices or enums. 
  <LI> We need a way to represent a pointer to an nsVarArgs struct as an argument 
    to a method.&nbsp; (This structure is used to collect arguments after the 
    last fixed argument.)&nbsp; There is, as of yet, no way to represent structs 
    in the typelib.&nbsp; For now, we could maybe lie and call it a void *. Or 
    we could add a special-case TypeDescriptor for this, as we did for <TT>nsIID*</TT>. 
    Or we could just punt and require all variable-length argument lists to be 
    handled by nsIScriptable, rather than through XPConnect.
  <LI> The common string type(s) that will be passed around in XPCOM methods still 
    seems to be up in the air.&nbsp; (nsString, nsIString, STL strings, ?) Until 
    that's resolved, the TypeDescriptor just uses "string" to represent that type.&nbsp; 
    Depending on what's decided, we may end up adding more than one string type. 
</UL>


</BODY>
</HTML>
