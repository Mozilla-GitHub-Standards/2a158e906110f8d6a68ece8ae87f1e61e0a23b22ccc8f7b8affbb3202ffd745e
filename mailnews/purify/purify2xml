#!/usr/bin/perl
# purify2xml 1.0 - convert purify expanded output to an XML file
# plus some JS to support dynamically displaying and filtering
# 
# Copyright (C) 1999 Alec Flett (alecf@usa.net, alecf@netscape.com)
# see http://www.mozilla.org/mailnews/purify/ for the latest version
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

my $leak=0;
print "<?xml version=\"1.0\"?>\n";
print "<?xml-stylesheet href=\"purify.css\" type=\"text/css\"?>\n";
print "<?xml-stylesheet href=\"toc.css\" type=\"text/css\"?>\n";

print "<purify id=\"purify\" xmlns:html=\"http://www.w3.org/TR/REC-html40\">\n";
print "<html:script src=\"toc.js\"/>\n";

print "<title>Purify results</title>\n";
print "<subtitle>date here</subtitle>\n";

print "<html:input type=\"text\" name=\"searchString\" id=\"searchString\"/>\n";
print "<html:input type=\"button\" onclick=\"doSearch(document, event);\" value=\"Search\"/>\n";

# print "<html:select multiple=\"true\" size=\"4\" name=\"warntypes\">\n";
# print "</html:select>\n";
# print "<html:br/>\n";
# print "<html:input type=\"button\" onclick=\"populateWarningTypes(event)\"/>\n";

$instack=0;
$insourceblock=0;
$inwarning=0;

while (<ARGV>) {
  chop;
  s/&/&amp;/g;
  s/</&lt;/g;
  s/>/&gt;/g;
#  print "line: $_\n";

  # main line - resets to beginning state
  if (/^\[(.)\]/) {
    my $level = $1;
    my $errtype, $warning;

    if (/^\[.\] (.+): (.*)$/) {
      $errtype = $1;
      $warning = $2;
    } elsif (/^\[.\] (.*)$/) {
      $warning = $2;
    }
    my $shortwarn = &get_shortwarning($errtype, $warning);

    # clean up from previous state
    if ($insourceblock) {
      print "\t\t\t\t</html:div>\n";
      $insourceblock=0;
    }
    
    if ($instack) {
      print "\t\t\t</stack>\n";
      $instack=0;
    }

    if ($instackblock) {
      print "\t\t</html:div>\n";
      $instackblock=0;
    }
    
    if ($inwarning) {
      print "\t</html:div>\n";
      $inwarning=0;
    }
    

    print "\t<html:div class=\"warning\">\n";
    print "\t\t<title><html:img src=\"plus.gif\" height=\"11\" width=\"11\" onclick=\"expandCollapse(event);\"/><error level=\"$level\">$errtype</error>: $shortwarn</title>\n";
    $inwarning=1;
    
  }

  # informational lines belong inside stackblocks
  elsif (/^\s{4,4}(\w.*)$/) {
    next if (/Distribution of leaked blocks/);
    
    if ($insourceblock) {
      print "\t\t\t\t</html:div>\n";
      $insourceblock=0;
    }
    
    if ($instack) {
      print "\t\t\t</stack>\n";
      $instack=0;
    }
    
    if (!$instackblock) {
      print "\t\t<html:div class=\"stackblock\">\n";
      $instackblock=1;
    }
    print "\t\t\t<info>$1</info>\n";
  }
  
  # stack trace entries belong inside stackblocks
  elsif (/^\s+([^\s].*[^\s])\s+\[(.*)\]/) {
    my ($function, $file, $lineno) = ($1, $2, $3);
    if ($file =~ /(.*):(\d+)/) {
      ($file, $lineno) = ($1, $2);
    }
    # clean up from previous state
    
    if ($insourceblock) {
      print "\t\t\t\t</html:div>\n";
      $insourceblock=0;
    }
    
    if ($instack) {
      print "\t\t\t</stack>\n";
      $instack=0;
    }

    if (!$instackblock) {
      print "\t\t<html:div class=\"stackblock\">\n";
      $instackblock=1;
    }

    $shortfunc = get_shortfunction($function);
    print "\t\t\t<stack>\n";
    print "\t\t\t\t<title class=\"stack\"><html:img src=\"plus.gif\" onclick=\"expandCollapse(event);\"/><function>$shortfunc</function> <link xml:link=\"http://lxr.mozilla.org/mozilla/find?string=$file\"> $file:$lineno</link></title>\n";
    $instack=1;
  }
  
  # the rest of the lines are only handled based on the state
  # generated by previous lines.
  else {
    
    if ($instack) {
      
      # create sourceblock if necessary
      if (!$insourceblock) {
        print "\t\t\t\t<html:div class=\"sourceblock\">\n";
        $insourceblock=1;
      }
      
      elsif (/\=\&gt\;\s(.*)$/) {
        print "\t\t\t\t\t<source highlight=\"true\">$1</source>\n";
      } elsif (/^\s{16,16}(.*)$/) {
        print "\t\t\t\t\t<source>$1</source>\n";
      }
    }     
  }
}


# clean up from previous state

if ($insourceblock) {
  print "\t\t\t\t\t</html:div>\n";
  $insourceblock=0;
}
    
if ($instack) {
  print "\t\t\t</stack>\n";
  $instack=0;
}

if ($instackblock) {
  print "\t\t</html:div>\n";
  $instackblock=0;
}
    
if ($inwarning) {
  print "\t</html:div>\n";
  $inwarning=0;
}
  
print "</purify>\n";

sub get_shortwarning {
  my ($errtype, $warning) = @_;

  my ($function, $details);

  if ($errtype eq "MLK" &&
      $warning =~ /Memory leak of (.*) allocated in (.*)$/) {
    ($function, $details) = ($2, $1);
  }
  
  elsif ($errtype eq "UMR" &&
         $warning =~ /Uninitialized memory read in (.*) \{((\d+).*)\}/) {
    ($function, $details) = ($1,$2);
  }

  elsif ($errtype eq "FMM" &&
         $warning =~ /Freeing mismatched memory in (.*) \{((\d+).*)\}/) {
    ($function, $details) = ($1, $2);
  }

  elsif ($errtype eq "ABR" &&
         $warning =~ /Array bounds read in (.*) \{((\d+).*)\}/) {
    ($function, $details) = ($1, $2);
  }

  elsif ($errtype eq "IPR" && 
         $warning =~ /Invalid pointer read in (.*) \{((\d+).*)\}/) {
      ($function, $details) = ($1, $2);
  }

  if ($function || $details) {
    $result = "$function $details";
  } else {
    $result = $warning;
  }
  
  $result;
}

sub get_shortfunction {
  my ($function) = @_;

  $result = $function;
  
  if ($function =~ /(.*)\(/) {
    $result = "$1()";
  }
  
  $result;
}
