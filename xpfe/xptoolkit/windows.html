<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="top" title="Home" href="http://www.mozilla.org/">
<link rel="stylesheet" type="text/css" href="../../css/print.css"  media="print">
<link rel="stylesheet" type="text/css" href="../../css/base/content.css"  media="all">
<link rel="stylesheet" type="text/css" href="../../css/cavendish/content.css" title="Cavendish" media="screen">
<link rel="stylesheet" type="text/css" href="../../css/base/template.css"  media="screen">
<link rel="stylesheet" type="text/css" href="../../css/cavendish/template.css" title="Cavendish" media="screen">
<link rel="icon" href="../../images/mozilla-16.png" type="image/png">

 <title>Windows and Dialogs</title>
 <link rel="content" href="./">
 <link rel="prev" href="persistence.html">
 <link rel="next" href="introClipDD.html">
<script src="../../__utm.js" type="text/javascript"></script>
</head>
<body id="www-mozilla-org" class="deepLevel">
<div id="container">
<p class="important">You are currently viewing a snapshot of www.mozilla.org taken on April 21, 2008. Most of this content is
highly out of date (some pages haven't been updated since the project began in 1998) and exists for historical purposes only.  If
there are any pages on this archive site that you think should be added back to www.mozilla.org, please <a
href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Websites&component=www.mozilla.org">file a bug</a>.</p>
<p class="skipLink"><a href="#mainContent" accesskey="2">Skip to main content</a></p>
<div id="header">
<h1><a href="/" title="Return to home page" accesskey="1">Mozilla</a></h1>
<ul>
<li id="menu_aboutus"><a href="../../about/" title="Getting the most out of your online experience">About</a></li>
<li id="menu_developers"><a href="../../developer/" title="Using Mozilla's products for your own applications">Developers</a></li>
<li id="menu_store"><a href="http://store.mozilla.org/?r=mozorg1" title="Shop for Mozilla products on CD and other merchandise">Store</a></li>
<li id="menu_support"><a href="../../support/" title="Installation, trouble-shooting, and the knowledge base">Support</a></li>
<li id="menu_products"><a href="../../products/" title="All software Mozilla currently offers">Products</a></li>
</ul>
<form id="searchbox_002443141534113389537:ysdmevkkknw" action="http://www.google.com/cse" title="mozilla.org Search">
<div>
<label for="q" title="Search mozilla.org's sites">search mozilla:</label>
<input type="hidden" name="cx" value="002443141534113389537:ysdmevkkknw">
<input type="hidden" name="cof" value="FORID:0">
<input type="text" id="q" name="q" accesskey="s" size="30">
<input type="submit" id="submit" value="Go">
</div>
</form>
</div>
<hr class="hide">
<div id="mBody">
<div id="side">

<ul id="nav">
<li><a title="Roadmap" href="../../roadmap.html"><strong> Roadmap</strong></a></li>
<li><a title="Projects" href="../../projects/"><strong> Projects</strong></a></li>
<li><a title="For developers" href="../../developer/"><strong> Coding</strong></a>
<ul>
<li><a title="Module Owners" href="../../owners.html"> Module Owners</a></li>
<li><a title="Hacking" href="../../hacking/"> Hacking</a></li>
<li><a title="Get the Source" href="http://developer.mozilla.org/en/docs/Download_Mozilla_Source_Code"> Get the Source</a></li>
<li><a title="Building Mozilla" href="http://developer.mozilla.org/en/docs/Build_Documentation"> Build It</a></li>
</ul>
</li>
<li><a title="Testing" href="../../quality/"><strong> Testing</strong></a>
<ul>
<li><a title="Downloads of mozilla.org software releases" href="../../download.html"> Releases</a></li>
<li><a title="Latest mozilla builds for testers" href="../../developer/#builds"> Nightly Builds</a></li>
<li><a title="For testers to report bugs" href="https://bugzilla.mozilla.org/"> Report A Problem</a></li>
</ul>
</li>
<li><a title="Tools for mozilla developers" href="../../tools.html"><strong> Tools</strong></a>
<ul>
<li><a title="Bug tracking system for mozilla testers." href="https://bugzilla.mozilla.org/"> Bugzilla</a></li>
<li><a title="Latest status of mozilla builds" href="http://tinderbox.mozilla.org/showbuilds.cgi?tree=Firefox"> Tinderbox</a></li>
<li><a title="Latest checkins" href="http://bonsai.mozilla.org/cvsqueryform.cgi"> Bonsai</a></li>
<li><a title="Source cross reference" href="http://lxr.mozilla.org/seamonkey/"> LXR</a></li>
</ul>
</li>
<li><a title="Frequently Asked Questions." href="../../faq.html"><strong> FAQs</strong></a></li>
</ul>

</div>
<hr class="hide">
<div id="mainContent">




 <h1>Windows and Dialogs</h1>
 <ul class="snav">
  <li><a href="persistence.html">Previous: Persistence and Sharing</a>
  <li><a href="./">Table of Contents</a>
  <li><a href="introClipDD.html">Next: Intro to Clipboard/Drag &amp; Drop</a>
 </ul>
 <dl>
  <dt>Feature Owner
  <dd><a href="mailto:danm@netscape.com">Daniel Matejka</a>
 </dl>
      <p>Dialogs are alive and well in Mozilla, and this document attempts to
        explain their current status.
      <h2>Scope</h2>
      <p>This document is not intended to be a comprehensive syntax or reference
        manual. With care and time, it should grow into a useful starting place
        for making windows and writing dialogs. The <a href="mailto:danm@netscape.com">author</a>
        thinks that feedback on what's missing from the document would help build
        a better document, so the quality of this thing is in the reader's hands.
        Keep that in mind while you're cursing me.
      <p>In the meantime, this document also serves as a roadmap of XPFE's dialog
        story. Interested parties would please review it to determine whether
        the package we plan to deliver will meet their needs.
      <h2>Direction</h2>
      <p>Current XPFE design goals state that dialogs get no special treatment;
        they're just windows like any other. Windows can have parent windows,
        and be displayed modally, and have control callbacks, and so behave like
        dialogs. But our goal is that the same application code that instantiates
        a browser window will serve equally to instantiate a dialog window. The
        difference lies in the window content, and a couple of parameters controlling
        modality and that sort of thing.
      <h2>JavaScript vs C++</h2>
      <p>Currently, all window control mechanisms flow through JavaScript. That
        is, any capabilities a window may have besides taking up space on the
        desktop are specified in the XUL describing the window, and the binding
        between the window content and the application is done through JavaScript
        in the XUL. That binding can be very short: it can fall through to application
        C code very quickly, but JavaScript will be part of the process. (Note
        that we have not yet run into any threading problems with this model,
        but we kind of expect to.)
      <p>JavaScript is easily added to a window: just include it in the XUL window
        description and follow a short but peculiar dance to hook it up. Hooking
        up C code involves writing a C++/JavaScript interface, and calling it
        from JavaScript. Currently, for historical reasons, there is an unfortunate
        dual standard for building these interfaces: DOM IDL and <a href="../../scriptable/">XPConnect</a>.
        Though <a href="../appCore/appcores.html">AppCores</a> are currently built
        using the former, XPConnect is the preferred means for writing additional
        extensions.
      <h2>Make a Window</h2>
      <p>There are two ways to make a window or dialog: directly through C++ and
        from JavaScript. The resulting window is an instance of <code>nsWebShellWindow</code>.
        This means it currently contains a hulking bunch of hackery for hooking
        up browser-window specific contents. The overhead is reduced from its
        former grandeur, but still slows window opening. We are still working
        on reducing the burden of opening a new window.</p>
      <h3>Javascript</h3>
      <p><code>window.open</code> will open a XUL window if given a XUL URL to
        load. It will open the given URL as the contents of a browser window,
        unless the <code>chrome</code> feature is specified in <code>window.open</code>'s
        third (&quot;features&quot;) parameter. Mozilla supports an extended form
        of <code>window.open</code> which can be used to pass parameters back
        and forth to the dialog window. It's named <code>window.openDialog</code>,
        reasonably enough, for now. Both <code>window.openDialog</code> and <code>chrome</code>
        are described in <a href="#jsextensions">JavaScript Extensions</a>.</p>
      <p>Another JavaScript interface is a Mozilla AppCore named <code>ToolkitCore</code>.
        It contains a handful of windowing utility functions which were more useful
        before <code>window.open</code> was working properly. <code>ToolkitCore</code>
        is deprecated: all the functionality it provides can be reached through
        standard JavaScript, and much functionality provided by standard JavaScript
        is missing from <code>ToolkitCore</code>.</p>
 <pre class="code">function MakeDialog() {
   var newWindow = window.open(&quot;madedialog.xul&quot;,
                     &quot;itsname&quot;, &quot;chrome&quot;);
}</pre>
 <p>or, alternatively (you'll see this in the code, but don't emulate it),</p>
 <pre class="code">function MakeDialog() {
    var toolkitCore = XPAppCoresManager.Find("ToolkitCore");
    if (!toolkitCore) {
      toolkitCore = new ToolkitCore();
      if (toolkitCore)
        toolkitCore.Init("ToolkitCore");
    }
    if (toolkitCore)
      toolkitCore.ShowWindow("madedialog.xul",
          window);
}</pre>
      <p>An <code>XPAppCoresManager</code> is pre-constructed; you can access
        it without any more preparation than shown above. <code>ToolkitCore</code>
        is not; it requires that small bit of preparation.
      <h3>C++</h3>
 <p>There are two interfaces for opening new windows from C code. One is really
      a private interface, providing only basic window opening functionality,
      and in general should not be used. In fact, its mention in this document
      should probably be removed. The other is more general, does more interesting
      things, and is your friend.</p>
      <h4>nsIAppShellService::CreateTopLevelWindow</h4>
      <p>The pseudo-private C++ interface is <code>nsIAppShellService::CreateTopLevelWindow()</code>.
        It handles the basic task of opening a window, but neglects to do a lot
        of important things like hooking the window up properly to JavaScript.
        It works like this:</p>
 <pre class="code">  nsresult              rv;
  nsIAppShellService    *appShell;
  nsIURL                *url;
  nsIWebShellWindow     *parent, *window;
  nsIXULWindowCallbacks *callbacks;
  PRInt32               width, height;

  window = nsnull;
  rv = nsServiceManager::GetService(kAppShellServiceCID,
         kIAppShellServiceIID,
         (nsISupports**) &amp;appShell);
  if (NS_SUCCEEDED(rv)) {
    appShell->CreateTopLevelWindow(parent, url, PR_TRUE, PR_TRUE,
                NS_CHROME_ALL_CHROME, callbacks, width, height,
                &amp;window);
    nsServiceManager::ReleaseService(kAppShellServiceCID,
                appShell);
  }</pre>
      <p><code>url</code> is an URL describing the contents of the window. <code>window</code>
        is returned from the function, set to the created window. See the code
        for descriptions of the other parameters.</p>
      <p>At this time, window descriptions must be loaded from an URL. In future
        releases, there may additionally be methods for loading windows from a
        stream. Streams would disengage the toolkit further from the source of
        the window description, and would be our method for creating windows whose
        XUL is calculated at runtime, rather than being distributed as a file.
        But we're uncertain whether this will truly be necessary, given current
        architecture.</p>
      <h4>nsIDOMWindow::OpenDialog</h4>
      <p>The primary C++ interface is <code>nsIDOMWindow::OpenDialog</code>. It
        has the advantage that it behaves exactly like the JavaScript <code>window.openDialog</code>
        function, being the same function, after all.</p>
      <p>The close association between this function and JavaScript places constraints
        on its usage. Any parameters sent to this function must be ready for use
        in JavaScript handlers built into the new window, and so must be fitted
        into JavaScript wrappers. There must also be a &quot;parent&quot; window
        available to do the window opening and provide a JavaScript context.</p>
      <p>The function to wrap a series of arguments is called <code>JS_PushArguments</code>,
        and is defined in <code>jsapi.h</code>. Its mysterious third argument
        is explained in that same header file. The sample code below will call
        <code>OpenDialog</code>, given an <code>nsIDOMWindow</code> to work with.
        <a href="#opendialog"><code>OpenDialog</code></a> is explained below.
        Its first three arguments are standard <code>Open</code> arguments. The
        remainder are parameters for the new window. That new window will have
        a property named <code>arguments</code>. It's an array, and <code>arguments[0]</code>
        is the string &quot;I was born a C string&quot;, while <code>arguments[1]</code>
        is the number 298.</p>
 <pre class="code">DoOpenDialog(nsIDOMWindow* aParent) {

  if (!aParent)
    return NS_ERROR_NULL_POINTER;

  nsresult rv = NS_ERROR_FAILURE;
  JSContext *jscx = 0;
  nsIDOMWindow *newWindow;

  // get the parent window's JS Context (this is not really a blessed thing
  // to do, but I believe it's all we have. it wants to be a real interface
  // someday.)
  nsCOMPtr&lt;nsIScriptGlobalObject&gt; scriptGlobalObj = do_QueryInterface(aParent);
  if (scriptGlobalObj) {
    nsCOMPtr&lt;nsIScriptContext&gt; scriptcx;
    scriptGlobalObj-&gt;GetContext(getter_AddRefs(scriptcx));
    if (scriptcx)
      jscx = (JSContext *) scriptcx-&gt;GetNativeContext();
  }

  // if everything went as planned...
  if (jscx) {

    // build a JavaScript &quot;arguments&quot; array for the OpenDialog function
    void *mark;
    jsval *argv;

    argv = JS_PushArguments(jscx, &amp;mark, &quot;ssssu&quot;,
      &quot;resource://res/samples/paramdialog.xul&quot;,
      &quot;windowName&quot;,
      &quot;chrome&quot;,
      &quot;I was born a C string&quot;,
      (uint32) 298);

    // if that worked, call the function.
    if (argv) {
      aParent-&gt;OpenDialog(jscx, argv, 5, &amp;newWindow);
      JS_PopArguments(jscx, mark);
      rv = NS_OK;
    }
  }

  return rv;
}</pre>
      <h2>Load a Window</h2>
      <p>Between making and showing the window, there is a callback. The resulting
        <code>nsWebShellWindow</code> comes with an associated DOM content model.
        Any initial control settings or content changes which must be made before
        the window is actually shown can be done at the time of this callback.</p>
      <p>This callback is any JavaScript specified as the value of the <code>onload</code>
        attribute of the <code>&lt;window&gt;</code> element. In the example below,
        the window start tag is declared
      <code>&lt;window ... onload=&quot;Startup()&quot;&gt;</code></p>
      <p>During the <code>onload</code> callback, dialog authors are free to alter
        control settings from JavaScript:</p>
 <pre class="code">
  function Startup() {
    // yellowize and check the "ow" button
    document.bgColor = "yellow";
    var checkbox = document.getElementByID("ow");
    if (checkbox)
      checkbox.checked = true;
  }</pre>
      <p>Except that not all properties are hooked up yet. The change to background
        color in the example won't do anything. But the important example does
        work!</p>
      <p>Dialog preprocessing can also be done in C by defining an XPIDL component,
        and loading and calling it from the <code>Startup()</code> method. See
        the <a href="../../scriptable/">scriptable XPIDL documentation</a> for
        details.</p>
      <h2>Debrief a Window</h2>
      <p>After the dialog has run -- a dismissal button has been clicked, say
        -- dialog users will need a callback in which to query the current control
        settings. As always, this will be done by walking the DOM content model,
        and accessed through a JavaScript hook. There is no explicit debriefing
        hook; we've found the event handlers for the dismissal buttons sufficient
        so far, with one exception. In the future we will need a means to capture
        a pending window close resulting from the user hitting an OS-level close
        widget.</p>
      <p>Data can be passed back to the calling window in more than one way. The
        dialog window and opener can agree to share information as properties
        added to the JavaScript dialog window object. Alternatively, the two windows
        could agree that the dialog window will call some function of its opener.
        A third way could be for the opener to use <code>window.openDialog</code>
        to pass parameters by reference to the dialog window. Any changes made
        by the dialog to these parameters would be visible in the opener window.
        See <a href="#jsextensions">JavaScript Extensions</a> or the <a href="#examples">examples</a>
        for details. Two files in the source code at <code>mozilla/xpfe/browser/samples/dexparam*.xul</code>
        are a kind of test suite for parameter passing, and consequently spell
        out more details than will this document.</p>
      <p>Note at time of writing, a dialog window, once closed, cannot be successfully
        accessed from JavaScript through the variable which was returned by <code>window.open</code>.
        This is a known bug, and wants fixing.</p>
      <h2 id="intrinsicsizing">Intrinsic Sizing</h2>
      <p>Windows in Mozilla are also dialogs. Unlike browser windows, it is often
        best to fit a dialog window around its contents. To make this work properly,
        the XUL must be carefully designed with element sizing hints and most
        likely <code><a href="boxes.html">boxes</a></code>. If a window's contents
        are properly designed, their intrinsic size can be determined, and the
        window sized to fit them. Such dialogs keep their looks after trauma like
        internationalization and content changes through DOM manipulation.</p>
      <p>Windows opened as <a href="#chromefeature">chrome</a> are given intrinsic
        sizing by default. This can be overridden by specifying an explicit size;
        a <code>width</code> attribute on the XUL <code>window</code> element,
        for example. A window can also be given intrinsic sizing using <code>nsIAppShellService::CreateTopLevelWindow</code>
        by specifying a height and width of <code>NS_SIZETOCONTENT</code>. A window
        can be wrapped around its contents at any time by calling its <code><a href="#sizetocontent">sizeToContent</a></code>
        function.</p>
      <p>Intrinsic sizing currently does not work for HTML content. It must be
        laid out using XUL, which, unlike HTML, can have a notion of its own optimal
        size.</p>
      <h2 id="jsextensions">Javascript Extensions</h2>
      <p>Mozilla has found it necessary to support a few extensions to standard
        JavaScript. These are, well, nonstandard. They are therefore subject to
        change while the program is under development, and will not work with
        other browser applications. Extensions used by the windowing system are
        described below. Other systems' extensions are described in their respective
        documents.</p>
      <h3><code>window.open</code></h3>
      <p><code>open(URL[, windowName [, windowFeatures]])</code></p>
      <p>The standard syntax still applies. See a JavaScript reference for details.
        Mozilla, however, understands a few extensions to <code>windowFeatures</code>
        (and doesn't yet understand all the latest standard features). The treatment
        of these extensions is somewhat confused in the name of backward compatibility
        and because of the sometimes uneasy interplay between standards-compliant
        <code>open</code> and the more freewheeling <code>openDialog</code>.</p>
      <ul>
        <li>New Features
          <ul>
            <li><code>titlebar</code> - The window can be created with or without
              a titlebar.</li>
            <li><code>close</code> - The window can be created with or without
              a close widget.</li>
            <li><a name="chromefeature"><code>chrome</code></a> - Normally, the
              URL given to <code>window.open</code> is treated as a content URL.
              That is, Mozilla generates a browser window and loads the given
              URL into its content area, as <code>window.open</code> has always
              behaved. However, the presence of a <code>chrome</code> flag in
              the <code>windowFeatures</code> parameter will cause the given URL
              to be treated as the window chrome, itself. It will be treated as
              the top-level window contents; it will not be wrapped in a browser
              window. The window will also be sized to wrap its contents.</li>
            <li><code>dependent</code> - The new window belongs to the calling
              window, on operating systems that support this behaviour. This is
              the kind of window that is minimized along with its parent/owner;
              a &quot;popup&quot; or &quot;transient&quot; window, or whatever
              word your OS has chosen to use.</li>
            <li><code>dialog</code> - Use a dialog-style window border.</li>
            <li><code>modal</code> - The window will be run modally. The call
              to <code>window.open</code> will not return until the user has dismissed
              the window. Note that <code>modal</code> implies <code>dependent</code>.</li>
          </ul>
        
        <li>Misunderstood Features
          <ul>
            <li>The following features are not implemented at time of writing:
              all z-ordering features (<code>alwaysLowered</code>, <code>alwaysRaised</code>,
              <code>z-lock</code>), <code>as well as copyhistory</code>, <code>hotkeys</code>,
              <code>screenX</code>, <code>screenY</code>, and <code>scrollbars</code>.</li>
          </ul>
        
        <li>Default Behaviour - As always, if no parameter is passed, all chrome
          is assumed turned on. Exceptions are the behaviour flags <code>chrome</code>,
          <code>dependent</code>, <code>dialog</code> and <code>modal</code>:
          these are not turned on unless done explicitly. If any string at all,
          even a zero-length string, is given in the <code>features</code> parameter,
          any features not explicitly mentioned are assumed off. <code>titlebar</code>
          and <code>close</code> are the two exceptions: they are not considered
          off unless explicitly mentioned (&quot;<code>titlebar=no</code>&quot;),
          since anything else would break extant script.</li>
      </ul>
      <h3 id="opendialog"><code>window.openDialog</code></h3>
      <p><code>openDialog(URL[, windowName [, windowFeatures [, args]]])</code></p>
      <p><code>window.openDialog</code> is an extension to <code>window.open</code>.
        It behaves the same, except that it can optionally take one or more parameters
        past <code>windowFeatures</code>, and <code>windowFeatures</code> itself
        is treated a little differently.</p>
      <p>The optional parameters, if present, will be bundled up in a JavaScript
        array and added to the newly created window as a property named <code>arguments</code>.
        They may be referenced in the JavaScript of the window at any time, including
        during the execution of an <code>onload</code> handler. These parameters
        may be used, then, to pass arguments to and from the dialog window.</p>
      <p>A dialog summoned up</p>
      <p> <code>openDialog(&quot;http://zzz.xul&quot;, &quot;dlg&quot;, &quot;&quot;,
        &quot;pizza&quot;, 6.98)</code></p>
      <p>could reference the &quot;pizza&quot; string as <code>window.arguments[0]</code>,
        and the number as <code>window.arguments[1]</code>.</p>
      <p><code>openDialog</code> treats the <code>features</code> parameter exactly
        as does <code>open</code>, with the following differences.</p>
      <ul>
        <li>New Features
          <ul>
            <li><code>all</code> - Initially activates (or deactivates (&quot;<code>all=no</code>&quot;))
              all chrome (except the behaviour flags <code>chrome</code>, <code>dialog</code>
              and <code>modal</code>). These can be overridden (so &quot;<code>menubar=no,all</code>&quot;
              turns on all chrome except the menubar.) This feature is explicitly
              ignored by <code>window.open</code>. <code>window.openDialog</code>
              finds it useful because of its different default assumptions.</li>
          </ul>
        
        <li>Default behaviour - The <code>chrome</code> and <code>dialog</code>
          features are always assumed on, unless explicitly turned off (&quot;<code>chrome=no</code>&quot;).
          <code>openDialog</code> treats the absence of the features parameter
          as does <code>window.open</code>, (that is, an empty string sets all
          features to off) except <code>chrome</code> and <code>dialog</code>,
          which default to on. If the <code>features</code> parameter is a zero-length
          string, or contains only one or more of the behaviour features (<code>chrome</code>,
          <code>dependent</code>, <code>dialog</code> and <code>modal</code>) the chrome features
          are assumed &quot;OS' choice.&quot; That is, window creation code is
          not given specific instructions, but is instead allowed to select the
          chrome that best fits a dialog on that operating system.</li>
      </ul>
      <h3 id="sizetocontent"><code>window.sizeToContent</code></h3>
      <p><code>sizeToContent()</code></p>
      <p>This reflows the window's content, and wraps the window around those
        contents. It functions even on fixed size windows (that is, windows with
        the &quot;resizable&quot; flag turned off.) This function's intended use
        is with intrinsically sized windows (those which are designed to wrap
        themselves to fit their content) after changing that content, presumably
        during the execution of an <code>onload</code> handler. See notes on intrinsic
        sizing <a href="#intrinsicsizing">elsewhere</a>.</p>
      <h3>window._content</h3>
      <p>Standard JavaScript assumes a standard browser window built on immutable
        contents: a menubar, a set of toolbars, and the point of this feature,
        a single HTML content area. Windows described by XUL can have any or none
        of any of these things. If the window is to include &quot;content,&quot;
        that is, a self-contained rectangle capable of displaying the contents
        of an arbitrary URL, then it must contain one (or more) content area(s).
        An example of a window that includes a content area is a browser window.
        An example of a window that does not is a simple dialog.</p>
      <p>Content areas are embedded in the window UI using an <code>iframe</code>.
        (Or a <code>browser</code> or <code>editor</code> tag; more readable synonyms for <code>iframe</code>.)
        The best documentation on this is, unfortunately, the XUL files in the
        Mozilla source. An <code>iframe</code> corresponds to a JavaScript <code>window</code>
        object. Note that the window UI (or chrome) is itself (XUL) content, described
        by a URL. It corresponds to a <code>window</code> object, as well. A content
        area is, once again, a container for URLs within URLs.
      <p>JavaScript code wishing to refer to the main content area of a window
        can simply use the window's <code>_content</code> property. A bookmark
        in another iframe or a menu item, for instance, for navigating to mozilla.org
        could be implemented using JavaScript reading</p>
      <p><code>window._content.location.href = &quot;http://www.mozilla.org/&quot;</code></p>
      <p>(Note that another iframe is another window. You need to use the
        correct window object, which, depending on the arrangement of a window's
        frames, may be a different window; perahaps <code>parent._content</code>.)</p>
      <p><code>window._content</code> is merely a shortcut for finding whatever
        was described in the XUL file as being the window's primary content area.
        That description is accomplished using the <code>iframe</code>'s <code>type</code>
        attribute. Mozilla makes note of all <code>iframe</code>s with a <code>type</code>
        of <code>content</code> (or <code>content-&lt;anything&gt;</code>). At this time, they just exchange insurance information
        and carry on; little is done with content frames. However, the <code>window._content</code>
        property returns the particular JavaScript <code>window</code> corresponding
        to the <code>iframe</code> with a <code>type</code> of <code>content-primary</code>.
        So for this shortcut to work, there must be an <code>iframe</code> declared</p>
      <p><code>&lt;iframe type=&quot;content-primary&quot; .../&gt;</code></p>
      <p>somewhere in the window description. (Yes, a JavaScript <code>window</code>
        can be either a real window or a content area. If you find this confusing,
        a good JavaScript book may help.)</p>
      <p>The content area can also be referenced using the <code>target</code>
        attribute of a link:</p>
      <p><code>&lt;a target=&quot;_content&quot; href=&quot;http://www.mozilla.org&quot;&gt;visit
        Mozilla&lt;/a&gt;</code></p>
      <h3>window.title</h3>
      <p>This is a property of the XUL <code>window</code> object which is reflected
        into the window titlebar. It is functionally equivalent to the HTML <code>document.title</code>
        property, but is a more natural way to affect the window's titlebar than
        through the <code>document</code>.</p>
      <h3><code>close</code> event handler</h3>
      <p>Standard HTML defines <code>load</code> and <code>unload</code> events,
        triggered when those two things happen to documents. Mozilla additionally
        defines a <code>close</code> event, triggered when a close request is
        made on a window. (Say, the user clicks the &quot;close&quot; widget.)
        A <code>close</code> event handler is different from <code>unload</code>
        in that it intercepts the impending closure and gives the app a chance
        to head it off. <code>unload</code>, in contrast, is called when document
        unloading is inevitable.</p>
      <p>The new event is intended to provide a hook for things like a &quot;Save
        changes before closing? [OK] [Cancel]&quot; dialog; a capability missing
        from HTML. If there is no <code>close</code> event handler on a Mozilla
        window, it will close as expected. If there is a <code>close</code> event
        handler, it should return a boolean value. It can explicitly close the
        window (<code>window.close()</code>), or return <code>true</code>. It
        must return <code>false</code> to stop event handling (aborting window
        closure.) In all cases, the <code>unload</code> event will still fire
        as the window is closing.</p>
      <h2 id="examples">Examples</h2>
      <p>The following XUL describes a window containing a couple of
         buttons. One will open another window: a nonmodal dialog,
         with a bit of imagination.
         It uses the extended <code>window.open</code> syntax to pass
         parameters to the dialog window, and in a JS object so the
         new window can modify the parameters and return the modified
         values to this window. The other button uses a debug
         function <code>dump</code> to print to the console. It will
         do nothing in an optimized or production build. In that case,
         you can use the more intrusive but always functional
         <code>alert</code>.</p>
 <pre class="code">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;?xml-stylesheet href=&quot;chrome://global/skin/&quot; type=&quot;text/css&quot;?&gt;
&lt;!DOCTYPE window&gt;
&lt;!-- Simple sample interface for bringing up a nonmodal dialog --&gt;
&lt;window
  xmlns:html=&quot;http://www.w3.org/1999/xhtml&quot;
  xmlns =&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;
  orient=&quot;vertical&quot;
  title = &quot;Dialog creation sample&quot;&gt;

&lt;html:script&gt;
  &lt;![CDATA[
  var dialogWindow = null;
  var ioSettings = new Boolean();

  // create a newdialog window, passing a couple of named parameters
  function MakeParamDialog() {
    var newWin = window.openDialog(&quot;madedialog.xul&quot;,
      &quot;_blank&quot;, &quot;chrome&quot;,
      {remind:true, prompt:&quot;Give me your money and convertible bonds&quot;});
    return newWin;
  }

  // cheesy demonstration that values are being returned
  function DumpObject(what) {
    dump(&quot;dumping object: &quot; + what + &quot;\n&quot;);
    for (prop in what)
      dump(&quot; property '&quot; + prop + &quot;' = '&quot; + what[prop] + &quot;'\n&quot;);
    dump(&quot;dumped.\n&quot;);
  }
  ]]&gt;
&lt;/html:script&gt;

&lt;box orient=&quot;horizontal&quot;&gt;
  &lt;button value=&quot;Make Dialog&quot; onclick=&quot;dialogWindow=MakeParamDialog()&quot;/&gt;
  &lt;spring style=&quot;width: 8px&quot;/&gt;
  &lt;button value=&quot;Dump Window&quot; onclick=&quot;DumpObject(dialogWindow.arguments[0])&quot;/&gt;
  &lt;spring flex=&quot;1&quot;/&gt;
&lt;/box&gt;
&lt;spring flex=&quot;1&quot;/&gt;

&lt;/window&gt;</pre>

      <p>The above code will produce a live window with a functional button if
        placed in a file named, perhaps, <code class="filename">makedialog.xul</code>, and
        another XUL file describing the dialog to open named
        <code>madedialog.xul</code> in the same directory.
        It relies on the Mozilla installation to locate the
        specified stylesheet (a typical installation will load
        <code>global.css</code> from the selected skin).
        Launch <code>apprunner</code> pointing at that file to load it
        into the main window.
      <p><code class="command">apprunner -url file:///samples/makedialog.xul</code>
      <p>The following example <code>madedialog.xul</code> window
        contains initialization code which uses the parameters passed
        by the <code>window.openDialog</code> call. Note that
        other documentation covers the widgetry and contents of a window.
        The <a href="boxes.html">box documentation</a> is a good place
        to begin.
 <pre class="code">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;?xml-stylesheet href=&quot;chrome://global/skin/&quot; type=&quot;text/css&quot;?&gt;
&lt;!DOCTYPE window&gt;
&lt;!-- dialog containing a control requiring initial setup --&gt;
&lt;window
  xmlns:html=&quot;http://www.w3.org/1999/xhtml&quot;
  xmlns=&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;
  onload=&quot;SetFromParams()&quot;
  orient=&quot;vertical&quot;
  title=&quot;Things to do&quot;&gt;

&lt;html:script&gt;
&lt;![CDATA[
// Initialize controls from parameters sent through openDialog
function SetFromParams() {
// look in arguments[0] for interesting properties and values
// set checkbox from that, if present
  if (window.arguments &amp;&amp; window.arguments[0]) {
    var setting;
    var control;
    // set checkbox from the value of argment[0]'s &quot;value&quot; property
    if (window.arguments[0].remind) {
      setting = window.arguments[0].remind;
      control = document.getElementById(&quot;remind&quot;);
      if (control)
        if (typeof setting == &quot;boolean&quot;)
          control.checked = setting;
        else if (typeof setting == &quot;object&quot;)
          control.checked = setting.valueOf();
    }
    // set prompt from the value of argment[0]'s &quot;prompt&quot; property
    if (window.arguments[0].prompt) {
      setting = window.arguments[0].prompt;
      if (typeof setting == &quot;string&quot;) {
        control = document.getElementById(&quot;prompt&quot;);
        if (control)
          control.setAttribute(&quot;value&quot;, setting);
      }
    }
  }
}

// OK button handler
// just close the window, since the checkbox is updating live
function DoOK() {
  window.close();
}

function copyToArgs(checkbox) {
  // if we were given an openDialog parameter, set its value
  if (window.arguments &amp;&amp; window.arguments[0])
    window.arguments[0].remind = checkbox.checked;
}
]]&gt;
&lt;/html:script&gt;

&lt;text id=&quot;prompt&quot; value=&quot;Give me your money&quot;/&gt;
&lt;checkbox id=&quot;remind&quot; value=&quot;remind&quot; oncommand=&quot;copyToArgs(this)&quot;/&gt;
&lt;button value=&quot;OK&quot; onclick=&quot;DoOK()&quot;/&gt;

&lt;/window&gt;</pre>



<hr class="hide">
</div>
</div>
<div id="footer">
<ul>
<li><a href="../../sitemap.html">Site Map</a></li>
<li><a href="../../security/">Security Updates</a></li>
<li><a href="../../contact/">Contact Us</a></li>
<li><a href="../../foundation/donate.html">Donate</a></li>
</ul>
<p class="copyright">
Portions of this content are &copy; 1998&#8211;2009 by individual mozilla.org
contributors; content available under a Creative Commons license | <a
href="http://www.mozilla.org/foundation/licensing/website-content.html">Details</a>.</p>
<p>
<span>Last modified October 28,  2006</span>
<span><a href="http://bonsai-www.mozilla.org/cvslog.cgi?file=mozilla-org/html/xpfe/xptoolkit/windows.html&amp;rev=&amp;root=/www/">Document History</a></span>
</p>
</div>
</div>
</body>
</html>
